#ifndef MATH_HPP
#define MATH_HPP

#include "vec.hpp"
#include "string.hpp"
#include <random>
#include <cmath>

static const double dnan = std::numeric_limits<double>::quiet_NaN();
static const float  fnan = std::numeric_limits<float>::quiet_NaN();
static const double dinf = std::numeric_limits<double>::infinity();
static const float  finf = std::numeric_limits<float>::infinity();
static const double dpi = 3.14159265359;
static const float  fpi = 3.14159265359;

// Create a range.
template<typename T>
vec1i rgen(T n) {
    phypp_check(n >= 0, "'rgen(n)' needs a positive or null value for 'n' (got ", n, ")");
    
    vec1i v = intarr(n);
    for (int_t k = 0; k < int_t(n); ++k) {
        v[k] = k; 
    }
    
    return v;
}

template<typename T, typename U>
vec1i rgen(T i, U j) {
    if (i < T(j)) {
        int_t n = j-i+1;
        vec1i v = intarr(n);
        for (int_t k = 0; k < n; ++k) {
            v[k] = i+k; 
        }
        return v;
    } else {   
        int_t n = i-j+1;
        vec1i v = intarr(n);
        for (int_t k = 0; k < n; ++k) {
            v[k] = i-k;
        }
        return v;
    }
}

template<typename T, typename U, typename V>
vec1d rgen(T i, U j, V n) {
    phypp_check(n >= 0, "'rgen(a,b,n)' needs a positive or null value for 'n' (got ", n, ")");
    
    if (n == 1) {
        vec1d v = dindgen(1);
        v[0] = i;
        return v;
    } else {
        vec1d v = dindgen(n);
        
        double dx = (j-i)/double(n-1); 
        for (int_t k = 0; k < int_t(n); ++k) {
            v[k] = i + k*dx; 
        }
        
        return v;
    }
}

template<typename T, typename U, typename V>
vec1d rgen_log(T i, U j, V n) {
    phypp_check(n >= 0, "'rgen_log(a,b,n)' needs a positive or null value for 'n' (got ", n, ")");
    
    if (n == 1) {
        vec1d v = dindgen(1);
        v[0] = i;
        return v;
    } else {
        vec1d v = dindgen(n);
        
        double dx = log10(j/i)/double(n-1); 
        for (int_t k = 0; k < int_t(n); ++k) {
            v[k] = i*pow(10.0, k*dx); 
        }
        
        return v;
    }
}

template<typename T, typename enable = typename std::enable_if<!is_vec<T>::value>::type>
bool finite(const T& t) {
    return std::isfinite(t); 
}

template<std::size_t Dim, typename Type>
vec_t<Dim,bool> finite(const vec_t<Dim,Type>& v) {
    vec_t<Dim,bool> r = boolarr(v.dims);
    for (uint_t i = 0; i < v.size(); ++i) {
        r[i] = std::isfinite(v[i]); 
    }
    
    return r;
}

template<typename T, typename ... Args>
vec_t<sizeof...(Args),double> randomn(T& seed, Args&& ... args) {
    vec_t<sizeof...(Args),double> v = dblarr(std::forward<Args>(args)...);
    
    std::mt19937 generator(seed);
    std::normal_distribution<double> distribution(0.0, 1.0);
    for (uint_t i = 0; i < v.size(); ++i) {
        v.data[i] = distribution(generator);
    }
    
    seed = generator();
    
    return v;
}

template<typename T, typename ... Args>
vec_t<sizeof...(Args),double> randomu(T& seed, Args&& ... args) {
    vec_t<sizeof...(Args),double> v = dblarr(std::forward<Args>(args)...);
    
    std::mt19937 generator(seed);
    std::uniform_real_distribution<double> distribution(0.0, 1.0);
    for (uint_t i = 0; i < v.size(); ++i) {
        v.data[i] = distribution(generator);
    }
    
    seed = generator();
    
    return v;
}

template<std::size_t Dim, typename Type, typename T>
auto shuffle(const vec_t<Dim,Type>& v, T& seed) {
    vec1i sid = sort(randomu(seed, v.size()));
    return v[sid];
}

template<typename F, F f, std::size_t Dim, typename Type>
auto run_index_(const vec_t<Dim,Type>& v, uint_t dim) -> vec_t<Dim-1,typename return_type<F>::type> {
    vec_t<Dim-1,typename return_type<F>::type> r;
    for (uint_t i = 0; i < dim; ++i) {
        r.dims[i] = v.dims[i];
    }
    for (uint_t i = dim+1; i < Dim; ++i) {
        r.dims[i-1] = v.dims[i];
    }
    r.resize();
    
    uint_t mpitch = 1;
    for (uint_t i = dim+1; i < Dim; ++i) {
        mpitch *= v.dims[i];
    }

//  Example demonstration of the index computation:
//  
//  Assume we have a 4D array of dimensions d1, d2, d3 and d4.
//  We want to compute an operation on the array generated by:
//      data[i*d2*d3*d4 + j*d3*d4 + k*d4 + l]
//  and by running the 'dim'th index (i, j, k or l), assigning
//  the value to another 3D array using a continuous index 'u'.
//          
//  - (i,j,k,_) : k+j*d3+i*d2*d3 = u : mean(((u/1)*d4 + l)*1 + (u%1))
//      mpitch = 1
//        
//  - (i,j,_,l) : l+j*d4+i*d2*d4 = u : mean(((u/d4)*d3 + k)*d4 + (u%d4))
//      mpitch = d4
//        
//  - (i,_,k,l) : l+k*d4+i*d3*d4 = u : mean(((u/(d3*d4))*d2 + j)*d3*d4 + (u%(d3*d4)))
//      mpitch = d4*d3
//            
//  - (_,j,k,l) : l+k*d4+j*d3*d4 = u : mean(((u/(d4*d3*d2))*d1 + i)*d2*d3*d4 + (u%(d4*d3*d2)))
//      mpitch = d4*d3*d2
//  
//  Final recipe:          
//      ((u/mpitch)*dim[d] + i)*mpitch + (u%mpitch)
    
    typename vec_t<1,Type>::effective_type tmp = arr<rtype_t<Type>>(v.dims[dim]);
    for (uint_t i = 0; i < r.size(); ++i) {
        for (uint_t j = 0; j < v.dims[dim]; ++j) {
            tmp[j] = dref(v.data[(i%mpitch) + ((i/mpitch)*v.dims[dim] + j)*mpitch]);
        }
        
        r[i] = (*f)(tmp);
    }
    
    return r;
}

template<std::size_t Dim, typename Type>
double total(const vec_t<Dim,Type>& v) {
    double total = 0;
    for (auto& t : v) {
        total += t;
    }
    
    return total;
}

template<std::size_t Dim, typename Type>
double mean(const vec_t<Dim,Type>& v) {
    double total = 0.0;
    for (auto& t : v) {
        total += t;
    }
    
    return total/n_elements(v);
}

template<std::size_t Dim, typename Type>
vec_t<Dim-1,double> mean(const vec_t<Dim,Type>& v, uint_t dim) {
    using fptr = double (*)(const vec_t<1,rtype_t<Type>>&);
    return run_index_<fptr, &mean<1,rtype_t<Type>>>(v, dim);
}

template<std::size_t Dim, typename Type>
rtype_t<Type> median(const vec_t<Dim,Type>& v) {
    vec_t<1,int_t> ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;
    
    typename vec_t<1,Type>::effective_type t = v[ok];
    std::ptrdiff_t offset = t.size()/2;
    std::nth_element(t.begin(), t.begin() + offset, t.end());
    return *(t.begin() + offset);
}

template<std::size_t Dim, typename Type>
vec_t<Dim-1,rtype_t<Type>> median(const vec_t<Dim,Type>& v, uint_t dim) {
    using fptr = rtype_t<Type> (*)(const vec_t<1,rtype_t<Type>>&);
    return run_index_<fptr, &median<1,rtype_t<Type>>>(v, dim);
}

template<std::size_t Dim, typename Type, typename U>
rtype_t<Type> percentile(const vec_t<Dim,Type>& v, const U& u) {
    vec_t<1,int_t> ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;
    
    typename vec_t<1,Type>::effective_type t = v[ok];
    std::ptrdiff_t offset = t.size()*u;
    std::nth_element(t.begin(), t.begin() + offset, t.end());
    return *(t.begin() + offset);
}

template<std::size_t Dim, typename Type>
void percentiles_(vec_t<1,Type>& r, uint_t i, vec_t<Dim,Type>& t) {}

template<std::size_t Dim, typename Type, typename U, typename ... Args>
void percentiles_(vec_t<1,Type>& r, uint_t i, vec_t<Dim,Type>& t, const U& u, const Args& ... args) {
    std::ptrdiff_t offset = t.size()*u;
    std::nth_element(t.begin(), t.begin() + offset, t.end());
    r.data[i] = *(t.begin() + offset);
    ++i;
    
    percentiles_(r, i, t, args...);
}

template<std::size_t Dim, typename Type, typename ... Args>
typename vec_t<1,Type>::effective_type percentiles(const vec_t<Dim,Type>& v, const Args& ... args) {
    vec_t<1,int_t> ok = where(finite(v));
    typename vec_t<1,Type>::effective_type t;
    if (n_elements(ok) == 0) return t;
    t = v[ok];

    typename vec_t<1,Type>::effective_type r = arr<rtype_t<Type>>(sizeof...(Args));
    percentiles_(r, 0, t, args...);
    
    return r;
}

template<std::size_t Dim, typename Type>
rtype_t<Type> min(const vec_t<Dim,Type>& v) {
    vec1i ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;
    
    typename vec_t<1,Type>::effective_type t = v[ok];
    std::nth_element(t.begin(), t.begin(), t.end());
    return *t.begin();
}

template<std::size_t Dim, typename Type>
rtype_t<Type> max(const vec_t<Dim,Type>& v) {
    vec1i ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;
    
    typename vec_t<1,Type>::effective_type t = v[ok];
    std::nth_element(t.begin(), t.end()-1, t.end());
    return *(t.end()-1);
}

template<std::size_t Dim, typename Type>
uint_t min_id(const vec_t<Dim,Type>& v) {
    vec1i ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;

    using ntype = typename vec_t<Dim,Type>::drtype;
    struct tsort {
        ntype v;
        int_t i;
    };
    
    std::vector<tsort> tmp(ok.size());
    for (uint_t i = 0; i < ok.size(); ++i) {
        tmp[i].v = dref(v.data[ok.data[i]]);
        tmp[i].i = ok.data[i];
    }
    
    std::nth_element(tmp.begin(), tmp.begin(), tmp.end(), 
        [](const tsort& t1, const tsort& t2) { return t1.v < t2.v; }
    );

    return tmp.begin()->i;
}

template<std::size_t Dim, typename Type>
uint_t max_id(const vec_t<Dim,Type>& v) {
    vec1i ok = where(finite(v));
    if (n_elements(ok) == 0) return 0;

    using ntype = typename vec_t<Dim,Type>::drtype;
    struct tsort {
        ntype v;
        int_t i;
    };
    
    std::vector<tsort> tmp(ok.size());
    for (uint_t i = 0; i < ok.size(); ++i) {
        tmp[i].v = dref(v.data[ok.data[i]]);
        tmp[i].i = ok.data[i];
    }
    
    std::nth_element(tmp.begin(), tmp.end()-1, tmp.end(), 
        [](const tsort& t1, const tsort& t2) { return t1.v < t2.v; }
    );

    return (tmp.end()-1)->i;
}

template<std::size_t Dim, typename Type1, typename Type2>
vec_t<Dim,rtype_t<Type1>> min(const vec_t<Dim,Type1>& v1, const vec_t<Dim,Type2>& v2) {
    phypp_check(v1.dims == v2.dims, "min: incompatible vector dimensions");
    vec_t<Dim,rtype_t<Type1>> r = arr<rtype_t<Type1>>(v1.dims);
    for (uint_t i = 0; i < v1.size(); ++i) {
        r[i] = std::min(v1[i], v2[i]);
    }
    return r;
}

template<std::size_t Dim, typename Type1, typename Type2>
vec_t<Dim,rtype_t<Type1>> max(const vec_t<Dim,Type1>& v1, const vec_t<Dim,Type2>& v2) {
    phypp_check(v1.dims == v2.dims, "max: incompatible vector dimensions");
    vec_t<Dim,rtype_t<Type1>> r = arr<rtype_t<Type1>>(v1.dims);
    for (uint_t i = 0; i < v1.size(); ++i) {
        r[i] = std::max(v1[i], v2[i]);
    }
    return r;
}

template<std::size_t Dim, typename T>
double stddev(const vec_t<Dim,T>& v) {
    return sqrt(mean(v*v));
}

template<std::size_t Dim, typename Type>
void data_info_(const vec_t<Dim,Type>& v) {
    vec1i idok = where(finite(v));
    print(n_elements(idok), "/", n_elements(v), " valid values (dims: ", dim(v), ")");
    if (n_elements(idok) == 0) return;
    print(" min : ", min(v[idok]));
    print(" 15% : ", percentile(v[idok], 0.15));
    print(" 50% : ", median(v[idok]));
    print(" mean: ", mean(v[idok]));
    print(" 85% : ", percentile(v[idok], 0.85));
    print(" max : ", max(v[idok]));
    print(" rms : ", stddev(v[idok] - median(v[idok])));
}

#define data_info(x) \
    print("data info: ", #x); \
    data_info_(x);

template<typename T, typename U, typename V,
    typename enable = typename std::enable_if<!is_vec<T>::value>::type>
auto clamp(const T& t, const U& mi, const V& ma) {
    return (t < mi ? mi : (t > ma ? ma : t));
}

template<std::size_t Dim, typename Type, typename U, 
    typename enable = typename std::enable_if<!is_vec<U>::value>::type>
auto pow(const U& u, const vec_t<Dim,Type>& v) -> vec_t<Dim, decltype(pow(u,v(0)))> {
    vec_t<Dim, decltype(pow(u,v(0)))> r = v;
    for (auto& t : r) {
        t = pow(u,t);
    }
    return r;
}

#define VECTORIZE(name) \
    template<std::size_t Dim, typename Type, typename ... Args> \
    auto name(const vec_t<Dim,Type>& v, const Args& ... args) { \
        using ntype = decltype(name(v[0], args...)); \
        vec_t<Dim,ntype> r = arr<ntype>(v.dims); \
        for (uint_t i = 0; i < v.size(); ++i) { \
            r.data[i] = name(dref(v.data[i]), args...); \
        } \
        return r; \
    }
    
VECTORIZE(sqrt);
VECTORIZE(pow);
VECTORIZE(cos);
VECTORIZE(sin);
VECTORIZE(tan);
VECTORIZE(acos);
VECTORIZE(asin);
VECTORIZE(atan);
VECTORIZE(cosh);
VECTORIZE(sinh);
VECTORIZE(tanh);
VECTORIZE(acosh);
VECTORIZE(asinh);
VECTORIZE(atanh);
VECTORIZE(exp);
VECTORIZE(log);
VECTORIZE(log2);
VECTORIZE(log10);
VECTORIZE(erf);
VECTORIZE(erfc);
VECTORIZE(tgamma);
VECTORIZE(ceil);
VECTORIZE(floor);
VECTORIZE(round);
VECTORIZE(fabs);
VECTORIZE(clamp);
    
#undef VECTORIZE

template<typename T>
auto e10(const T& t) {
    return pow(10.0, t);
}

template<typename F>
auto derivate1(F func, const vec1d& x, const double ep, uint_t ip) -> decltype(func(x)) {
    static const double a[5] = {1.0/12.0, -2.0/3.0, 0.0, 2.0/3.0, -1.0/12.0};
    
    vec1d tmp = x;
    tmp(ip) -= 2*ep;
    
    decltype(func(x)) res = a[0]*func(tmp)/ep;
    for (uint_t i = 1; i < 5; ++i) {
        tmp(ip) += ep;
        res += a[i]*func(tmp)/ep;
    }
            
    return res;
}

template<typename F>
auto derivate2(F func, const vec1d& x, const double ep, uint_t ip) -> decltype(func(x)) {
    static const double a[5] = {-1.0/12.0, 4.0/3.0, -5.0/2.0, 4.0/3.0, -1.0/12.0};
    
    vec1d tmp = x;
    tmp(ip) -= 2*ep;
    
    decltype(func(x)) res = a[0]*func(tmp)/(ep*ep);
    for (uint_t i = 1; i < 5; ++i) {
        tmp(ip) += ep;
        res += a[i]*func(tmp)/(ep*ep);
    }
            
    return res;
}

template<typename F>
auto derivate2(F func, const vec1d& x, const double ep, uint_t ip1, uint_t ip2) -> decltype(func(x)) {
    static const double a[5] = {1.0/12.0, -2.0/3.0, 0.0, 2.0/3.0, -1.0/12.0};
    
    vec1d tmp = x;
    tmp(ip1) -= 2*ep;
    tmp(ip2) -= 2*ep;
    
    decltype(func(x)) res = a[0]*a[0]*func(tmp)/(ep*ep);
    for (uint_t j = 1; j < 5; ++j) {
        tmp(ip2) += ep;
        res += a[0]*a[j]*func(tmp)/(ep*ep);
    }
    
    for (uint_t i = 1; i < 5; ++i) {
        tmp(ip1) += ep;
        tmp(ip2) = x(ip2) - 2*ep;
        
        res += a[i]*a[0]*func(tmp)/(ep*ep);
        for (uint_t j = 1; j < 5; ++j) {
            tmp(ip2) += ep;
            res += a[i]*a[j]*func(tmp)/(ep*ep);
        }
    }
            
    return res;
}

template<typename TypeA, typename TypeB>
auto mmul(const vec_t<2,TypeA>& a, const vec_t<2,TypeB>& b) -> vec_t<2,decltype(a(0,0)*b(0,0))> {
    assert(a.dims[1] == b.dims[0]);
    const int_t o = a.dims[1];
    
    using ntype_t = decltype(a(0,0)*b(0,0));
    const int_t n = a.dims[0];
    const int_t m = b.dims[1];
    
    vec_t<2,ntype_t> r = arr<ntype_t>(n,m);
    for (int_t i = 0; i < n; ++i)
    for (int_t j = 0; j < m; ++j) 
    for (int_t k = 0; k < o; ++k) {
        r(i,j) += a(i,k)*b(k,j);    
    } 
    
    return r;
}

template<typename TypeA, typename TypeB>
auto mmul(const vec_t<2,TypeA>& a, const vec_t<1,TypeB>& b) -> vec_t<1,decltype(a(0,0)*b(0,0))> {
    assert(a.dims[1] == b.dims[0]);
    const int_t o = a.dims[1];
    
    using ntype_t = decltype(a(0,0)*b(0,0));
    const int_t n = a.dims[0];
    
    vec_t<1,ntype_t> r = arr<ntype_t>(n);
    for (int_t i = 0; i < n; ++i)
    for (int_t k = 0; k < o; ++k) {
        r(i) += a(i,k)*b(k);
    } 
    
    return r;
}

template<typename TypeA, typename TypeB>
auto mmul(const vec_t<1,TypeB>& b, const vec_t<2,TypeA>& a) -> vec_t<1,decltype(a(0,0)*b(0,0))> {
    assert(a.dims[0] == b.dims[0]);
    const int_t o = a.dims[0];
    
    using ntype_t = decltype(a(0,0)*b(0,0));
    const int_t n = a.dims[1];
    
    vec_t<1,ntype_t> r = arr<ntype_t>(n);
    for (int_t i = 0; i < n; ++i)
    for (int_t k = 0; k < o; ++k) {
        r(i) += b(k)*a(k,i);
    } 
    
    return r;
}

template<typename Type>
void mprint(const vec_t<2,Type>& m) {
    for (uint_t i = 0; i < m.dims[0]; ++i) {
        for (uint_t j = 0; j < m.dims[1]; ++j) {
            if (j != 0) std::cout << ", ";
            std::cout << m(i,j);
        }
        
        std::cout << "\n";
    }
    
    std::cout << std::flush;
}

template<typename Type>
vec_t<2,rtype_t<Type>> transpose(const vec_t<2,Type>& v) {
    vec_t<2,rtype_t<Type>> r = arr<rtype_t<Type>>(v.dims[1], v.dims[0]);
    
    for (uint_t i = 0; i < v.dims[0]; ++i)
    for (uint_t j = 0; j < v.dims[1]; ++j) {
        r(j,i) = v(i,j);
    }
    
    return r;
}

template<typename Type>
auto diag(const vec_t<2,Type>& v) -> decltype(v(_,0)) {
    assert(v.dims[0] == v.dims[1]);
    decltype(v(_,0)) d(get_parent(v));
    d.dims[0] = v.dims[0];
    d.resize();
    for (uint_t i = 0; i < v.dims[0]; ++i) {
        d.data[i] = &v(i,i);
    }
    
    return d;
}

template<typename Type>
auto diag(vec_t<2,Type>& v) -> decltype(v(_,0)) {
    assert(v.dims[0] == v.dims[1]);
    decltype(v(_,0)) d(get_parent(v));
    d.dims[0] = v.dims[0];
    d.resize();
    for (uint_t i = 0; i < v.dims[0]; ++i) {
        d.data[i] = &v(i,i);
    }
    
    return d;
}

template<typename Type = double>
auto identity_matrix(uint_t dim) {
    auto m = arr<Type>(dim, dim);
    diag(m) = 1;
    return m;
}

template<typename TX, typename TY>
auto scale_matrix(const TX& sx, const TY& sy) {
    auto m = arr<decltype(sx*sy)>(3, 3);
    m(0,0) = sx;
    m(1,1) = sy;
    m(2,2) = 1;
    return m;
}

template<typename T>
auto scale_matrix(const T& s) {
    auto m = arr<T>(3, 3);
    m(0,0) = s;
    m(1,1) = s;
    m(2,2) = 1;
    return m;
}

template<typename TX, typename TY>
auto translation_matrix(const TX& tx, const TY& ty) {
    auto m = arr<decltype(tx*ty)>(3, 3);
    diag(m) = 1;
    m(0,2) = tx;
    m(1,2) = ty;
    return m;
}

template<typename A>
auto rotation_matrix(const A& a) {
    auto m = arr<decltype(cos(a))>(3, 3);
    auto ca = cos(a), sa = sin(a);
    m(0,0) = m(1,1) = ca;
    m(0,1) = -sa;
    m(1,0) = sa;
    m(2,2) = 1;
    return m;
}

template<typename TX, typename TY>
auto point2d(const TX& x, const TY& y) {
    return vec_t<1,decltype(x*y)>{x, y, 1};
}

extern "C" void dgetrf_(int* n, int* m, double* a, int* lda, int* ipiv, int* info);
extern "C" void dgetri_(int* n, double* a, int* lda, int* ipiv, double* work, int* lwork, int* info);

bool invert(vec2d& i) {
    assert(i.dims[0] == i.dims[1]);
    int n = i.dims[0];
    
    int lda = n;
    int info;
    
    vec_t<1,int> ipiv = arr<int>(n);
    dgetrf_(&n, &n, i.data.data(), &lda, ipiv.data.data(), &info);
    if (info < 0) {
        return false;
    }
    
    vec1d work = dblarr(n);
    int lw = n;
    dgetri_(&n, i.data.data(), &lda, ipiv.data.data(), work.data.data(), &lw, &info);
    if (info != 0) {
        return false;
    }
    
    return true;
}

template<typename TypeA>
bool invert(const vec_t<2,TypeA>& a, vec2d& i) {
    i = a;
    return invert(i);
}

enum nlfit_status {
    ILL_MODEL,
    MAX_ITER,
    SINGULAR_HESSIAN,
    MIN_REL,
    MIN_ABS,
    PERFECT_FIT
};

struct nlfit_result {
    bool         success;
    nlfit_status status;
    
    double chi2;
    vec1d  params;
    vec1d  errors;
    vec2d  cov;
    uint_t niter;
};

template<typename Func, typename TypeY, typename TypeE>
nlfit_result nlfit(Func f, const TypeY& y, const TypeE& ye, vec1d params, double e = 0.001,
    double abs = 0.01, const uint_t max_iter = 1000) {

    nlfit_result fr;
    
    int_t np = n_elements(params);
    int_t nm = n_elements(y);
    
    vec2d alpha = dblarr(np,np);
    vec1d beta  = dblarr(np);
    
    vec1d best_params = params;
    vec2d best_alpha  = alpha;
    
    auto make_chi2 = [&](const vec1d& p) {
        return total(pow((f(p) - y)/ye, 2));
    };
    
    double best_chi2 = make_chi2(params);
    double prev_chi2 = best_chi2;
    fr.chi2          = best_chi2;
    
    double lambda = 0.001;
    double factor = 10.0;
    
    fr.errors = dblarr(np);
    fr.niter = 0;
    
    vec2d deriv = dblarr(np,nm);
    
    auto make_alpha = [&]() {
        for (int_t i = 0; i < np; ++i) {
            deriv(i,_) = flatten(derivate1(f, params, 0.001, i)/ye);
        }
        
        auto tmp = flatten((y - f(params))/ye);
        for (int_t i = 0; i < np; ++i) {
            for (int_t j = 0; j < np; ++j) {
                if (i == j) {
                    alpha(i,i) = (1.0 + lambda)*total(deriv(i,_)*deriv(i,_));
                } else if (i < j) {
                    alpha(i,j) = total(deriv(i,_)*deriv(j,_));
                } else {
                    alpha(i,j) = alpha(j,i);
                }
            }
            
            beta(i) = total(deriv(i,_)*tmp);
        }
        
        if (!invert(alpha)) {
            return false;
        } else {
            return true;
        }
    };
    
    auto fail = [&](nlfit_status s) {
        params = best_params;
        if (make_alpha()) {
            best_alpha = alpha;
        }
        
        auto d = diag(best_alpha);
        d /= (1.0 + lambda);
        
        fr.cov     = best_alpha;
        fr.chi2    = best_chi2;
        fr.params  = params;
        fr.errors  = sqrt(d);
        fr.success = false;
        fr.status  = s;
    };
    
    auto succeed = [&](nlfit_status s) {
        if (make_alpha()) {
            best_alpha = alpha;
        }
        
        auto d = diag(best_alpha);
        d /= (1.0 + lambda);
        
        fr.cov     = best_alpha;
        fr.params  = params;
        fr.errors  = sqrt(d);
        fr.success = true;
        fr.status  = s;
    };
    
    while (max_iter == 0 || fr.niter < max_iter) {
        if (!make_alpha()) {
            fail(SINGULAR_HESSIAN);
            return fr;
        }
        
        params += mmul(alpha, beta);
        fr.chi2 = make_chi2(params);
 
        if (!finite(fr.chi2)) {
            fail(ILL_MODEL);
            return fr;
        }
        
        if (fr.chi2 == 0.0) {
            succeed(PERFECT_FIT);
            return fr;
        }
        
        if (fr.chi2 >= best_chi2) {
            lambda *= factor;
            
            prev_chi2 = fr.chi2;
            params = best_params;
        } else {
            if (fr.niter > 10) {
                if ((best_chi2 - fr.chi2)/best_chi2 < e) {
                    succeed(MIN_REL);
                    return fr;
                }
            
                if (abs != 0.0 && fabs(prev_chi2 - fr.chi2) < abs) {
                    succeed(MIN_ABS);
                    return fr;
                }
            }
               
            lambda /= factor;
                
            prev_chi2   = best_chi2 = fr.chi2;
            best_params = params;
            best_alpha  = alpha;
        }
        
        ++fr.niter;
    }
    
    fail(MAX_ITER);
    return fr;
}

struct linfit_result {
    bool success;
    
    double chi2;
    vec1d  params;
    vec1d  errors;
    vec2d  cov;
};

template<typename T, typename TypeE>
void linfit_make_cache_(vec2d& cache, const TypeE& ye, uint_t i, T&& t) {
    cache(i,_) = flatten(t/ye);
}

template<typename T, typename TypeE, typename ... Args>
void linfit_make_cache_(vec2d& cache, const TypeE& ye, uint_t i, T&& t, Args&& ... args) {
    cache(i,_) = flatten(t/ye);
    linfit_make_cache_(cache, ye, i+1, args...);
}

template<typename TypeY, typename TypeE, typename ... Args>
linfit_result linfit(const TypeY& y, const TypeE& ye, Args&&... args) {
    linfit_result fr;
    
    int_t np = sizeof...(Args);
    int_t nm = n_elements(y);
    
    vec2d alpha = dblarr(np,np);
    vec1d beta = dblarr(np);
    
    vec2d cache = dblarr(np,nm);
    linfit_make_cache_(cache, ye, 0, std::forward<Args>(args)...);
    
    auto tmp = flatten(y/ye);
    for (int_t i = 0; i < np; ++i) {
        for (int_t j = 0; j < np; ++j) {
            if (i <= j) {
                alpha(i,j) = total(cache(i,_)*cache(j,_));
            } else {
                alpha(i,j) = alpha(j,i);
            }
        }
    
        beta(i) = total(cache(i,_)*tmp);
    }
    
    if (!invert(alpha)) {
        fr.success = false;
        fr.chi2 = dnan;
        fr.params = dblarr(np)*dnan;
        fr.errors = dblarr(np)*dnan;
        fr.cov = alpha*dnan;
        return fr;
    }
    
    fr.success = true;
    fr.params = mmul(alpha, beta);
    fr.errors = sqrt(diag(alpha));
    
    vec1d model = dblarr(nm);
    for (int_t i = 0; i < nm; ++i) {
        model(i) = total(fr.params*cache(_,i));
    }
    
    fr.chi2 = total(pow(model*flatten(1.0/ye) - flatten(y/ye), 2));
    
    return fr;
}


struct affinefit_result {
    bool success;
    
    double chi2;
    double slope, offset;
    double slope_err, offset_err;
};

// Perform a simple linear fit 'y = offset + slope*x'
template<typename TypeX, typename TypeY, std::size_t Dim, typename TypeE>
affinefit_result affinefit(const TypeX& x, const TypeY& y, const vec_t<Dim,TypeE>& ye) {
    affinefit_result fr;
    fr.success = true;

    auto s = total(1.0/ye);
    auto sx = total(x/ye);
    auto sy = total(y/ye);
    auto sxx = total(x*x/ye);
    auto sxy = total(x*y/ye);
    
    auto delta = s*sxx - sx*sx;
    fr.offset = (sxx*sy - sx*sxy)/delta;
    fr.slope = (s*sxy - sx*sy)/delta;
    fr.offset_err = sqrt(sxx/delta);
    fr.slope_err = sqrt(s/delta);
    
    return fr;
}

// Perform a simple linear fit 'y = offset + slope*x'
template<typename TypeX, typename TypeY, typename TypeE>
affinefit_result affinefit(const TypeX& x, const TypeY& y, const TypeE& ye) {
    affinefit_result fr;
    fr.success = true;

    auto s = n_elements(x)/ye;
    auto sx = total(x/ye);
    auto sy = total(y/ye);
    auto sxx = total(x*x/ye);
    auto sxy = total(x*y/ye);
    
    auto delta = s*sxx - sx*sx;
    fr.offset = (sxx*sy - sx*sxy)/delta;
    fr.slope = (s*sxy - sx*sy)/delta;
    fr.offset_err = sqrt(sxx/delta);
    fr.slope_err = sqrt(s/delta);
    
    return fr;
}

// Returns the position of the first value in the array that is less than or equal to 'x'.
// Returns -1 if no value satisfy this criterium.
// Note: assumes that 'v' is sorted.
template<typename T, typename Type>
int_t lower_bound(T x, const vec_t<1,Type>& v) {
    auto iter = std::upper_bound(v.data.begin(), v.data.end(), x,
        typename vec_t<1,Type>::comparator());

    do {
        if (iter == v.data.begin()) return -1;
        --iter;
    } while (!finite(dref(*iter)));

    return iter - v.data.begin();
}

// Returns the position of the first value in the array that is greater than 'x'.
// Returns -1 if no value satisfy this criterium.
// Note: assumes that 'v' is sorted.
template<typename T, typename Type>
int_t upper_bound(T x, const vec_t<1,Type>& v) {
    auto iter = std::upper_bound(v.data.begin(), v.data.end(), x,
        typename vec_t<1,Type>::comparator());

    if (iter == v.data.end()) {
        return -1;
    } else {
        return iter - v.data.begin();
    }
}

// Check if a given array is sorted or not
template<typename Type>
bool is_sorted(const vec_t<1,Type>& v) {
    const int_t n = n_elements(v);
    for (int_t i = 0; i < n-1; ++i) {
        if (v[i] >= v[i+1]) return false;
    }

    return true;
}

// Linearly interpolate '(x, y)' data at new positions 'nx'
template<typename TypeY, typename TypeX1, typename TypeX2>
auto interpol(const vec_t<1,TypeY>& y, const vec_t<1,TypeX1>& x, const vec_t<1,TypeX2>& nx) {
    using rtypey = rtype_t<TypeY>;
    using rtypex = rtype_t<TypeX1>;

    phypp_check(n_elements(y) == n_elements(x),
        "interpol: 'x' and 'y' arrays must contain the same number of elements");
    phypp_check(n_elements(y) >= 2,
        "interpol: 'x' and 'y' arrays must contain at least 2 elements");
    phypp_check(is_sorted(x), "interpol: 'x' array must be strictly increasing");

    auto idok1 = where(finite(y) && finite(x));
    auto okx = x[idok1];
    auto oky = y[idok1];

    int_t cnt;
    auto idok2 = where(finite(nx), cnt);
    auto r = replicate(y[0]*dnan, n_elements(nx));

    for (int_t i = 0; i < cnt; ++i) {
        int_t j = idok2[i];
        auto tx = nx[j];

        int_t low = lower_bound(tx, okx);
        int_t up  = upper_bound(tx, okx);

        rtypey ylow, yup;
        rtypex xlow, xup;
        if (low >= 0 && up >= 0) {
            ylow = oky[low]; yup = oky[up];
            xlow = okx[low]; xup = okx[up];
        } else if (low < 0) {
            ylow = oky[up]; yup = oky[up+1];
            xlow = okx[up]; xup = okx[up+1];
        } else {
            ylow = oky[low-1]; yup = oky[low];
            xlow = okx[low-1]; xup = okx[low];
        }

        r[j] = ylow + (yup - ylow)*(tx - xlow)/(xup - xlow);
    }

    return r;
}

// Linearly interpolate '(x, y)' data at new positions 'nx'
template<typename TypeY, typename TypeX, typename T, 
    typename enable = typename std::enable_if<!is_vec<T>::value>::type>
auto interpol(const vec_t<1,TypeY>& y, const vec_t<1,TypeX>& x, const T& nx) {
    using rtypey = rtype_t<TypeY>;
    using rtypex = rtype_t<TypeX>;

    phypp_check(n_elements(y) == n_elements(x),
        "interpol: 'x' and 'y' arrays must contain the same number of elements");
    phypp_check(n_elements(y) >= 2,
        "interpol: 'x' and 'y' arrays must contain at least 2 elements");
    phypp_check(is_sorted(x), "interpol: 'x' array must be strictly increasing");

    auto idok1 = where(finite(y) && finite(x));
    auto okx = x[idok1];
    auto oky = y[idok1];

    int_t low = lower_bound(nx, okx);
    int_t up  = upper_bound(nx, okx);

    rtypey ylow, yup;
    rtypex xlow, xup;
    if (low >= 0 && up >= 0) {
        ylow = oky[low]; yup = oky[up];
        xlow = okx[low]; xup = okx[up];
    } else if (low < 0) {
        ylow = oky[up]; yup = oky[up+1];
        xlow = okx[up]; xup = okx[up+1];
    } else {
        ylow = oky[low-1]; yup = oky[low];
        xlow = okx[low-1]; xup = okx[low];
    }

    return ylow + (yup - ylow)*(nx - xlow)/(xup - xlow);
}

// This interpolation function is faster than the basic 'interpol', because it assumes that the
// interpolated arrays only contain finite elements, and that 'x' is properly sorted. If these
// two conditions are matched, then the output will be the same as for 'interpol' (except that it
// will be quite faster). On the other hand, if one of the arrays contains special values (NaN, inf,
// ...), all the points that would use these values will be contaminated. If 'x' is not properly
// sorted, the result will simply be wrong.
template<typename TypeY, typename TypeX1, typename TypeX2>
auto interpol_fast(const vec_t<1,TypeY>& y, const vec_t<1,TypeX1>& x, const vec_t<1,TypeX2>& nx) {
    using rtypey = rtype_t<TypeY>;
    using rtypex = rtype_t<TypeX1>;

    phypp_check(n_elements(y) == n_elements(x),
        "interpol: 'x' and 'y' arrays must contain the same number of elements");
    phypp_check(n_elements(y) >= 2,
        "interpol: 'x' and 'y' arrays must contain at least 2 elements");

    int_t cnt = n_elements(nx);
    auto r = replicate(y[0]*dnan, cnt);

    for (int_t i = 0; i < cnt; ++i) {
        auto tx = nx[i];

        int_t low = lower_bound(tx, x);
        int_t up  = upper_bound(tx, x);

        rtypey ylow, yup;
        rtypex xlow, xup;
        if (low >= 0 && up >= 0) {
            ylow = y[low]; yup = y[up];
            xlow = x[low]; xup = x[up];
        } else if (low < 0) {
            ylow = y[up]; yup = y[up+1];
            xlow = x[up]; xup = x[up+1];
        } else {
            ylow = y[low-1]; yup = y[low];
            xlow = x[low-1]; xup = x[low];
        }

        r[i] = ylow + (yup - ylow)*(tx - xlow)/(xup - xlow);
    }

    return r;
}

// This interpolation function is faster than the basic 'interpol', because it assumes that the
// interpolated arrays only contain finite elements, and that 'x' is properly sorted. If these
// two conditions are matched, then the output will be the same as for 'interpol' (except that it
// will be quite faster). On the other hand, if one of the arrays contains special values (NaN, inf,
// ...), all the points that would use these values will be contaminated. If 'x' is not properly
// sorted, the result will simply be wrong.
template<typename TypeY, typename TypeX, typename T,
    typename enable = typename std::enable_if<!is_vec<T>::value>::type>
auto interpol_fast(const vec_t<1,TypeY>& y, const vec_t<1,TypeX>& x, const T& nx) {
    using rtypey = rtype_t<TypeY>;
    using rtypex = rtype_t<TypeX>;

    phypp_check(n_elements(y) == n_elements(x),
        "interpol: 'x' and 'y' arrays must contain the same number of elements");
    phypp_check(n_elements(y) >= 2,
        "interpol: 'x' and 'y' arrays must contain at least 2 elements");

    int_t low = lower_bound(nx, x);
    int_t up  = upper_bound(nx, x);

    rtypey ylow, yup;
    rtypex xlow, xup;
    if (low >= 0 && up >= 0) {
        ylow = y[low]; yup = y[up];
        xlow = x[low]; xup = x[up];
    } else if (low < 0) {
        ylow = y[up]; yup = y[up+1];
        xlow = x[up]; xup = x[up+1];
    } else {
        ylow = y[low-1]; yup = y[low];
        xlow = x[low-1]; xup = x[low];
    }

    return ylow + (yup - ylow)*(nx - xlow)/(xup - xlow);
}

template<typename TypeX, typename TypeY>
auto integrate(const vec_t<1,TypeX>& x, const vec_t<1,TypeY>& y) -> decltype(0.5*y[0]*x[0]) {
    assert(n_elements(x) == n_elements(y));
    
    decltype(0.5*y[0]*x[0]) r = 0;
    const int_t n = n_elements(x);
    for (int_t i = 0; i < n-1; ++i) {
        r += 0.5*(y[i+1]+y[i])*(x[i+1]-x[i]);
    }
    
    return r;
}

template<typename F, typename T, typename U>
auto integrate_trap(F f, T x0, U x1, uint_t n) -> decltype(0.5*f(x0)*x0) {
    using rtype = decltype(0.5*f(x0)*x0);
    rtype r = 0;
    rtype y0 = f(x0);
    T x = x0;
    auto dx = (x1 - x0)/double(n);
    for (uint_t i = 0; i < n; ++i) {
        x += dx;
        rtype y1 = f(x);
        r += 0.5*(y1+y0)*dx;
        y0 = y1;
    }
    
    return r;
}

template<typename F, typename T, typename U>
auto integrate(F f, T x0, U x1, double e = std::numeric_limits<decltype(f(x0))>::epsilon()) ->
    decltype(0.5*f(x0)*x0) {

    using rtype = decltype(0.5*f(x0)*x0);
    
    std::vector<rtype> buffer;
    buffer.reserve(20);
    buffer.push_back(0.5*(x1 - x0)*(f(x0) + f(x1)));
    
    uint_t n = 0;
    uint_t oid = 0;
    
    do {
        ++n;
        
        rtype tr = 0;
        uint_t tn = 1 << n;
        auto d = (x1 - x0)/double(tn);
        for (uint_t k = 1; k <= tn/2; ++k) {
            tr += f(x0 + (2*k-1)*d);
        }
        buffer.push_back(0.5*buffer[oid] + d*tr);
        
        for (uint_t m = 1; m <= n; ++m) {
            auto t = 1 << (2*m);
            buffer.push_back((t*buffer.back() - buffer[oid+m-1])/(t - 1));
        }
        
        oid += n;
    } while (fabs((buffer.back() - *(buffer.end()-2))/buffer.back()) > e);
    
    return buffer.back();
}

// Build the convex hull of a set of points, returning the indices of the points that form the hull
// in counter-clockwise order.
// Uses the monotone chain algorithm, taken from:
// http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain#C.2B.2B
template<typename TX, typename TY>
vec1i convex_hull(const TX& x, const TY& y) {
    phypp_check(n_elements(x) == n_elements(y),
        "convex_hull requires same number of elements in 'x' and 'y'");

    uint_t npt = n_elements(x);
    vec1i res = intarr(2*npt);
    vec1i ids = indgen(npt);
    std::sort(ids.data.begin(), ids.data.end(), [&](int_t i, int_t j) {
        if (x[i] < x[j]) return true;
        if (x[i] > x[j]) return false;
        if (y[i] < y[j]) return true;
        return false;
    });

    auto cross = [&](int_t i, int_t j, int_t k) {
        return (x[j] - x[i])*(y[k] - y[i]) - (y[j] - y[i])*(x[k] - x[i]);
    };

    uint_t k = 0;
    for (uint_t i = 0; i < npt; ++i) {
        while (k >= 2 && cross(res[k-2], res[k-1], ids[i]) <= 0) --k;
        res[k] = ids[i];
        ++k;
    }

    uint_t t = k+1;
    for (int_t i = npt-2; i >= 0; --i) {
        while (k >= t && cross(res[k-2], res[k-1], ids[i]) <= 0) --k;
        res[k] = ids[i];
        ++k;
    }

    res.data.resize(k);
    res.dims[0] = k;

    return res;
}

#endif
