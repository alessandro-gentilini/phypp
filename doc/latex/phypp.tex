\documentclass[12pt]{report}

\usepackage[T1]{fontenc}
% \usepackage{lmodern}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{txfonts}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{minted}
\usepackage{geometry}
\usepackage{imakeidx}
\makeindex
\usepackage[totoc]{idxlayout}
\usepackage{xparse}
\usepackage{mdframed}
\usepackage{footnote}
\usepackage{tikz}
\usepackage[colorlinks=true,linkcolor=blue,linktoc=page]{hyperref}

\makesavenoteenv{tabular}
\makesavenoteenv{table}

\newcommand{\via}{{\it via}\xspace}
% \newcommand{\phypp}{\texttt{phy++}\xspace}
\newcommand{\phypp}{\textit{phy}$_{\text{++}}$\xspace}
\newcommand{\stdvec}{\cppinline|std::vector|\xspace}
\newcommand{\funcitem}{\item}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.0pt] (char) {#1};}}

\newcommand{\vectorfuncsym}{\circled{$\hspace{-1pt}\mathcal{V}$}\xspace}
\newcommand{\vectorfunc}{\vectorfuncsym\hspace{2pt}\xspace}

\newcommand{\lapacksym}{\textsc{\small[lapack\small]}}
\newcommand{\lapack}{\lapacksym\hspace{2pt}\xspace}
\newcommand{\fftwsym}{\textsc{[fftw]}}
\newcommand{\fftw}{\fftwsym\hspace{2pt}\xspace}

\newcommand{\stwork}{works}
\newcommand{\sthwork}{half-working}
\newcommand{\stnwork}{not working}

\NewDocumentCommand\itt{v}{%
  \index{#1@\ittt{#1}}%
}

\NewDocumentCommand{\ittt}{v}{\texttt{#1}}

\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{advanced}{%
    linecolor=red,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{warning}{%
    linecolor=blue,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{example}{%
    linecolor=black,linewidth=1pt,%
    leftmargin=0pt,rightmargin=0pt,%
    innerleftmargin=0pt,innerrightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=1pt
}

\newenvironment{advanced}
{
    \begin{mdframed}[style=advanced,frametitle={Advanced}]
}
{
    \end{mdframed}
}
\newenvironment{warning}
{
    \begin{mdframed}[style=warning,frametitle={Warning}]
}
{
    \end{mdframed}
}
\newenvironment{example}
{
    \begin{mdframed}[style=example,frametitle={Example}]
}
{
    \end{mdframed}
}

\newminted{cpp}{fontsize=\small}
\newmintinline{cpp}{fontsize=\small}
\newminted{bash}{fontsize=\small}
\newmintinline{bash}{fontsize=\small}

\newcommand{\cpptrue}{\cppinline{true}\xspace}
\newcommand{\cppfalse}{\cppinline{false}\xspace}

\newcommand{\footlabel}[2]{\footnote{\label{#1}#2}}
\newcommand{\footref}[1]{\textsuperscript{\ref{#1}}}

\DeclareFixedFont{\titlefont}{T1}{ppl}{b}{it}{0.5in}

\begin{document}
\begin{titlepage}

{\noindent \Huge \textbf{\phypp} \Large v1.0 \\[0.6cm]} \par
\noindent
\vspace{2cm}
\begin{center}
\Huge \textbf{Reference manual}
\end{center}
\null\vfill
\vspace*{1cm}
\hfill
\begin{minipage}{0.35\linewidth}
    \begin{flushright}
        \large Corentin Schreiber \\
        \today
    \end{flushright}
\end{minipage}
%
\begin{minipage}{0.02\linewidth}
    \rule{1pt}{40pt}
\end{minipage}
\end{titlepage}

\tableofcontents

\chapter{Introduction \label{SEC:intro}}

\section{Description of the library \label{SEC:intro:overview}}

\subsection{Overview}

\phypp is a set of library and tools built to provide user-friendly vector data manipulation, as offered in interpreted languages like IDL\footnote{\url{http://www.exelisvis.com/ProductsServices/IDL.aspx}}, its open source clone GDL\footnote{\url{http://gnudatalanguage.sourceforge.net/}}, or \texttt{python} \& \texttt{numpy}\footnote{\url{http://www.numpy.org/}}, but with the added benefit of C++: increased robustness, and optimal speed.

The library can be split into two components: the \emph{core} library (\ref{SEC:core}) and the \emph{support} library (\ref{SEC:support}). The core library introduces the \emph{vector} type, which is at the heart of \phypp, while the support library provides functions and other tools to manipulate these vectors and do some common tasks. You can think of the core library as ``the language'', and the support library as ``the function library''.

Below is an code sample written in \phypp that illustrates the most basic functionalities.

\begin{cppcode}
vec2f img = fits::read("img.fits"); // read a FITS image
img -= median(img);                 // subtract the median of the whole image
float imax = max(img);              // find the maximum of the image
vec1u ids = where(img > 0.5*imax);  // find pixels at least half as bright
float sum = total(img[ids]);        // compute the sum of these pixels
img[ids] = log(img[ids]/sum);       // modify these pixels with a logarithm
fits::write("new.fits", img);       // save the modified image to a FITS file
\end{cppcode}

\subsection{Why write something new?}

The immediate goal of \phypp is to provide a syntax as close as possible to that of IDL. IDL is an interpreted language that is widely used in the scientific community, in particular in astrophysics. Born in the late 1970s, this language provides intuitive manipulation of large arrays of data using vectorized operations: applying an operation on a given array does not require the user to write a loop to iterate over its elements and apply the operation. This leads to very concise code that easy to write and read. Unfortunately, IDL suffers from a number of problems. I will start with the \emph{political} and \emph{ethical} problems.
\begin{itemize}
\item It is a proprietary, mostly\footnote{The procedures from the IDL library that are written in IDL language are actually open-source, but all the procedures written in native language are compiled and only the binary is provided.} closed-source program. This means that IDL is a black box and that people using it have no choice but to rely on the IDL developers for writing accurate code. While there is an extensive documentation, the algorithms used by the procedures are not always described. This is hardly acceptable for scientific code.
\item IDL, like C++, combines several languages into one: a functional language and an object-oriented language. It also contains a huge support library providing many features (having used IDL for more than two years, I could not list them all). For this reason, and because it is proprietary, maintaining this language and adding new features costs a lot of money to its owner, Exelis. This money, in turn, is provided by science labs all around the world, who pay a yearly fee for a bunch of IDL licenses. This is totally fine in itself, but the fact is that most IDL users I have seen only make use of a small sub-set of IDL, one that has barely evolved in twenty years. In this context, the price that is paid is not justified.
\item On top of that, the licensing model is that of \emph{floating} licenses: only a fixed, maximum number of simultaneously running IDL instance is allowed in the whole lab. With the now common budget restrictions in research, labs typically buy fewer licenses than there are users. Even worse, it is often needed to run multiple instances of IDL on a single computer, e.g., when working on two projects simultaneously. This will consume two licenses, even though there is a single user. This leads to silly situations, typically when approaching specific deadlines (e.g., deadlines for requesting observing time on large telescopes) where everyone needs to use IDL at the same time, but there is not enough license available. Even worse, we have seen cases in our lab of users being unable to run IDL on their new shiny computer because of incompatibility, not with IDL itself, but with the licensing software. Lastly, it should be noted that this licensing model relies on having network connection with a license server. This means that one cannot use IDL while traveling unless a proper SSH tunneling is in place.
\end{itemize}

These issues can be solved by switching to one of the free and open-source alternatives, like GDL. The downside is that these implementations are lacking behind IDL in terms of features, as some useful functions are still to be implemented. Worse, some functions cannot \emph{legally} be implemented because they would violate IDL's copyright.

But that's only half of the story. Indeed, IDL and GDL also suffer from technical issues. I will list below the most important ones.
\begin{itemize}
\item Designed in the 1970s, IDL was born in an era where the available RAM was scarce, and that great care had to be taken to consume as few bytes of memory as possible. For this reason, the default integer type in IDL is a \cppinline{short}, i.e., it occupies only two bytes in memory, while most languages (including some that are older than IDL itself) encode their integers on four bytes by default. The biggest issue with this choice is that the largest number one can store in a \cppinline{short} is \cppinline{32768}. Being the default integer type, this creates quite a few surprises to the unexperienced user, and will fool even the expert from time to time.
\item IDL is an interpreted language, meaning that the code you write is continuously read and interpreted by the IDL executable. While this is not an issue if you make good use of vectorization (the art of writing IDL code), performances are severely degraded onces you write loops explicitly, because the content of the loop has to be \emph{interpreted} and then \emph{executed} on each iteration. And this is sometimes unavoidable.
\item Like many interpreted languages, IDL is dynamically typed. This means that the type of a variable can change from one line to another, and that a variable containing a string can be assigned a number. While sometimes convenient, this comes at a cost: performance. And the fact is that in most IDL programs this feature is not used.
\item But worse than dynamic typing, and this is my main concern, variables in IDL are not \emph{declared} before they are used. This means that if you do a typo in the name of one of your variables, chances are that the code will still run. Indeed, IDL cannot know that this was not intended, and will think that you want to create a new variable. It will then do its best to carry on, and the result will be unpredictable. This, together with the fact that variables are almost not \emph{scoped} (i.e., a variable created inside a \cppinline{for} loop is still valid outside of the loop) makes it very easy to write confusing and buggy code. The most frightening part is that, in a good fraction of the cases, the output will be meaningful, and you can go on with your calculation never realizing that something went wrong. And publish that.
\end{itemize}

Switching to more modern interpreted languages like \texttt{python} or Julia\footnote{\url{http://julialang.org/}} would solve a few of these issues, in particular the first one. But the other items on this list are unfortunately inherent to most interpreted languages\footnote{The best counter example is probably Java.}. To avoid these traps, the only solution today is to use \emph{statically typed}, compiled languages, like C++.

Now, there are already some libraries in C++ that are addressing the topic of vector data manipulation. One can cite \href{http://eigen.tuxfamily.org}{Eigen} or the more recent \href{https://code.google.com/p/blaze-lib/}{blaze-lib}. These are wonderful libraries that have inspired \phypp in some way, but their issue is that they are more oriented toward algebra, meaning that they have vectors and matrices, but no data type for arrays of higher dimensions (i.e., tensors\footnote{Eigen actually has a tensor module, but it is unsupported.}).

Therefore, seeing that a gap had to be filled, \phypp was created.

\subsection{Why C++?}

There are many different compiled languages that offer similar or better performances than C++. In particular, the most famous ones are Fortran and C. C is impractical to use because it has not been developed with user-friendliness in mind, and no mechanism exist to improve that. This is a system language, and it does that perfectly, but not much more. Fortran is known as the fastest of all, and it is particularly well suited for numerical analysis. While few languages as harder to read than Fortran 77, things have become much better since since Fortran 90 (which is not used as often as it should be). However, Fortran is relatively bad at doing anything else than numerical analysis, which is annoying the moment you want to do something that is a bit off the tracks. C++ on the other hand, with all its disadvantages, is probably the best fit thanks to its almost unlimited capacity for adaptation. And it also happens to be the language I am most familiar with.

Since the beginning, C++ has always been good at performances, first because it is a language that compiles directly into assembly, but also thanks to its philosophy: ``you only pay for what you ask for". But its main disadvantage is its \emph{complexity}: it contains almost the whole C language, plus all the layers that were added on top of it, one year after another, starting from classes, exceptions, then templates. The end result is that it is a challenging task to master all the aspects of this language.

But the good news is: you do not have to master all of C++, and for your sanity you probably should not. Indeed, there is a number of \emph{sub-languages} made out of a subset C++ that are completely self-sufficient, i.e.~you can use them to write any program. In other words, there are multiple, very different ways of writing the same program in C++. Typically, modern programs only use a small fraction of the whole language, e.g., leaving aside most of what was inherited from C (arrays, raw pointers, explicit memory management, etc.). A special class of such sub-languages are those that are tailored specifically to address a given task, as opposed to being open to any purpose. These are called \emph{domain-specific languages} (DSL), and only require learning a few of C++'s rules and concepts, plus the rules introduced by the sub-language itself. The \phypp library is an example of such domain-specific languages, its domain being vector data manipulation.

In short, although C++ is a very complex language, it is only necessary to learn a fraction of it to be able to use \phypp correctly. For example, you will find in \ref{SEC:instro:qstart:new} a self-consistent tutorial to get started with the library that does not require any preliminary knowledge of C++. Of course, the more you will know about C++, the more you will be able to take advantage of all the features of \phypp in an optimal way.

\section{Supported systems \label{SEC:intro:supported}}

The combination of operating systems and compilers on which this library has been tested is reported in the following table. If you have issues and your system is reported in this table as working, then there is probably something wrong in your configuration (e.g., a missing library). If you are using a system combination that is not listed here: if you managed to get it to work, please drop me an email and I will add it to the list; else, if you failed to compile or run programs with the library, please open a new issue on \texttt{github}\footnote{\url{https://github.com/cschreib/phypp/issues}} and we will try to get it fixed together.

\vspace*{0.5cm}
\begin{minipage}{\textwidth}
\begin{center}
\begin{tabular}{cccc}
\hline \hline
Operating system & Compiler & Status & Notes \\ \hline
Linux Mint 15 & gcc-4.8   & \stwork & \footlabel{foot:lm15}{\texttt{libclang} in the repository is too old. Use a more recent version from \href{https://launchpad.net/~h-rayflood/+archive/ubuntu/llvm}{ppa:h-rayflood/llvm}.} \\
 --           & gcc-4.7   & \stwork & \footref{foot:lm15} \\
 --           & clang-3.3 & \stwork & \footref{foot:lm15} \\
Linux Mint 17 & gcc-4.8   & \stwork & \footlabel{foot:lm17}{\texttt{libclang} in the repository crashes on valid C++ code. Fixed in \texttt{libclang-3.5}.} \\
 --           & clang-3.3 & \stwork & \footref{foot:lm17} \\
 --           & clang-3.4 & \stwork & \footref{foot:lm17} \\
 --           & clang-3.5 & \stwork & \footref{foot:lm17} \\
Ubuntu 14.04  & gcc-4.8   & \stwork & \footlabel{foot:ntested}{Not all dependencies were tested.} \\
Debian 4.6.3  & gcc-4.7   & \stwork & \footref{foot:ntested} \\
OSX 10.9.5    & xcode-6.0 & \stwork & \footref{foot:ntested} \\
\hline
\end{tabular}
\end{center}
\end{minipage}

\section{Installing \label{SEC:intro:installing}}

\section{Quick-start guide \label{SEC:instro:qstart}}
\subsection{For users new to C++ \label{SEC:instro:qstart:new}}
\subsection{For users familiar with C++ \label{SEC:instro:qstart:fami}}


\chapter{Core library \label{SEC:core}}
% vec.hpp
% variadic.hpp
% reflex.hpp
% range.hpp
% iterator.hpp

\section{Overview \label{SEC:core:overview}}
At the core of the \phypp library is the \emph{vector} class. This is basically an enhanced \stdvec\footnote{In fact, \stdvec is used to implement the \phypp vectors internally.}, and it therefore shares most of its features and strengths. In particular, a vector can contain zero, one, or as many elements as your computer can handle. Its size is defined at \emph{runtime}, meaning that its content can vary depending on user input, but also that a vector can change its total number of elements at any time. These elements are stored contiguously in memory, which provides optimal performances in most situations. Lastly, a vector is an homogeneous container, meaning that a given vector can only contain a single type of elements (e.g., \cppinline|int| or \cppinline|float|, but not both at the same time).

Like most advanced C++ libraries, \phypp is essentially \emph{template} based. This means that most of the code is written to work for \emph{any} type \cppinline|T|, e.g., \cppinline|int|, \cppinline|float|, \cppinline|std::string|, or whatever you need. However, while templates are a fantastic tool for library writers, they can easily become a burden for the \emph{user} of the library. The good thing is, since \phypp is a numerical analysis library, we know in advance what types will most often be stored inside the vectors. So for this reason, to reduce typing and enhance readability, we introduce type aliases for the most commonly used vector types:
\begin{itemize}
\item \cppinline|vec1f|: vector of \cppinline|float|,
\item \cppinline|vec1d|: vector of \cppinline|double|,
\item \cppinline|vec1cf|: vector of \cppinline|std::complex<float>|,
\item \cppinline|vec1cd|: vector of \cppinline|std::complex<double>|,
\item \cppinline|vec1i|: vector of \cppinline|int| (precisely, \cppinline|int_t = std::ptrdiff_t|),
\item \cppinline|vec1u|: vector of \cppinline|unsigned int| (precisely, \cppinline|uint_t = std::size_t|),
\item \cppinline|vec1b|: vector of \cppinline|bool|,
\item \cppinline|vec1s|: vector of \cppinline|std::string|,
\item \cppinline|vec1c|: vector of \cppinline|char|.
\end{itemize}

On top of the \stdvec interface, the \phypp vector adds some extra functionalities. The most important ones are operator overloading, multi-dimensional indexing, and vector views.

\subsection{Operator overloading \label{SEC:core:overview:overloading}}

The only thing you can do to operate on all the elements of an \stdvec is to iterate over these elements explicitly, either using a C++11 range-based loop, or using indices:
\begin{cppcode}
// Goal: multiply all elements by two.
std::vector<float> v = {1,2,3,4};

// Either using a range-based loop,
for (float& x : v) {
    x *= 2;
}

// ... or an index-based loop.
for (std::size_t i = 0; i < v.size(); ++i) {
    v[i] *= 2;
}
\end{cppcode}

While this is fairly readable (especially the first version), it is still not very concise and expressive. In \phypp, we have \emph{overloaded} the usual mathematical operators on our vector type, meaning that it is possible to write the above code in a much simpler way:

\begin{cppcode}
// Using phy++ vector.
vec1f w = {1,2,3,4};
w *= 2; // {2,4,6,8}
\end{cppcode}

Not only this, but we can perform operations on a pair of vectors in the same way:
\begin{cppcode}
// Goal: sum the content of the two vectors.
vec1f x = {1,2,3,4}, y = {4,3,2,1};
vec1f z = x + y; // {5,5,5,5}
\end{cppcode}

\begin{warning}
The only issue with operator overloading concerns the hat operator \cppinline|^|. In most languages, this operator is used for exponentiation, e.g., \cppinline|4^2 == 16|. However, in C++ this value is actually \cppinline|6|, because the hat operator is the binary XOR (exclusive-or). Even worse, the hat operator in C++ does not have the same \emph{precedence} as in regular mathematics: it has a lower priority than any other mathematical operator. Both these reasons make it unwise to overload the hat operator in \phypp. In order to perform exponentiation, you will have to use a dedicated function such as \cppinline|pow(4,2)| (\ref{SEC:support:math}).
\end{warning}

\subsection{Multi-dimensional indexing \label{SEC:core:overview:multidim}}

The standard \stdvec is a purely linear container: one can access its elements using \cppinline|v[i]|, with \cppinline|i| ranging from \cppinline|0| up to \cppinline|std::vector::size()-1| (included). However, the \phypp vector allows N-dimensional indexing, i.e., using a group of indices to identify one element. For example, this is particularly useful to work on images, which are essentially 2-dimensional objects where one identifies a given pixel by its coordinates \cppinline|x| and \cppinline|y|. The natural syntax for this indexing would be to write \cppinline|img[x,y]|. This syntax is valid C++ code, but unfortunately will not do what you expect\footnote{This will call the \emph{comma} operator, which evaluates both elements \cppinline|x| and \cppinline|y| and returns the last one, i.e., \cppinline|y|. So this code actually means \cppinline|img[y]|. With proper configuration, most compiler will warn about this though, since in this context \cppinline|x| is a useless statement, so you should be safe should you make this mistake.} and there is no sane way around it. The alternative we chose here is to write instead \cppinline|img(x,y)|. While it is not as semantically clear as using brackets, it has the nice advantage of being compatible with the IDL syntax.

The multi-dimensional nature of a vector is determined at \emph{compile time}, i.e., it cannot be changed after the vector is declared. By default, a vector is mono-dimensional. To use the above feature, one needs to specify the number of needed dimensions in the type of the vector. For example, a 2D image of \cppinline|float| will be declared as \cppinline|vec2f|. These type aliases are provided for dimensions up to $6$. Here is an example of manipulation of a 2D matrix:

\begin{cppcode}
// Create a simple matrix.
vec2f m = {{1,2,3}, {4,5,6}, {7,8,9}};

// Index ordering is similar to C arrays: the last index
// is contiguous in memory. Note that this is *opposite*
// to the IDL convention.
m(0,0); // 1
m(0,1); // 2
m(1,0); // 4

// It is still possible to access elements as if in a
// "flat" vector
m[0]; // 1
m[1]; // 2
m[3]; // 4
\end{cppcode}

\begin{advanced}
If for some reason you need to use more than 6 dimensions, or if you need to declare a vector of some type which is not covered above, you can always fall back to the full template syntax:
\begin{cppcode}
// Need 12 dimensions?
using vec12f = vec<12,float>;
// Need 512 bit of floating point precision?
using vec3f512 = vec<3,mpfr::real<512>>;
\end{cppcode}

The hard limit on the number of dimensions will then depend on your compiler (each dimension involves an additional level of template recursion). The C++ standard does not guarantee anything, but you should be able to go as high as 256 on all major compilers. Beyond this, you should probably see a doctor first.

As for the types allowed inside the vector, there is no explicit restriction. However, some features may obviously not be available depending on the capabilities of your type (e.g., if your type has no \cppinline{operator*}, you will not be able to multiply together vectors of this type). Lastly, the \phypp vector shares the same restrictions as the \stdvec regarding the \emph{copyable} and \emph{movable} capabilities of the stored type.
\end{advanced}

\subsection{Vector views \label{SEC:core:overview:views}}

We have seen that, instead of accessing each element individually, we can use operator overloading to perform simple operations on all the elements of the vector at once: \cppinline|w *= 2|. We can also, like with \stdvec, modify each element individually, knowing their indices: \cppinline|w[2] *= 2|. One last important feature allowed by the \phypp vector is that one can create a \emph{view} inside a vector. Each element of the view is actually a \emph{reference} to an element in the original vector, and modifying the elements of the view actually modifies the elements in the original vector. As you will see later, views actually share most of the interface and capabilities of true vectors, so that most generic codes that work with vectors will also work with views.

\begin{cppcode}
// Create a simple vector.
vec1f w = {1,2,3,4,5,6};

// We want to "view" only the second, the third and the
// fifth elements. So we first create a vector containing
// the corresponding indices.
vec1u id = {1,2,4};

// Then we create the view.
// Note the usage of "auto" there. The type of the view is
// complex, and it is better not to worry about it.
auto v = w[id];

// Now we can modify these elements very simply, as if they
// were part of a real vector.
v;         // {2,3,5}
v *= 2;    // {4,6,10}
w;         // {1,4,6,4,10,6}
w[1] = 99; // {1,99,6,4,10,6}
v;         // {99,6,10}
\end{cppcode}

\begin{warning}
It is important to note that, since a view keeps references to the elements of the original vector, the lifetime of the view must not exceed that of the original vector. Else, it will contain \emph{dangling references}, i.e.~pointers to unused memory, and this should be avoided at all cost. In fact, views are not meant to be stored into named variables like in the above example. Most of the time, one will use them as temporary variables, e.g.:
\begin{cppcode}
vec1f w = {1,2,3,4,5,6};
vec1u id = {1,2,4};
w[id] *= 2; // {1,4,6,4,10,6}
\end{cppcode}
\end{warning}

\section{The vector class \label{SEC:core:vec}}

The full type of the vector class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec<Dimension,ElementType>;
\end{cppcode}

In the rest of this document, \cppinline{Dimension} will usually just be called \cppinline{D} and \cppinline{ElementType} will be shortened to \cppinline{T}.

\subsection{Member variables \label{SEC:core:vec:member_var}}

A vector only contains two member variables:
\begin{itemize}
\item \cppinline{std::vector<T> data} \\ This is the underlying \stdvec containing the elements of the vector. It is exposed to the public interface for simplicity, but on most occasions it should \emph{not} be used directly. In fact, it may become part of the private interface in the future, so you should not rely on its existence.

\begin{advanced}
Concerning \cppinline{bool} vectors. We do not use \cppinline{std::vector<bool>}, since it is a very special case of \stdvec: the C++ standard specifies that the \cppinline{bool} specialization does not store \cppinline{bool} elements, but is actually implemented like a \emph{bit field}. This is essentially to save memory: a \cppinline{bool} in C++ occupies $8$ bits of memory, like a \cppinline{char}, even though it can only carry a single bit of information. This is due to \emph{memory alignment} issues, which are inherent to the CPU architecture (the address of individual values in memory are supposed to be multiples of $8$ bits, or one byte). In a bit field however, $8$ \cppinline{bool}s are stored in a single \cppinline{char}, and bitwise operators are used to read and write individual \cppinline{bool}s. While more memory efficient, it is also slower, and involves a whole machinery to trick the user into thinking that none of this is happening. For this reason, \cppinline{bool} vectors are implemented with \cppinline{std::vector<char>} in \phypp, with one \cppinline{char} containing one \cppinline{bool}. This is completely transparent to the library user though, since \cppinline{char&} is casted into \cppinline{bool&}, and vice versa, at the boundary of the vector interface.
\end{advanced}

\item \cppinline{std::array<std::size_t,D> dims} \\ This variable contains the dimensions of this vector (useful only for multidimensional vectors). On no occasion should you modify this variable yourself: you should only read its content\footnote{This statement is actually a bit bold, but is mostly true. The only reason why this variable is made public is for optimization purposes. On occasions, it can be noticeably faster to manage manually the growth of a vector, and update the dimensions afterwards. This is often done within the core library, but should rarely be done otherwise.}. To change the dimensions of a vector, either use \cppinline{resize(...)} (\ref{SEC:core:vec:member_fun}) or assign it another vector (\ref{SEC:core:vec:constructor}).

\begin{example}
\begin{cppcode}
// Create a 2D image with 256 x 128 pixels
vec2f img(256,128);
img.dims[0]; // 256
img.dims[1]; // 128
for (std::size_t x = 0; x < img.dims[0]; ++x)
for (std::size_t y = 0; y < img.dims[1]; ++y) {
    img(x,y) = 3.1415;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Constructors and assignment \label{SEC:core:vec:constructor}}

There are various ways to construct a new vector, or assign it some value. In the following, we will cover the various \emph{constructors} and the associated \emph{assignments} when applicable.

\begin{itemize}
\item \cppinline|vec::vec(); // The default constructor|

Like \stdvec, the \phypp vector is \emph{default constructible}. By default it is in a valid state where the vector does not contain any element.

\begin{example}
\begin{cppcode}
vec1f w; // default constructor: w is empty
\end{cppcode}
\end{example}

\item \cppinline|explicit vec::vec(...); // The dimension constructor|

The \stdvec has a constructor to create a new vector of a given size. The \phypp vector also offers this feature, however it is rendered a bit more complex by the possibility of having multi-dimensional vectors. In particular, it is possible to specify the size either by giving all the dimensions one by one, or by specifying some (or all) as a \cppinline|std::array|. In all cases, the vector is populated with the number of requested elements, and all these elements are \emph{default initialized} (i.e., integers and floats are initialized to \cppinline{0}, booleans to \cppfalse, and \cppinline|std::string| are empty). This constructor is declared \cppinline{explicit} to prevent interference with the other constructors and assignments.

\begin{example}
\begin{cppcode}
vec1f w(10);     // w contains 10 objects all equal to 0
vec2d z(5,4);    // z contains 5*4=20 objects all equal to 0
vec2s x(z.dims); // x has the same dimensions as z
                 // but contains strings, all empty
vec3b y(z.dims, 8); // y has the same dimensions as z,
                 // plus an extra dimension of length 8
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(nested_initializer_list<D,T>); // The list constructor|

Like \stdvec, the \phypp vector can be initialized from a list of values. This usually requires the usage of \cppinline|std::initializer_list<T>|, however here we also have to support multi-dimensional vectors, hence we need initializer lists of initializer lists of ..., and \cppinline|nested_initializer_list<D,T>| is just that. Note that, since C++ is a row-major language, the most nested lists correspond to the last index in a multi-dimensional vector.

\begin{example}
\begin{cppcode}
vec1f w({1,2,3}); // 1D list constructor: {1,2,3}
vec2f z({{1,2,3},{6,5,4}}); // 2D list constructor: {{1,2,3},{6,5,4}}
z(0,0); // 1
z(0,1); // 2
z(0,2); // 3

// Assignment
w = {4,5,6};
z = {{1,2}, {3,4}, {5,6}}; // dimensions can change through assignment
z(0,0); // 1
z(1,0); // 3
z(2,0); // 5
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec&); // The copy constructor|

Like \stdvec, the \phypp vector is \emph{copiable}, meaning that one can duplicate the content of an existing vector inside another vector by copy. Note that this constructor is only valid for copying vectors of the \emph{same} type. If the type is different, then another constructor is called (conversion constructor, see below).

\begin{example}
\begin{cppcode}
vec1f w = {1,2,3};
vec1f z(w); // copy constructor: {1,2,3}

// Assignment
z = w;
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(vec&&); // The move constructor|

Like \stdvec, the \phypp vector is \emph{movable}, meaning that one can move the content of an existing vector that is going to be destroyed inside another vector. This is an optimized copy for temporary variables (C++11 move semantics). You need not explicitly ask for either the copy of the move constructor, as they will automatically be chosen by the compiler. For you, this is transparent (but the performance boost is large).

\begin{example}
\begin{cppcode}
vec1f z(vec1f{1,2,3}); // move constructor: {1,2,3}
// Here, a temporary vector is created with vec1f{1,2,3}.
// This temporary vector is then *moved* inside z.

// Assignment
z = vec1f{4,5,6};
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec<D,OtherT>&); // The conversion constructor|

C++ supports implicit conversion between all the build in types. In particular, it is possible to write:
\begin{cppcode}
int i = 0;
float f = i; // int to float
bool b1 = i; // int to bool, mostly for interoperability with C
bool b2 = f; // float to bool, not sure if that makes sense...
\end{cppcode}
While this is very convenient in most cases, it can also lead to dangerous silent conversions, such as the \cppinline{float} to \cppinline{bool} conversion. This is, somehow, a legacy of C. In \phypp we decided to also support such implicit conversions. They make the code much easier to read, but the price to pay is that sometimes we do some conversions which are not necessary, and we do not realize it because they are implicit. However, we decided to disable implicit conversion to and from \cppinline{bool} vectors, since it could lead to subtle bugs that are difficult to trace. It is sill possible to do the conversion to \cppinline{bool} using explicit

\begin{example}
\begin{cppcode}
vec1i w = {1,2,0};
vec1f z(w); // int to float {1,2,0}
vec1b y(w); // error: cannot convert int to bool
vec1s x(w); // error: cannot convert int to std::string

vec1b b = {true,true,false};
vec1i s(b); // bool to int {1,1,0}

// Assignment
z = w;
y = w;        // error: cannot convert int to bool
x = w;        // error: cannot convert int to std::string

s = b;        // error: implicit conversion is not allowed for bool
s = vec1i(b); // ok: bool to int {1,1,0}
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec<D,T*>&); // The view constructor|

The last constructor on the list is the view constructor. It allows implicit conversion of a view (\ref{SEC:core:view}) into a new, independent vector.

\begin{example}
\begin{cppcode}
vec1i w = {1,2,3};
vec1u id = {0,1};
vec1i z(w[id]); // {1,2}

// Assignment
z = w[id];
\end{cppcode}
\end{example}

\end{itemize}

\subsection{Member functions \label{SEC:core:vec:member_fun}}

\begin{itemize}
\item \cppinline{bool vec::empty() const}

This function will return \cpptrue if this vector contains at least one element, and \cppfalse otherwise. In particular, \cpptrue will be returned for default constructed vectors, and after a call to \cppinline{vec::clear()}.

\begin{example}
\begin{cppcode}
vec1i v;
v.empty(); // true
vec1i w = {1,2,3};
w.empty(); // false
\end{cppcode}
\end{example}

\item \cppinline{std::size_t vec::size() const}

This function will return the total number of elements in this vector. If the vector is empty, then the function returns \cppinline{0}. If the vector is multidimensional, then the function returns the product of all the dimensions.

\begin{example}
\begin{cppcode}
vec1i v;
v.size(); // 0
vec1i w = {1,2,3};
w.size(); // 3
vec2i z = {{1,2,3}, {4,5,6}};
z.size(); // 6
\end{cppcode}
\end{example}

\item \cppinline{void vec::resize(...)}

This function can be used to explicitly change the size of a vector. The parameters it accepts are the same as the dimension constructor (\ref{SEC:core:vec:constructor}), i.e., either integral values for individual dimensions, or an \cppinline{std::array} containing multiple dimensions, or any combination of these. However, the total number of dimensions of the vector must remain unchanged.

After the vector has been resized, its content will have changed. For a monodimensional vector, if the resize operation \emph{decreased} the total number of elements, then the last elements will be erased, but the other ones will remain untouched. On the other hand, if the resize operation \emph{increased} the total number of elements, all the previous elements are unchanged, and new elements are inserted at the end of the vector, default constructed (i.e., zeroes for integral types, etc.). For a multidimensional vector, its content is left in an \emph{undefined state}, and can be assumed to be destroyed\footnote{This is just out of laziness. In the future, this will probably be specified to behave like the monodimensional vector. The issue is that it involves non-trivial reshuffling of the elements to preserve the original structure after the dimensions have changed. I have not needed this feature so far.}.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.resize(5); // {1,2,3,0,0}
v.resize(2); // {1,2}
v.resize(3); // {1,2,0}

vec2f w = {{1,2},{2,3}};
w.resize(2,3); // w has been resized, but its content is unspecified
w(0,0); // ?
\end{cppcode}
\end{example}

\item \cppinline{void vec::clear()}

This function removes all elements from the vector, and sets all dimensions to zero.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.clear(); // v is now empty
v.empty(); // true
v.size();  // 0
v.dims;    // {0}
\end{cppcode}
\end{example}

\item \cppinline{T& vec::back()}

This function is only available for monodimensional vectors. It returns the last element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.back(); // 3
v.back() == v[v.size()-1]; // always true
\end{cppcode}
\end{example}

\item \cppinline{T& vec::front()}

This function is only available for monodimensional vectors. It returns the first element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.front(); // 1
v.front() == v[0]; // always true
\end{cppcode}
\end{example}

\item \cppinline{void vec::push_back(...)}

The behavior of this function is different for monodimensional and multidimensional vectors. For monodimensional vectors, this function appends a new element at the end of the vector, and therefore takes for argument a single value of type \cppinline{T} (or convertible to \cppinline{T}). For multidimensional vectors, this function takes for argument another vector of \cppinline{D-1} dimensions, and whose lengths match the \emph{last} \cppinline{D-1} dimensions of the first vector. This new vector is inserted after the existing elements, and the first dimension of the first vector is increased by one.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.push_back(4); // {1,2,3,4}

vec2i w = {{1,2,3}, {4,5,6}};
w.push_back({7,8,9}); // {{1,2,3}, {4,5,6}, {7,8,9}}
w.push_back({7,8});   // error: dimensions do not match, 2 != 3
\end{cppcode}
\end{example}

\item \cppinline{void vec::reserve(std::size_t)}

This function is used for optimization, and is similar to \cppinline{std::vector::reserve()} (actually, this function is called internally). To understand what this function actually does, one needs to know the internal behavior of \stdvec. By default, the \stdvec only allocates enough memory to hold a few elements. Once the allocated memory is full, \stdvec allocates a larger amount of memory, copies the existing elements inside this new memory, and frees the old memory. This strategy allows virtually unlimited growth of a given vector, and is quite efficiently tuned. However, it is still an expensive operation, and performances can be greatly improved if one knows \emph{in advance} the total number of objects that need to be stored in the vector, so that the right amount of memory is allocated from the beginning, and no copy is required. This function does just that, it tells \stdvec how many elements it \emph{will} (or might) contain at some point, so that the vector can already allocate enough memory. This is also useful if you only have a rough idea of the future number of elements.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,...};

// Let's imagine you have an algorithm that will produce an
// unknown number of values, but you know that on average
// it is close to N*N.
vec1i w;
// Reserve roughly enough memory in advance
w.reserve(v.size()*v.size());

// Now the algorithm will run close to the optimal memory
// efficiency
for (...) {
    w.push_back(...);
}
\end{cppcode}
\end{example}

\item \cppinline{uint_t vec::pitch(uint_t) const}

This is only useful for multidimensional vectors. This function returns the ``pitch'' factor associated to a given dimension. This factor is number of elements in memory that separate two consecutive indices of this dimension. By definition, the pitch factor is \cppinline{1} for the last dimension. For the other dimensions, this is the product of all the other dimensions located between the one considered and the last dimension.

\begin{example}
\begin{cppcode}
vec3f v(5,8,6);
v.pitch(2); // 1
v.pitch(1); // 6 = v.dims[2]
v.pitch(0); // 48 = v.dims[2]*v.dims[1]
\end{cppcode}
\end{example}

\item \cppinline{bool vec::is_same(const vec<D,T>&) const}

This function tests if the provided vector is a view inside this vector.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
vec1f w = {1,2,3};
vec1u id = {1,2};
v.is_same(v[id]); // true
v.is_same(w[id]); // false
\end{cppcode}
\end{example}

\item \cppinline{const vec& vec::concretize() const}

This function just returns a reference to this vector, and is only present to mirror the interface of the view class.

\item \cppinline{iterator vec::begin()} and \cppinline{iterator vec::end()}

These functions allow iteration over the values of this vector. The only reason one may use these functions explicitly is when using algorithms from the standard C++ library, which often work on a pair of iterators as returned by \cppinline{begin()} and \cppinline{end()}.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
// The presence of these functions allow to use vectors
// in range-based loops
for (float& f : v) {
    f += 1;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Indexing \label{SEC:core:vec:indexing}}

There are two ways to index a given vector, for both mono- and multidimensional vectors. The first way is through ``flat'' indices and the bracket indexing \cppinline{v[i]}, i.e., a single index that runs contiguously in memory, and the second way is through multidimensional indices and parenthesis indexing \cppinline{v(i)} (\ref{SEC:core:overview:multidim}). For monodimensional vectors, these two methods are perfectly identical.

Flat indexing does not care about the details of the dimensions of a given vector. The only important thing is the total number of elements in the vector. This is the simplest and fastest\footnote{Actually there is a faster way using the \cppinline{safe} wrapper, which does not do bounds checking. See the ``Advanced'' note at the end of this section.} way to access the data inside a vector.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.size(); ++i) {
    // Here we traverse the vector v regardless of its dimensions
    v[i] = 12.0 + i*i - sqrt(5.0*i) + v[i/4];
}
\end{cppcode}
\end{example}

Multidimensional indexing is more involved computationally, because it implies some index arithmetic to compute the flat index and find the right place to read in memory. However it is much more expressive and easier to read and understand. Furthermore, except for very critical code sections, the performance gap is usually negligible, as long as you iterate over the dimensions properly, i.e., following the example below, that you do the \emph{last} nested loop to iterate on the \emph{last} index. This will guarantee as much memory locality as possible, and will take best advantage of CPU caches.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.dims[0]; ++i)
for (std::size_t j = 0; j < v.dims[1]; ++j)
for (std::size_t k = 0; k < v.dims[2]; ++k) {
    // Here we traverse the vector v keeping its dimensional structure
    v(i,j,k) = 42.0 + i + j + k/(j+1);
}
\end{cppcode}
\end{example}

Indexing a vector can only be done with integers, e.g., \cppinline{int}, \cppinline{unsigned int}, \cppinline{int_t}, \cppinline{uint_t}, \cppinline{std::size_t}, etc. Indexing with \emph{unsigned} integers is faster because it removes the need to check for the positivity of the index, and should therefore be preferred when possible. Negative indices are allowed though, and they are interpreted as \emph{reverse} indices, where \cppinline{-1} refers to the last element of the vector, \cppinline{-2} the one before the last, etc.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v[0];    // 1, int index
v[0u];   // 1, unsigned int index (faster, but more cumbersome)
vec[-1]; // 4, int index
vec[-2]; // 3, int index
vec[-1] == vec[vec.size()-1]; // always true

v[0.1]; // error: can only access using integers
\end{cppcode}
\end{example}

As discussed in the overview (\ref{SEC:core:overview:views}), one can also use a vector to index another one. This is creates a \emph{view} into the vector. Similarly to scalar indexing, creating a view is only allowed by using integer vectors, i.e., \cppinline{vec1u}, \cppinline{vec1i} and their multidimensional counterparts. Again, unsigned integers should be preferred when possible.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,2,3};
v[id]; // 1,3,4
\end{cppcode}
\end{example}

Sometimes, one will want to use views to access all the elements at once, for example to set all the elements of a vector to a specific value. This can be done with a loop, of course, but it can be boring to write. To do so without explicitly writing the loop, one typically has to create first an index vector containing all the indices of the target vector, and then apply the operation:

\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,1,2,3}; // all the indices of v
v[id] = 12;

// Note that the following will not work
v = 12; // now v only contains a single element equal to 12
\end{cppcode}

Not only is this not very practical to write, it is error prone and not very clear. If we decide to add an element to \cppinline{v}, we also have to modify \cppinline{id}. Not only this, but it will most likely be slower than writing the loop directly, because the compiler may not realize that you are accessing all the elements contiguously, and will fail to optimize it properly. For this reason, we also introduce the ``placeholder'' symbol, defined as a single underscore \cppinline{_}. When used as an index, it means ``all the indices in the range''. Coming back to our example:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_] = 12; // it cannot get much shorter
\end{cppcode}

This placeholder index can be used in all situations, with both flat and multidimensional indexing. It can be further refined to only encompass a fraction of the whole range, using a peculiar syntax\footnote{Be warned that this feature has been introduced recently and may not survive in the future.}:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_-2] = 12;   // only access the indices 0 to 2
v[2-_] = 12;   // only access the indices 2 to 3
v[1-_-2] = 12; // only access the indices 1 to 2
\end{cppcode}

Except for the special case of the placeholder index \cppinline{_}, all the indexing methods described above perform \emph{bound checks} before accessing each element. In other words, the vector class makes sure that each index is smaller than either the total size of the vector (for flat indices) or the length of its corresponding dimension (for multidimensional indices). If this condition is not satisfied, an assertion is raised explaining the problem, and the program is stopped immediately to prevent memory corruption.

\begin{advanced}
This bound checking has a small but noticeable impact on performances. In most cases, the added security is definitely worth it. Indeed, accessing a vector with an out of bounds index has very unpredictable impacts on the behavior of the program: sometimes it will crash, but most of the time it will not. Memory will be silently corrupted, the problem will be hard to notice, but the consequences can be terrible... Then, identifying the root of the problem to fix it may prove even more challenging. This is why bound checking is enabled by default.

However, there are cases where bound checking is superfluous, for example if we already know \emph{by construction} that the indices we are dealing with will always be valid. Sometimes the compiler may realize that and optimize the checks away, but one should not rely on it. If these situations are computation-limited, i.e., a lot of time is spent doing some number crushing for each element, then the performance hit of bound checking will be negligible, and one should not worry about it. On the other hand, if very little work is done per element, then most of the time will be spent iterating from one index to the next and loading the value in the CPU cache, and bound checking can take a significant amount of the total time.

For this reason, the \phypp vector also offers an alternative indexing interface, the \emph{safe} interface, that behaves exactly like the standard interface described above, except that it does not perform bound checking. One may access it using \cppinline{v.safe[i]} for flat indexing, or \cppinline{v.safe(x,y)} for multidimensional indexing, and it can also be used to create views. This interface is not meant to be used in daily coding, but rather for computationally intensive functions that you write once but use many times.
\end{advanced}

\subsection{Operators \label{SEC:core:vec:operator}}

The set of available operators depend on the type of the elements contained in the vector.

\begin{itemize}
\item For arithmetic types (\cppinline{int}, \cppinline{unsigned int}, \cppinline{float} and \cppinline{double}): addition (\cppinline{+}), subtraction (\cppinline{-}), multiplication (\cppinline{*}), division (\cppinline{/}) and (integer types only) modulo (\cppinline{%}).

\item For \cppinline{bool}: and (\cppinline{&&}), or (\cppinline{||}) and negation (\cppinline{!}).

\item For \cppinline{std::string}: concatenation (\cppinline{+}).

\item For all types: less than (\cppinline{<}), less than or equal (\cppinline{<=}), greater than (\cppinline{>}), greather than or equal (\cppinline{>=}), equal (\cppinline{==}) and not equal (\cppinline{!=}).
\end{itemize}

In all cases, the operator overloading allows mixing together vectors of different types (as long as they are convertible one to another) and scalar values.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v + 2; // {3,4,5,6}
v + v; // {2,4,6,8}

vec1s fruits = {"apple", "orange"};
"I ate an "+fruits; // {"I ate an apple", "I ate an orange"}
2+fruits;           // error: no operator found for int + std::string
\end{cppcode}
\end{example}

\section{The view class \label{SEC:core:view}}

The full type of the view class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec<Dimension,ElementType*>;
//            note the asterisk ^
\end{cppcode}

The public interface of the view class is very similar to that of the normal vector, and we will not repeat it here. There are some important differences though, which are inherent to the goal of this class. In particular, there is no available constructor (you do now create a view yourself, you ask for it from an existing vector that will create it for you), and the \cppinline|resize()| function is not available. Lastly, the view implements \cppinline|concretize()|, differently.

Thanks to their strong similarity, we will not distinguish in the other sections between vectors and views, and will consider views as just another kind of vectors. Indeed, the interface of these two classes has been designed for views to be completely interchangeable with vectors, and vice versa, so that the code of any given function is generally written once and is valid for both types.

\subsection{Member functions \label{SEC:core:view:member_fun}}

\begin{itemize}
\item \cppinline|vec<D,T> vec<D,T*>::concretize() const|

This function creates a new vector out of the elements of this view. The returned vector is completely independent from this view, or the original vector this view is currently pointing to. This function is mostly useful when writing generic functions. Indeed, views are implicitly convertible to normal vectors on assignment (\ref{SEC:core:vec:constructor}).
\end{itemize}

\section{Metaprogramming traits and functions (WIP) \label{SEC:core:meta}}

\begin{warning}
This whole section is more advanced than the rest. It is describing the sets of helper types and metaprogramming functions that one can use to write new functions. It is intended to be followed by readers already familiar with the \phypp library, and with good knowledge of C++ metaprogramming.
\end{warning}


% Functions:

% n_elements

% dim

% element
% first
% last

\chapter{Support libraries \label{SEC:support}}

In this chapter we describe the set of helper functions that are part of the \phypp support library. These functions are not essential to the use of the \phypp library, but are mostly modular components that one may choose to use or not. All the support functions are sorted into broad categories to help you discover new functions and algorithm. Alternatively, if you know the name of a function and would like to read its documentation, an index is available at the end of this document.

Note that, in all this section, the signature of the functions is given in pseudo-code, both for conciseness and readability. In particular, the following rules apply.

\begin{itemize}
\item The presence of the \vectorfuncsym symbol in front of the signature of the function means that this function is also available in a \emph{vectorized} form. This only applies to functions whose first argument is a scalar (i.e., not a vector). In this case, the vectorized form shares the same signature as the original form, but the first argument is promoted to a vector. Calling the vectorized version is the same as writing a loop to call the original version on each element of the vector. If the original function had a return value, the vectorized form returns a vector whose elements are the return value of each call, corresponding to each element of the input vector. The vectorized version can be faster than writing the loop manually.

\begin{example}
\begin{cppcode}
// Suppose this function is marked as vectorized
bool is_odd(uint_t)
// It means that there is another function with the
// same name, but that acts on a vector instead
vec<D,bool> is_odd(vec<D,uint_t>)

// It is used like this
vec1u v = {1,2,3,4,5};
vec1b b = is_odd(v);
// ... and is equivalent to
vec1b b(v.dims);
for (uint_t i : range(v)) {
    b[i] = is_odd(v[i]);
}
\end{cppcode}
\end{example}

\item If the function depends on an external library, the name of this library will be written before the signature, for example if LAPACK is needed you will find the symbol \lapacksym.

\item Template parameters are not declared explicitly. They are always written in uppercase, usually with a single character (e.g., \cppinline{T}, \cppinline{D}), or possibly two (e.g., a letter and a number), but never more. Letters \cppinline{T}, \cppinline{U}, \cppinline{V}, etc.~refer to template \emph{types}, while letters \cppinline{D}, \cppinline{N} or \cppinline{I} refer to template \emph{integers}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void foo(T)
// Corresponding C++ code
template<typename T>
void foo(T);

// Pseudo-code used in this section
void foo(vec<D,T> v, U u)
// Corresponding C++ code
template<std::size_t D, typename T, typename U>
void foo(vec<D,T> v, U u);
\end{cppcode}
\end{example}

\item Template parameters are omitted when not relevant to the description of the function. In this case, it is implicitly assumed that the function will work for any type/value of these template parameters.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void sort(vec&)
// Corresponding C++ code
template<std::size_t D, typename T>
void sort(vec<D,T>&);
\end{cppcode}
\end{example}

\item There are only two kinds of arguments: input arguments, and input/output arguments. Input arguments are always spelled as plain types, e.g. \cppinline{T}, even if the actual signature of the function uses a constant reference, an r-value reference or a universal reference. The reason is that this implementation choice does not matter to the end user. What matters is the interface. The input/output parameters are always C++ references, e.g. \cppinline{T&}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
vec1u dims(vec)
// Corresponding C++ code could be either
template<std::size_t D, typename T>
vec1u dims(vec<D,T>);
// ... or
template<std::size_t D, typename T>
vec1u dims(const vec<D,T>&);
// The only difference is that the first version will
// always make a copy (or move) of its parameter, while
// the second may not. This optimization choice depends
// on the actual code inside the function, and has no
// consequence on how the function is actually used.
\end{cppcode}
\end{example}

\item The ellipsis \cppinline{...} is used to symbolize a list of multiple arguments whose length can vary depending on the context. These arguments are not spelled out explicitly, but the description of the function must make it clear what they are used for. Optionally, a type may be placed before the ellipsis to indicate that all the arguments must be of this same type.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t flat_id(vec, ...)
// Corresponding C++ code
template<std::size_t D, typename T, typename ... Args>
uint_t flat_id(vec<D,T>, Args&& ...);
\end{cppcode}
\end{example}

\item The \cppinline{std} namespace is omitted for common standard types, like \cppinline{std::string} or \cppinline{std::array}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t length(string)
// Corresponding C++ code
uint_t length(const std::string&);
\end{cppcode}
\end{example}

\item For the particular case of \cppinline{std::array}, the individual elements inside the array can be named by placing the names inside curly braces after the type of the array.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t distance(array {x,y})
// Corresponding C++ code
template<typename T>
uint_t length(const std::array<T,2>& a) {
    // x := a[0]
    // y := a[1]
}
\end{cppcode}
\end{example}

\item If the return type of a function in pseudo-code is \cppinline{auto}, it means that this return value is ``complex'' (usually a structure or a class) and it is not important to know its precise type. The description of the function must therefore make it clear how this return value can be used.

\end{itemize}

With this in mind, it is clear that this chapter focuses on the \emph{interface} that is provided by the library, rather than on the individual function themselves. In fact, a single interface may be composed of many different functions to take care of all the combination of types that the interface supports. If the reader is interested in all these overloads, or is experiencing a particular compiler error that cannot be easily fixed just by looking at the interface, then it is best to look directly into the code of the library. Although less readable than the pseudo-code used in this document, most of the time an effort is made to make the code as clear as possible. However, if a function is too hard to understand, I consider this as a bug that should be reported on the \texttt{github} issue tracker (seriously). Similarly, if you end up doing something wrong with the library, but that the compiler error message is too cryptic or too long, you may also fill in a bug report. Ensuring that clear error messages are sent to the user is a shared responsibility between compiler writers and library authors.

\section{Generic vector functions \label{SEC:support:generic}}

The vector and view classes are useful and complete tools. However, there are a number of tasks that one repeatedly need to do, like generating a sequence of indices, or sorting a vector, and that would be tedious to write each time they are needed. For this reason, the \phypp library comes with a large set of utility functions to sort, rearrange, and select data inside vectors. In this section we list these functions and algorithms.

This support library also introduces a global constant called \cppinline{npos}\itt{npos}. This is an unsigned integer whose value is the largest possible integer that the \cppinline{uint_t} type can hold. It is meant to be used as an error value, or the value to return if no normal value would make sense. It is very similar in concept to the \cppinline{std::string::npos} provided by the C++ standard library. In particular, it is worth noting that converting \cppinline{npos} to a \emph{signed} integer produces the value \cppinline{-1}.

We now describe the functions provided by this library, sorted by categories.

\subsection{Range-based iteration}

\begin{itemize}
\input{support_generic_range.tex}
\end{itemize}

\subsection{Index manipulation}

\begin{itemize}
\input{support_generic_index.tex}
\end{itemize}

\subsection{Integer sequences}

\begin{itemize}
\input{support_generic_sequence.tex}
\end{itemize}

\subsection{Rearranging elements}

\begin{itemize}
\input{support_generic_rearrange.tex}
\end{itemize}

\subsection{Finding elements}

\begin{itemize}
\input{support_generic_find.tex}
\end{itemize}

\subsection{Modifying dimensions}

\begin{itemize}
\input{support_generic_dim.tex}
\end{itemize}

\subsection{Error checking \label{SEC:support:generic:error}}

\begin{itemize}
\input{support_generic_error.tex}
\end{itemize}

\section{Parsing command line arguments \label{SEC:support:cmd}}
% argv.hpp

\begin{itemize}
\input{support_cmd.tex}
\end{itemize}

\section{File input/output \label{SEC:support:file}}
% file.hpp

\subsection{File system \label{SEC:support:file:system}}

This section describes the function provided by the \phypp library that are related to file system management, i.e., getting informations, creating or copying files and directories. All paths can be either absolute, or relative to the working directory.

\begin{itemize}
\input{support_file_system.tex}
\end{itemize}

\subsection{ASCII table input/output \label{SEC:support:file:ascii}}

\begin{itemize}
\input{support_file_ascii.tex}
\end{itemize}

\section{String manipulation \label{SEC:support:string}}

\subsection{String conversions \label{SEC:support:string:convert}}

\begin{itemize}
\input{support_string_convert.tex}
\end{itemize}

\subsection{String operations \label{SEC:support:string:modify}}

\begin{itemize}
\input{support_string_modify.tex}
\end{itemize}

\section{OS interaction \label{SEC:support:os}}

\begin{itemize}
\input{support_os.tex}
\end{itemize}

\section{Printing to the terminal \label{SEC:support:print}}
% print.hpp

\begin{itemize}
\input{support_print.tex}
\end{itemize}

\section{Measuring time \label{SEC:support:time}}

\begin{itemize}
\input{support_time.tex}
\end{itemize}

\section{Mathematics \label{SEC:support:math}}

The mathematics support library is among the largest inside \phypp. It contains many functions, as well as a handful of useful constants. Some functionalities of this library are only available if you have installed the \texttt{fftw} and \texttt{gsl} libraries. If not, the specific functions that depend on these libraries will not be available, or will be slow, but the rest of the library will function properly.

This library provides the following global constants:
\begin{itemize}
\item \cppinline{fnan}\itt{fnan} and \cppinline{dnan}\itt{dnan}. These are the \cppinline{float} and \cppinline{double} representation of the ``not-a-number'' (NaN) special value. This value is returned by some operations that are mathematically undefined in the real domain. For example, dividing zero by zero, or taking the square root of a negative number. NaN has some very peculiar properties that can surprise the newcomer. In particular, it propagates extremely fast, since any operation involving at least a NaN value will always return NaN, e.g., \cppinline{2.0 + fnan == fnan}). More troubling, any comparison operation involving a NaN will return \cppfalse, e.g., \cppinline{(10.0 < fnan) == false} and \cppinline{(10.0 >= fnan) == false} too. The only notable exception to this rule is that \cppinline{(fnan != fnan) == true}. Knowing this, NaN is a very useful return value to indicate that giving an actual value would not make sense. For example, in a galaxy catalog, some galaxies may have been observed at a certain wavelength, but not all of them. For those that are not observed, we do not know their flux. In this case, astronomers typically assign them a special, weird value, such as \cppinline{-99}. Using NaN in this case is clearer.

\item \cppinline{fpi}\itt{fpi} and \cppinline{dpi}\itt{dpi}. This is the \cppinline{float} and \cppinline{double} closest representation of the number $\pi = 3.14519...$.

\item \cppinline{finf}\itt{finf} and \cppinline{dinf}\itt{dinf}. This is the \cppinline{float} and \cppinline{double} representation of the positive infinity. The positive infinity is larger than any other finite value.
\end{itemize}

We now present the functions provided by this support library. One of the responsibilities of this library is to bring vectorized versions of standard mathematical functions that only work for scalar values. Since these functions are fairly common and well known, we will not describe their signature and behavior, and instead just list them here:

\begin{itemize}
\item exponentiation: \cppinline{sqrt}\itt{sqrt}, \cppinline{pow}\itt{pow},
\item trigonometry: \cppinline{cos}\itt{cos}, \cppinline{sin}\itt{sin}, \cppinline{tan}\itt{tan}, \cppinline{acos}\itt{acos}, \cppinline{asin}\itt{asin}, \cppinline{atan}\itt{atan}, \cppinline{cosh}\itt{cosh}, \cppinline{sinh}\itt{sinh}, \cppinline{tanh}\itt{tanh}, \cppinline{acosh}\itt{acosh}, \cppinline{asinh}\itt{asinh}, \cppinline{atanh}\itt{atanh},
\item exponentials and logarithms: \cppinline{exp}\itt{exp}, \cppinline{log}\itt{log}, \cppinline{log2}\itt{log2}, \cppinline{log10}\itt{log10},
\item special functions: \cppinline{erf}\itt{erf}, \cppinline{erfc}\itt{erfc}, \cppinline{tgamma}\itt{tgamma},
\item rounding: \cppinline{ceil}\itt{ceil}, \cppinline{floor}\itt{floor}, \cppinline{round}\itt{round},
\item absolute value: \cppinline{fabs}\itt{fabs}.
\end{itemize}

We also introduce the functions \cppinline{bessel_j0}\itt{bessel_j0}, \cppinline{bessel_j1}\itt{bessel_j1}, \cppinline{bessel_y0}\itt{bessel_y0}, \cppinline{bessel_y1}\itt{bessel_y1}, \cppinline{bessel_i0}\itt{bessel_i0}, \cppinline{bessel_i1}\itt{bessel_i1}, \cppinline{bessel_k0}\itt{bessel_k0}, \cppinline{bessel_k1}\itt{bessel_k1}. The scalar version of the first four are provided by the C++ standard, while the last four are provided by the \texttt{gsl}.

We now list the other, less common functions provided in this library. These are grouped by sections.

\subsection{Low level mathematics}

\begin{itemize}
\input{support_math_lowlevel.tex}
\end{itemize}

\subsection{Sequences and bins}

\begin{itemize}
\input{support_math_sequence.tex}
\end{itemize}

\subsection{Randomization}

\begin{itemize}
\input{support_math_random.tex}
\end{itemize}

\subsection{Reduction}

\begin{itemize}
\input{support_math_reduce.tex}
\end{itemize}

\subsection{Interpolation}

\begin{itemize}
\input{support_math_interpol.tex}
\end{itemize}

\subsection{Calculus}

\begin{itemize}
\input{support_math_calculus.tex}
\end{itemize}

\subsection{Algebra}

\begin{itemize}
\input{support_math_algebra.tex}
\end{itemize}

\subsection{Fitting}

\begin{itemize}
\input{support_math_fit.tex}
\end{itemize}

\subsection{Geometry}

\begin{itemize}
\input{support_math_geometry.tex}
\end{itemize}

\subsection{Debug functions}

\begin{itemize}
\item \cppinline|void data_info(vec)| \itt{data_info}
\item \cppinline|void mprint(vec<2,T>)| \itt{mprint}
\end{itemize}

\section{Parallel execution \label{SEC:support:thread}}
% thread.hpp

\begin{itemize}
\input{support_thread.tex}
\end{itemize}

\section{FITS input/output \label{SEC:support:fits}}
% fits.hpp

The FITS (Flexible Image Transport System) format is a general purpose file format developed for astrophysics data. In particular, FITS files can store images with floating point pixel values, image cubes, but also binary data tables with an arbitrary number of columns and rows. Using a meta-data system (FITS keywords), FITS files usually carry a number of important additional informations about their content. E.g., for images files, the mapping between image pixels and sky coordinates (WCS coordinates), or the physical unit of the pixel values.

Storying data tables in binary inside FITS files is a space-efficient and fast way to store and read non-image data. FITS tables come in two fashions: row-oriented and column-oriented tables. In row-oriented tables, all the data about one row (e.g., about one galaxy in the table) is stored contiguously on disk. This means that it is very fast to retrieve all the information about a given object. In column-oriented tables however, a whole column is stored contiguously in memory. This means that it is very fast to read a given column for all the objects in the table. Due to the way the \phypp library is designed, it is more efficient to use the latter format, since a given column of the file will be represented by a single \phypp vector. It also brings the nice advantage of allowing to store columns of different lengths, e.g.~to combine two tables in the same file, or to carry meta-data that would be hard to store in the standard FITS keywords. The column-oriented format is not well known, but most softwares and libraries do support it\footnote{Topcat does. In IDL, column-oriented FITS files are supported by the \cppinline{mrdfits} and \cppinline{mwrfits} procedures.}.

Finally, note that this support library introduces a new type: \cppinline{fits::header} (that we will shorten to \cppinline{header} in the following). This type is used to store the header of any FITS file. For now, it is actually just a raw \cppinline{std::string}, but that might change in the future.

We now describe the various functions offered by this library, split into categories.

\subsection{Generic header functions \label{SEC:support:fits:header}}

\begin{itemize}
\input{support_fits_header.tex}
\end{itemize}

\subsection{FITS images input/output \label{SEC:support:fits:image}}

\begin{itemize}
\input{support_fits_image.tex}
\end{itemize}

\subsection{WCS coordinates \label{SEC:support:fits:wcs}}

\begin{itemize}
\input{support_fits_wcs.tex}
\end{itemize}

\subsection{FITS tables input/output \label{SEC:support:fits:table}}

\begin{itemize}
\input{support_fits_table.tex}
\end{itemize}


\section{Image processing \label{SEC:support:image}}
% image.hpp

\begin{itemize}
\input{support_image.tex}
\end{itemize}

\section{Astrophysics \label{SEC:support:astro}}
% astro.hpp

\subsection{PSF fitting}

\begin{itemize}
\input{support_astro_psffit.tex}
\end{itemize}

\subsection{Cosmology}

\begin{itemize}
\input{support_astro_cosmo.tex}
\end{itemize}

\subsection{Fluxes, magnitudes and luminosities}

\begin{itemize}
\input{support_astro_flux.tex}
\end{itemize}

\subsection{Sky coordinates}

\begin{itemize}
\input{support_astro_sky.tex}
\end{itemize}

\subsection{Catalog management}
% astro/catalog_merge.hpp

\begin{itemize}
\input{support_astro_catalog.tex}
\end{itemize}

\subsection{Image stacking}
% astro/qstack.hpp

\begin{itemize}
\input{support_astro_stack.tex}
\end{itemize}

\subsection{Template fitting}
% astro/qstack.hpp

\begin{itemize}
\input{support_astro_sedfit.tex}
\end{itemize}

\chapter{Tools \label{SEC:tool}}

\section{Astrophysics \label{SEC:tool:astro}}
\subsection{\texttt{angcorrel}} \itt{angcorrel}
\subsection{\texttt{catinfo}} \itt{catinfo}
\subsection{\texttt{deg2sex} and \texttt{sex2deg}} \itt{deg2sex} \itt{sex2deg}
\subsection{\texttt{findsrc}} \itt{findsrc}
\subsection{\texttt{fluxcube}} \itt{fluxcube}
\subsection{\texttt{getgal}} \itt{getgal}
\subsection{\texttt{photinfo}} \itt{photinfo}
\subsection{\texttt{psffit}} \itt{psffit}
\subsection{\texttt{qstack2}} \itt{qstack2}
\subsection{\texttt{qxmatch2}} \itt{qxmatch2}
\subsection{\texttt{randsrc}} \itt{randsrc}
\subsection{\texttt{subsrc}} \itt{subsrc}

\section{FITS and ASCII \label{SEC:tool:fits}}
\subsection{\texttt{fits2ascii}} \itt{fits2ascii}
\subsection{\texttt{fitstool}} \itt{fitstool}
\subsection{\texttt{imgtool}} \itt{imgtool}
\subsection{\texttt{qconvol}} \itt{qconvol}
\subsection{\texttt{remcol}} \itt{remcol}


\printindex

\end{document}
