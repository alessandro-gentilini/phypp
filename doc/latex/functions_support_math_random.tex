\funcitem \cppinline|auto make_seed(T)| \itt{make_seed}

This function creates a new \emph{seed}. A seed is generally created at the beginning of a program, and is then used throughout to generate random numbers. Any positive integral number can be used to create the seed. The choice of this number influences which random numbers will be generated by the program. If the seed is always initialized with the same number, the program will always generate the same random values if it is executed multiple times. This is a very useful property, since the program will yield the same output regardless of when it is executed or if whether or not it is raining outside.

\begin{example}
\begin{cppcode}
// We create the seed
auto seed = make_seed(42);

// Now we can use it to generate random numbers
// (see the documentation of randomu())
double rnd = randomu(seed);
rnd; // will be something between 0 and 1
rnd = randomu(seed);
rnd; // will be some other value between 0 and 1

// Calling this program another time will produce the same numbers
\end{cppcode}
\end{example}

\begin{advanced}
The seed is basically the state of the random number generator, which is chosen in all the \phypp library to be a ``Mersene twister''. A random number generator in a given state will always generate the same random numbers, in a predictable way, even though this series of number will still be ``random'' in the sense that there will be no apparent logical connection between consecutive numbers.

The quality of a random number generator depends on how easy it is to figure out the link between one number and the next. The simplest generators only require a handful of operations, often including modulos and bit-wise operations, and are therefore very fast. The values they generate really appear to be random at first sight, however they usually have a relatively low period (i.e., the number of random values that can be generated until the random number generator comes back to its initial state and starts to repeat itself). This can be shown easily when generating random images, where regular patterns can be found by eye. Mersene twisters are more advanced, but they provide a very good trade off between quality and speed. In particular, they should provide random numbers of high enough quality for all physics related usages.

If generating random numbers happens to be one of the main performance bottleneck of one of your program, and if you can accept the loss in randomness quality, you can decide to use a faster random number generator. The C++ standard library provides several other alternatives in \cppinline{#include<random>}, it is up to you to figure out the one that suits you best. You can also write your own, provided it satisfies the interface requirements. You can then use it in all the \phypp random functions in place of the usual Mersene twister. For reference, the default randomn number generator used in \phypp (the one that is returned by \cppinline{make_seed()}) is \cppinline{std::mt19937}.
\end{advanced}

\funcitem \cppinline|double randomn(auto& seed)| \itt{randomn}

\cppinline|vec<N,double> randomn(auto& seed, ...)|

This function generates random double precision floating point values that are distributed according to the canonical Gaussian (or normal) probability distribution. This distribution has a mean, median and mode of zero and a standard deviation of one.

Both versions need a random seed as first argument (see \cppinline{make_seed()}). The first version generates one number, while the second will create a new vector and fill it with random values. The other arguments after the seed are the dimensions of the generated vector.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

// Generate one random number
double rnd = randomn(seed);
// Generate 1000 numbers
vec1d rv = randomn(seed, 1000);
// Generate 500 x 100 numbers
vec2d rv2 = randomn(seed, 500, 100);

// Properties of the distribution
mean(rv); // should be close to zero
stddev(rv); // should be close to one
min(rv); // can be anything, most likely negative
max(rv); // can be anything, most likely positive

// Other distributions can be generated from this one.
// For example if one says that a value is measured to be equal to
// 'x' plus or minus 'dx', then this value can be simulated using
double x = 3, dx = 0.5;
vec1d obs = x + dx*randomn(seed, 1000);
\end{cppcode}
\end{example}

\funcitem \cppinline|double randomu(auto& seed)| \itt{randomu}

\cppinline|vec<N,double> randomu(auto& seed, ...)|

This function generates random double precision floating point values that are distributed according to the canonical uniform probability distribution. This distribution has a mean and median of \cppinline{0.5}, a minimum of \cppinline{0} and a maximum of \cppinline{1}. All numbers in this interval have the same probability of appearing.

Both versions need a random seed as first argument (see \cppinline{make_seed()}). The first version generates one number, while the second will create a new vector and fill it with random values. The other arguments after the seed are the dimensions of the generated vector.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

// Generate one random number
double rnd = randomu(seed);
// Generate 1000 numbers
vec1d rv = randomu(seed, 1000);
// Generate 500 x 100 numbers
vec2d rv2 = randomu(seed, 500, 100);

// Properties of the distribution
mean(rv); // should be close to 0.5
min(rv); // will be greater or equal to 0
max(rv); // will be less or equal to 1

// Other distributions can be generated from this one.
// For example to generate values with uniform probability between
// 'mi' and 'ma'
double mi = -3, ma = 5;
vec1d v = mi + (ma - mi)*randomu(seed, 1000);
\end{cppcode}
\end{example}

\funcitem \cppinline|T randomi(auto& seed, T mi, T ma)| \itt{randomi}

\cppinline|vec<N,T> randomi(auto& seed, T mi, T ma, ...)|

This function generates random integer values that are distributed according to the uniform probability distribution between \cppinline{mi} and \cppinline{ma} (inclusive). All numbers in this interval have the same probability of appearing.

Note that generating random integer numbers is more complex than floating point numbers, and it is easy to make mistakes that will bias the resulting probability distribution. You should always prefer using this function rather than emulating the same output with rounded floating point numbers.

Both versions need a random seed as first argument (see \cppinline{make_seed()}). The first version generates one number, while the second will create a new vector and fill it with random values. The other arguments after the seed are the dimensions of the generated vector.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

int mi = -5, ma = 5;

// Generate one random number
int rnd = randomi(seed, mi, ma);
// Generate 1000 numbers
vec1i rv = randomi(seed, mi, ma, 1000);
// Generate 500 x 100 numbers
vec2i rv2 = randomi(seed, mi, ma, 500, 100);

// Properties of the distribution
mean(rv); // should be close to '0.5*(mi + ma)'
min(rv); // will be greater or equal to 'mi'
max(rv); // will be less or equal to 'ma'
\end{cppcode}
\end{example}

\funcitem \cppinline|T random_pdf(auto& seed, vec<1,T> x, vec<1,U> y)| \itt{random_pdf}

\cppinline|vec<N,T> random_pdf(auto& seed, vec<1,T> x, vec<1,U> y, ...)|

This function generates random double precision floating point values that are distributed according to an arbitrary probability distribution given here in terms of \cppinline{x} and \cppinline{y} which represent, respectively, a list of values and their corresponding probability. This function considers that the probability distribution is continuous and varies linearly between the provided values.

Both versions need a random seed as first argument (see \cppinline{make_seed()}). The \cppinline{x} and \cppinline{y} values define the probability distribution. This distribution does not need to be normalized (i.e., have an integral equal to one), however it is required that \cppinline{x} is sorted and that both \cppinline{x} and \cppinline{y} only contain finite values. The first version generates one number, while the second will create a new vector and fill it with random values. The other arguments after the seed are the dimensions of the generated vector.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

// We need a proper distribution
// For example
vec1d x = {1, 2, 8, 9};
vec1d y = {0, 1, 1, 0};

// Graphically:
//
// 1       -------------------
//        /                   \
//       /                     \
// 0 ----                       ----
//      1  2  3  4  5  6  7  8  9

// Generate one random number
double rnd = random_pdf(seed, x, y);
// Generate 1000 numbers
vec1d rv = random_pdf(seed, x, y, 1000);
// Generate 500 x 100 numbers
vec2d rv2 = random_pdf(seed, x, y, 500, 100);
\end{cppcode}
\end{example}

\funcitem \cppinline|bool random_coin(auto& seed, double p)| \itt{random_coin}

\cppinline|vec<N,bool> random_coin(auto& seed, double p, ...)|

This function generates random boolean values with a probability \cppinline{p} of generating \cppinline{true} and \cppinline{1-p} of generating \cppinline{false}.

Both versions need a random seed as first argument (see \cppinline{make_seed()}). The first version generates one number, while the second will create a new vector and fill it with random values. The other arguments after the seed are the dimensions of the generated vector.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

double p = 0.7;

// Generate one random number
bool rnd = random_coin(seed, p);
// Generate 1000 numbers
vec1b rv = random_coin(seed, p, 1000);
// Generate 500 x 100 numbers
vec2b rv2 = random_coin(seed, p, 500, 100);

// Properties of the distribution
fraction_of(rv); // should be close to 'p'
\end{cppcode}
\end{example}

\funcitem \cppinline|vec shuffle(auto& seed, vec v)| \itt{shuffle}

\cppinline|void inplace_shuffle(auto& seed, vec& v)| \itt{inplace_shuffle}

These functions will randomly modify the order of all the values inside the vector \cppinline{v}. The function \cppinline{shuffle()} will re-order a copy of the provided vector, while \cppinline{inplace_shuffle()} will modify the provided vector directly and is therefore faster. Note that there is a non-zero probability that the order will remain the same.

\begin{example}
\begin{cppcode}
// We create the seed (see make_seed())
auto seed = make_seed(42);

vec1u v = indgen(5);
v; // {0,1,2,3,4}

inplace_shuffle(v);
v; // could be {3,1,2,4,0}
\end{cppcode}
\end{example}
