<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>phy++ API</title>
    <link rel="stylesheet" href="pygments.css">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
  </head>
  <body>

  <div class="header">
  <i>phy</i><sub>++</sub> <span class="header-text">documentation</span>
  </div>

  <div class="page">
  <script src="menu-left.js"></script>
  <script src="menu-right.js"></script>

<div class="content">
<span class="section">Categories</span><br>
<div class="catlist">
<a href="category_support_08_time.html">Measuring time</a>
</div><br>
<span class="section">Signatures</span>
<table style="signatures">
<tr><td><div class="highlight-sig"><pre><span class="k">auto</span> <span class="n">progress_start</span><span class="p">(</span><span class="kt">uint_t</span><span class="p">)</span>
</pre></div></td></tr>
<tr><td><div class="highlight-sig"><pre><span class="kt">void</span> <span class="n">progress</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="p">,</span> <span class="kt">uint_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
</pre></div></td></tr>
<tr><td><div class="highlight-sig"><pre><span class="kt">void</span> <span class="n">print_progress</span><span class="p">(</span><span class="k">auto</span> <span class="n">p</span><span class="p">,</span> <span class="n">T</span> <span class="n">i</span><span class="p">,</span> <span class="kt">uint_t</span> <span class="n">m</span><span class="p">)</span>
</pre></div></td></tr>
</table>
<br><span class="section">Description</span><br>
<div class="description">
These functions are used to estimate and display in the terminal the time it will take to complete a given loop as well as a progress bar. At first, this time is unknown. After the first iteration is done, we have an estimate of how long it takes to perform one single iteration. Assuming that the calculation load is evenly spread over the whole loop (i.e., that each iteration will roughly take the same amount of time to execute), we can extrapolate how long it will take to complete. Since a single iteration can be relatively short, and since there can be small variation in execution time from one iteration to another, the estimate of the remaining time is refined after each iteration until the end of the loop.
<br><br>
<div class="highlight-inline"><pre><span class="n">progress_start</span><span class="p">()</span></pre></div> is used to initialize the prediction code before the loop begins, and inform it of how many iterations it will go through. Then, <div class="highlight-inline"><pre><span class="n">progress</span><span class="p">()</span></pre></div> is called at the end of <span class="emphasis">each</span> iteration (be careful of early exits with <div class="highlight-inline"><pre><span class="k">continue</span></pre></div> keywords) to update the statistics and update the time estimate in the terminal. Be careful that printing to the terminal is costly, and doing so for each iteration can dramatically slow down your program. Therefore <div class="highlight-inline"><pre><span class="n">progress</span><span class="p">()</span></pre></div> has an optional argument <div class="highlight-inline"><pre><span class="n">m</span></pre></div> that specifies that printing should be done only every <div class="highlight-inline"><pre><span class="n">m</span></pre></div> iterations. Advice: for cosmetic purposes, avoid choosing values of <div class="highlight-inline"><pre><span class="n">m</span></pre></div> that end with an even digit (<div class="highlight-inline"><pre><span class="mi">0</span></pre></div> included) or <div class="highlight-inline"><pre><span class="mi">5</span></pre></div>, and avoid using <div class="highlight-inline"><pre><span class="mi">0</span></pre></div> for any digit; for example <div class="highlight-inline"><pre><span class="mi">13</span></pre></div> or <div class="highlight-inline"><pre><span class="mi">621</span></pre></div> are fine. This will make it less obvious that printing is not done for all iterations.
<br><br>
Also, make sure that the terminal window is sufficiently large to display the whole progress bar. If not enough space is available, the output may look bad. A future version of these functions will
fetch the width of the terminal programmatically and adjust the size of the progress bar accordingly.
<br><br><span class="example">Example</span><br><hr>
<div class="highlight"><pre><span class="kt">uint_t</span> <span class="n">nelem</span> <span class="o">=</span> <span class="mi">10000</span><span class="p">;</span>

<span class="c1">// Initialize the estimation</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">progress_start</span><span class="p">(</span><span class="n">nelem</span><span class="p">);</span>

<span class="c1">// Enter the loop</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">uint_t</span> <span class="n">i</span> <span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="n">nelem</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Do some complex stuff...</span>
    <span class="c1">// Here we simulate that with a sleep() command that will block</span>
    <span class="c1">// the program for the provided duration (in seconds).</span>
    <span class="kr">thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mf">0.05</span><span class="p">);</span>

    <span class="c1">// Estimate the time and print the estimate every 13 iterations</span>
    <span class="n">progress</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="mi">13</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// During the execution of the loop, the user will see something</span>
<span class="c1">// similar to:</span>
<span class="c1">//</span>
<span class="c1">// [--            ] 1207  12%, 1m00s elapsed, 7m20s left, 8m21s total</span>
<span class="c1">//</span>
<span class="c1">//        (1)        (2)  (3)      (4)           (5)          (6)</span>
<span class="c1">//</span>
<span class="c1">// Legend:</span>
<span class="c1">//  (1) progress bar, dashes indicate the progress</span>
<span class="c1">//  (2) current iteration</span>
<span class="c1">//  (3) percentage of the loop currently completed</span>
<span class="c1">//  (4) elapsed time since the beginning</span>
<span class="c1">//  (5) estimate of the time remaining</span>
<span class="c1">//  (6) estimate of the total time it will take to complete</span>
<span class="c1">//</span>
<span class="c1">// NB: The progress bar has been shrank to fit the documentation</span>
<span class="c1">// format, it is normally substantially larger.</span>
</pre></div>
<hr><br>
<br><br><span class="advanced-title">Advanced</span><div class="advanced"><hr>
The function <div class="highlight-inline"><pre><span class="n">print_progress</span><span class="p">()</span></pre></div> should be used in a situation where a calculation will be done in a fixed number of steps, but each iteration of the loop corresponds to zero or more than one such step, in an unpredictable way. In this case, you have the responsibility of figuring out how many steps were done during each iteration, and feed this progress to <div class="highlight-inline"><pre><span class="n">print_progress</span><span class="p">()</span></pre></div> which will take care of estimating the time remaining.
<br><br>
The typical use case is when a loop is executed over multiple threads, each taking care of a fraction of the whole loop. In this case, the main thread only maintains a global iteration counter and regularly update the progress to display a time estimate.
<br><br><span class="example">Example</span><br><hr>
<div class="highlight"><pre><span class="c1">// The global counter, must be an atomic type for thread-safe</span>
<span class="c1">// simultaneous read and write.</span>
<span class="n">std</span><span class="o">::</span><span class="n">atomic</span><span class="o">&lt;</span><span class="kt">uint_t</span><span class="o">&gt;</span> <span class="n">iter</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

<span class="c1">// Some data to work on</span>
<span class="n">vec1d</span> <span class="n">in</span> <span class="o">=</span> <span class="n">dindgen</span><span class="p">(</span><span class="mf">1e8</span><span class="p">);</span>
<span class="n">vec1d</span> <span class="nf">out</span><span class="p">(</span><span class="mf">1e8</span><span class="p">);</span>

<span class="c1">// The calculation to do</span>
<span class="k">auto</span> <span class="n">do_stuff</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="kt">uint_t</span> <span class="n">begin</span><span class="p">,</span> <span class="kt">uint_t</span> <span class="n">end</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">begin</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">out</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="n">sqr</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">log10</span><span class="p">(</span><span class="n">pow</span><span class="p">(</span><span class="n">in</span><span class="p">[</span><span class="n">i</span><span class="p">],</span><span class="mf">3.5</span><span class="p">));</span>

        <span class="c1">// Do not forget to update the global counter</span>
        <span class="o">++</span><span class="n">iter</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// Create a thread pool and launch them</span>
<span class="kt">uint_t</span> <span class="n">nthreads</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">pool</span> <span class="o">=</span> <span class="kr">thread</span><span class="o">::</span><span class="n">pool</span><span class="p">(</span><span class="n">nthreads</span><span class="p">);</span>
<span class="kt">uint_t</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">uint_t</span> <span class="n">i</span> <span class="o">:</span> <span class="n">range</span><span class="p">(</span><span class="n">pool</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">uint_t</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">last</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="n">nthreads</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">last</span> <span class="o">=</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">last</span> <span class="o">+=</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">()</span><span class="o">/</span><span class="n">nthreads</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">pool</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">start</span><span class="p">(</span><span class="n">do_stuff</span><span class="p">,</span> <span class="n">begin</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Wait here for the calculation to finish and display the</span>
<span class="c1">// progress</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">progress_start</span><span class="p">(</span><span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="k">while</span> <span class="p">(</span><span class="n">iter</span> <span class="o">&lt;</span> <span class="n">in</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="kr">thread</span><span class="o">::</span><span class="n">sleep_for</span><span class="p">(</span><span class="mf">0.2</span><span class="p">);</span>
    <span class="n">print_progress</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">iter</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Do not forget to close the threads</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">t</span> <span class="o">:</span> <span class="n">pool</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span><span class="p">.</span><span class="n">join</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
<hr><br>
<hr></div><br>
</div>
</div>
  </div>
  </body>
</html>

