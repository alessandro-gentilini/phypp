\documentclass[12pt]{report}

\usepackage{graphicx}
\usepackage{txfonts}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{minted}
\usepackage{geometry}
\usepackage{imakeidx}
\makeindex
\usepackage[totoc]{idxlayout}
\usepackage{xparse}
\usepackage{mdframed}
\usepackage{tikz}
\usepackage[colorlinks=true,linkcolor=blue,linktoc=page]{hyperref}

\newcommand{\via}{{\it via}\xspace}
\newcommand{\phypp}{\texttt{phy++}\xspace}
\newcommand{\cpp}[1]{\texttt{#1}\xspace}
\newcommand{\stdvec}{\cppinline|std::vector|\xspace}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.0pt] (char) {#1};}}

\newcommand{\vectorfuncsym}{\circled{$\hspace{-1pt}\mathcal{V}$}\xspace}
\newcommand{\vectorfunc}{\vectorfuncsym\hspace{2pt}\xspace}

\newcommand{\lapacksym}{\textsc{\small[lapack\small]}}
\newcommand{\lapack}{\lapacksym\hspace{2pt}\xspace}
\newcommand{\fftwsym}{\textsc{[fftw]}}
\newcommand{\fftw}{\fftwsym\hspace{2pt}\xspace}

\NewDocumentCommand\itt{v}{%
  \index{#1@\ittt{#1}}%
}

\NewDocumentCommand{\ittt}{v}{\texttt{#1}}

\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{advanced}{%
    linecolor=red,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{warning}{%
    linecolor=blue,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{example}{%
    linecolor=black,linewidth=1pt,%
    leftmargin=0pt,rightmargin=0pt,%
    innerleftmargin=0pt,innerrightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=1pt
}

\newenvironment{advanced}
{
    \begin{mdframed}[style=advanced,frametitle={Advanced}]
}
{
    \end{mdframed}
}
\newenvironment{warning}
{
    \begin{mdframed}[style=warning,frametitle={Warning}]
}
{
    \end{mdframed}
}
\newenvironment{example}
{
    \begin{mdframed}[style=example,frametitle={Example}]
}
{
    \end{mdframed}
}

\newminted{cpp}{fontsize=\small}
\newmintinline{cpp}{fontsize=\small}

\begin{document}
\begin{center}
\Large \bf \phypp v1.0
\end{center}

\tableofcontents

\chapter{Introduction \label{SEC:intro}}

\section{Getting started \label{SEC:start}}

\chapter{Core library \label{SEC:core}}
% vec.hpp
% variadic.hpp
% reflex.hpp
% range.hpp
% iterator.hpp

\section{Overview \label{SEC:core:overview}}
At the core of the \phypp library is the \emph{vector} class. This is basically an enhanced \stdvec\footnote{In fact, \stdvec is used to implement the \phypp vectors internally.}, and it therefore shares most of its features and strengths. In particular, a vector can contain zero, one, or as many elements as your computer can handle. Its size is defined at \emph{runtime}, meaning that its content can vary depending on user input, but also that a vector can change its total number of elements at any time. These elements are stored contiguously in memory, which provides optimal performances in most situations. Lastly, a vector is an homogeneous container, meaning that a given vector can only contain a single type of elements (e.g., \cppinline|int| or \cppinline|float|, but not both at the same time).

Like most advanced C++ libraries, \phypp is essentially \emph{template} based. This means that most of the code is written to work for \emph{any} type \cppinline|T|, e.g., \cppinline|int|, \cppinline|float|, \cppinline|std::string|, or whatever you need. However, while templates are a fantastic tool for library writers, they can easily become a burden for the \emph{user} of the library. The good thing is, since \phypp is a numerical analysis library, we know in advance what types will most often be stored inside the vectors. So for this reason, to reduce typing and enhance readability, we introduce type aliases for the most commonly used vector types:
\begin{itemize}
\item \cppinline|vec1f|: vector of \cppinline|float|,
\item \cppinline|vec1d|: vector of \cppinline|double|,
\item \cppinline|vec1cf|: vector of \cppinline|std::complex<float>|,
\item \cppinline|vec1cd|: vector of \cppinline|std::complex<double>|,
\item \cppinline|vec1i|: vector of \cppinline|int| (precisely, \cppinline|int_t = std::ptrdiff_t|),
\item \cppinline|vec1u|: vector of \cppinline|unsigned int| (precisely, \cppinline|uint_t = std::size_t|),
\item \cppinline|vec1b|: vector of \cppinline|bool|,
\item \cppinline|vec1s|: vector of \cppinline|std::string|,
\item \cppinline|vec1c|: vector of \cppinline|char|.
\end{itemize}

On top of the \stdvec interface, the \phypp vector adds some extra functionalities. The most important ones are operator overloading, multi-dimensional indexing, and vector views.

\subsection{Operator overloading \label{SEC:core:overview:overloading}}

The only thing you can do to operate on all the elements of an \stdvec is to iterate over these elements explicitly, either using a C++11 range-based loop, or using indices:
\begin{cppcode}
// Goal: multiply all elements by two.
std::vector<float> v = {1,2,3,4};

// Either using a range-based loop,
for (float& x : v) {
    x *= 2;
}

// ... or an index-based loop.
for (std::size_t i = 0; i < v.size(); ++i) {
    v[i] *= 2;
}
\end{cppcode}

While this is fairly readable (especially the first version), it is still not very concise and expressive. In \phypp, we have \emph{overloaded} the usual mathematical operators on our vector type, meaning that it is possible to write the above code in a much simpler way:

\begin{cppcode}
// Using phy++ vector.
vec1f w = {1,2,3,4};
w *= 2; // {2,4,6,8}
\end{cppcode}

Not only this, but we can perform operations on a pair of vectors in the same way:
\begin{cppcode}
// Goal: sum the content of the two vectors.
vec1f x = {1,2,3,4}, y = {4,3,2,1};
vec1f z = x + y; // {5,5,5,5}
\end{cppcode}

\begin{warning}
The only issue with operator overloading concerns the hat operator \cppinline|^|. In most languages, this operator is used for exponentiation, e.g., \cppinline|4^2 == 16|. However, in C++ this value is actually \cppinline|6|, because the hat operator is the binary XOR (exclusive-or). Even worse, the hat operator in C++ does not have the same \emph{precedence} as in regular mathematics: it has a lower priority than any other mathematical operator. Both these reasons make it unwise to overload the hat operator in \phypp. In order to perform exponentiation, you will have to use a dedicated function such as \cppinline|pow(4,2)| (\ref{SEC:support:math}).
\end{warning}

\subsection{Multi-dimensional indexing \label{SEC:core:overview:multidim}}

The standard \stdvec is a purely linear container: one can access its elements using \cppinline|v[i]|, with \cppinline|i| ranging from \cppinline|0| up to \cppinline|std::vector::size()-1| (included). However, the \phypp vector allows N-dimensional indexing, i.e., using a group of indices to identify one element. For example, this is particularly useful to work on images, which are essentially 2-dimensional objects where one identifies a given pixel by its coordinates \cppinline|x| and \cppinline|y|. The natural syntax for this indexing would be to write \cppinline|img[x,y]|. This syntax is valid C++ code, but unfortunately will not do what you expect\footnote{This will call the \emph{comma} operator, which evaluates both elements \cppinline|x| and \cppinline|y| and returns the last one, i.e., \cppinline|y|. So this code actually means \cppinline|img[y]|. With proper configuration, most compiler will warn about this though, since in this context \cppinline|x| is a useless statement, so you should be safe should you make this mistake.} and there is no sane way around it. The alternative we chose here is to write instead \cppinline|img(x,y)|. While it is not as semantically clear as using brackets, it has the nice advantage of being compatible with the IDL syntax.

The multi-dimensional nature of a vector is determined at \emph{compile time}, i.e., it cannot be changed after the vector is declared. By default, a vector is mono-dimensional. To use the above feature, one needs to specify the number of needed dimensions in the type of the vector. For example, a 2D image of \cppinline|float| will be declared as \cppinline|vec2f|. These type aliases are provided for dimensions up to $6$. Here is an example of manipulation of a 2D matrix:

\begin{cppcode}
// Create a simple matrix.
vec2f m = {{1,2,3}, {4,5,6}, {7,8,9}};

// Index ordering is similar to C arrays: the last index
// is contiguous in memory. Note that this is *opposite*
// to the IDL convention.
m(0,0); // 1
m(0,1); // 2
m(1,0); // 4

// It is still possible to access elements as if in a
// "flat" vector
m[0]; // 1
m[1]; // 2
m[3]; // 4
\end{cppcode}

\begin{advanced}
If for some reason you need to use more than 6 dimensions, or if you need to declare a vector of some type which is not covered above, you can always fall back to the full template syntax:
\begin{cppcode}
// Need 12 dimensions?
using vec12f = vec_t<12,float>;
// Need 512 bit of floating point precision?
using vec3f512 = vec_t<3,mpfr::real<512>>;
\end{cppcode}

The hard limit on the number of dimensions will then depend on your compiler (each dimension involves an additional level of template recursion). The C++ standard does not guarantee anything, but you should be able to go as high as 256 on all major compilers. Beyond this, you should probably see a doctor first.

As for the types allowed inside the vector, there is no explicit restriction. However, some features may obviously not be available depending on the capabilities of your type (e.g., if your type has no \cppinline{operator*}, you will not be able to multiply together vectors of this type). Lastly, the \phypp vector shares the same restrictions as the \stdvec regarding the \emph{copyable} and \emph{movable} capabilities of the stored type.
\end{advanced}

\subsection{Vector views \label{SEC:core:overview:views}}

We have seen that, instead of accessing each element individually, we can use operator overloading to perform simple operations on all the elements of the vector at once: \cppinline|w *= 2|. We can also, like with \stdvec, modify each element individually, knowing their indices: \cppinline|w[2] *= 2|. One last important feature allowed by the \phypp vector is that one can create a \emph{view} inside a vector. Each element of the view is actually a \emph{reference} to an element in the original vector, and modifying the elements of the view actually modifies the elements in the original vector. As you will see later, views actually share most of the interface and capabilities of true vectors, so that most generic codes that work with vectors will also work with views.

\begin{cppcode}
// Create a simple vector.
vec1f w = {1,2,3,4,5,6};

// We want to "view" only the second, the third and the
// fifth elements. So we first create a vector containing
// the corresponding indices.
vec1u id = {1,2,4};

// Then we create the view.
// Note the usage of "auto" there. The type of the view is
// complex, and it is better not to worry about it.
auto v = w[id];

// Now we can modify these elements very simply, as if they
// were part of a real vector.
v;         // {2,3,5}
v *= 2;    // {4,6,10}
w;         // {1,4,6,4,10,6}
w[1] = 99; // {1,99,6,4,10,6}
v;         // {99,6,10}
\end{cppcode}

\begin{warning}
It is important to note that, since a view keeps references to the elements of the original vector, the lifetime of the view must not exceed that of the original vector. Else, it will contain \emph{dangling references}, i.e.~pointers to unused memory, and this should be avoided at all cost. In fact, views are not meant to be stored into named variables like in the above example. Most of the time, one will use them as temporary variables, e.g.:
\begin{cppcode}
vec1f w = {1,2,3,4,5,6};
vec1u id = {1,2,4};
w[id] *= 2; // {1,4,6,4,10,6}
\end{cppcode}
\end{warning}

\section{The vector class \label{SEC:core:vec}}

The full type of the vector class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec_t<Dimension,ElementType>;
\end{cppcode}

In the rest of this document, \cppinline{Dimension} will usually just be called \cppinline{D} and \cppinline{ElementType} will be shortened to \cppinline{T}.

\subsection{Member variables \label{SEC:core:vec:member_var}}

A vector only contains two member variables:
\begin{itemize}
\item \cppinline{std::vector<T> data} \\ This is the underlying \stdvec containing the elements of the vector. It is exposed to the public interface for simplicity, but on most occasions it should \emph{not} be used directly. In fact, it may become part of the private interface in the future, so you should not rely on its existence.

\begin{advanced}
Concerning \cppinline{bool} vectors. We do not use \cppinline{std::vector<bool>}, since it is a very special case of \stdvec: the C++ standard specifies that the \cppinline{bool} specialization does not store \cppinline{bool} elements, but is actually implemented like a \emph{bit field}. This is essentially to save memory: a \cppinline{bool} in C++ occupies $8$ bits of memory, like a \cppinline{char}, even though it can only carry a single bit of information. This is due to \emph{memory alignment} issues, which are inherent to the CPU architecture (the address of individual values in memory are supposed to be multiples of $8$ bits, or one byte). In a bit field however, $8$ \cppinline{bool}s are stored in a single \cppinline{char}, and bitwise operators are used to read and write individual \cppinline{bool}s. While more memory efficient, it is also slower, and involves a whole machinery to trick the user into thinking that none of this is happening. For this reason, \cppinline{bool} vectors are implemented with \cppinline{std::vector<char>} in \phypp, with one \cppinline{char} containing one \cppinline{bool}. This is completely transparent to the library user though, since \cppinline{char&} is casted into \cppinline{bool&}, and vice versa, at the boundary of the vector interface.
\end{advanced}

\item \cppinline{std::array<std::size_t,D> dims} \\ This variable contains the dimensions of this vector (useful only for multidimensional vectors). On no occasion should you modify this variable yourself: you should only read its content\footnote{This statement is actually a bit bold, but is mostly true. The only reason why this variable is made public is for optimization purposes. On occasions, it can be noticeably faster to manage manually the growth of a vector, and update the dimensions afterwards. This is often done within the core library, but should rarely be done otherwise.}. To change the dimensions of a vector, either use \cppinline{resize(...)} (\ref{SEC:core:vec:member_fun}) or assign it another vector (\ref{SEC:core:vec:constructor}).

\begin{example}
\begin{cppcode}
// Create a 2D image with 256 x 128 pixels
vec2f img(256,128);
img.dims[0]; // 256
img.dims[1]; // 128
for (std::size_t x = 0; x < img.dims[0]; ++x)
for (std::size_t y = 0; y < img.dims[1]; ++y) {
    img(x,y) = 3.1415;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Constructors and assignment \label{SEC:core:vec:constructor}}

There are various ways to construct a new vector, or assign it some value. In the following, we will cover the various \emph{constructors} and the associated \emph{assignments} when applicable.

\begin{itemize}
\item \cppinline|vec_t::vec_t(); // The default constructor|

Like \stdvec, the \phypp vector is \emph{default constructible}. By default it is in a valid state where the vector does not contain any element.

\begin{example}
\begin{cppcode}
vec1f w; // default constructor: w is empty
\end{cppcode}
\end{example}

\item \cppinline|explicit vec_t::vec_t(...); // The dimension constructor|

The \stdvec has a constructor to create a new vector of a given size. The \phypp vector also offers this feature, however it is rendered a bit more complex by the possibility of having multi-dimensional vectors. In particular, it is possible to specify the size either by giving all the dimensions one by one, or by specifying some (or all) as a \cppinline|std::array|. In all cases, the vector is populated with the number of requested elements, and all these elements are \emph{default initialized} (i.e., integers and floats are initialized to \cppinline{0}, booleans to \cppinline{false}, and \cppinline|std::string| are empty). This constructor is declared \cppinline{explicit} to prevent interference with the other constructors and assignments.

\begin{example}
\begin{cppcode}
vec1f w(10);     // w contains 10 objects all equal to 0
vec2d z(5,4);    // z contains 5*4=20 objects all equal to 0
vec2s x(z.dims); // x has the same dimensions as z
                 // but contains strings, all empty
vec3b y(z.dims, 8); // y has the same dimensions as z,
                 // plus an extra dimension of length 8
\end{cppcode}
\end{example}

\item \cppinline|vec_t::vec_t(nested_initializer_list<D,T>); // The list constructor|

Like \stdvec, the \phypp vector can be initialized from a list of values. This usually requires the usage of \cppinline|std::initializer_list<T>|, however here we also have to support multi-dimensional vectors, hence we need initializer lists of initializer lists of ..., and \cppinline|nested_initializer_list<D,T>| is just that. Note that, since C++ is a row-major language, the most nested lists correspond to the last index in a multi-dimensional vector.

\begin{example}
\begin{cppcode}
vec1f w({1,2,3}); // 1D list constructor: {1,2,3}
vec2f z({{1,2,3},{6,5,4}}); // 2D list constructor: {{1,2,3},{6,5,4}}
z(0,0); // 1
z(0,1); // 2
z(0,2); // 3

// Assignment
w = {4,5,6};
z = {{1,2}, {3,4}, {5,6}}; // dimensions can change through assignment
z(0,0); // 1
z(1,0); // 3
z(2,0); // 5
\end{cppcode}
\end{example}

\item \cppinline|vec_t::vec_t(const vec_t&); // The copy constructor|

Like \stdvec, the \phypp vector is \emph{copiable}, meaning that one can duplicate the content of an existing vector inside another vector by copy. Note that this constructor is only valid for copying vectors of the \emph{same} type. If the type is different, then another constructor is called (conversion constructor, see below).

\begin{example}
\begin{cppcode}
vec1f w = {1,2,3};
vec1f z(w); // copy constructor: {1,2,3}

// Assignment
z = w;
\end{cppcode}
\end{example}

\item \cppinline|vec_t::vec_t(vec_t&&); // The move constructor|

Like \stdvec, the \phypp vector is \emph{movable}, meaning that one can move the content of an existing vector that is going to be destroyed inside another vector. This is an optimized copy for temporary variables (C++11 move semantics). You need not explicitly ask for either the copy of the move constructor, as they will automatically be chosen by the compiler. For you, this is transparent (but the performance boost is large).

\begin{example}
\begin{cppcode}
vec1f z(vec1f{1,2,3}); // move constructor: {1,2,3}
// Here, a temporary vector is created with vec1f{1,2,3}.
// This temporary vector is then *moved* inside z.

// Assignment
z = vec1f{4,5,6};
\end{cppcode}
\end{example}

\item \cppinline|vec_t::vec_t(const vec_t<D,OtherT>&); // The conversion constructor|

C++ supports implicit conversion between all the build in types. In particular, it is possible to write:
\begin{cppcode}
int i = 0;
float f = i; // int to float
bool b1 = i; // int to bool, mostly for interoperability with C
bool b2 = f; // float to bool, not sure if that makes sense...
\end{cppcode}
While this is very convenient in most cases, it can also lead to dangerous silent conversions, such as the \cppinline{float} to \cppinline{bool} conversion. This is, somehow, a legacy of C. In \phypp we decided to also support such implicit conversions. They make the code much easier to read, but the price to pay is that sometimes we do some conversions which are not necessary, and we do not realize it because they are implicit. However, we decided to disable implicit conversion to and from \cppinline{bool} vectors, since it could lead to subtle bugs that are difficult to trace. It is sill possible to do the conversion to \cppinline{bool} using explicit

\begin{example}
\begin{cppcode}
vec1i w = {1,2,0};
vec1f z(w); // int to float {1,2,0}
vec1b y(w); // error: cannot convert int to bool
vec1s x(w); // error: cannot convert int to std::string

vec1b b = {true,true,false};
vec1i s(b); // bool to int {1,1,0}

// Assignment
z = w;
y = w;        // error: cannot convert int to bool
x = w;        // error: cannot convert int to std::string

s = b;        // error: implicit conversion is not allowed for bool
s = vec1i(b); // ok: bool to int {1,1,0}
\end{cppcode}
\end{example}

\item \cppinline|vec_t::vec_t(const vec_t<D,T*>&); // The view constructor|

The last constructor on the list is the view constructor. It allows implicit conversion of a view (\ref{SEC:core:view}) into a new, independent vector.

\begin{example}
\begin{cppcode}
vec1i w = {1,2,3};
vec1u id = {0,1};
vec1i z(w[id]); // {1,2}

// Assignment
z = w[id];
\end{cppcode}
\end{example}

\end{itemize}

\subsection{Member functions \label{SEC:core:vec:member_fun}}

\begin{itemize}
\item \cppinline{bool vec_t::empty() const}

This function will return \cppinline{true} if this vector contains at least one element, and \cppinline{false} otherwise. In particular, \cppinline{true} will be returned for default constructed vectors, and after a call to \cppinline{vec_t::clear()}.

\begin{example}
\begin{cppcode}
vec1i v;
v.empty(); // true
vec1i w = {1,2,3};
w.empty(); // false
\end{cppcode}
\end{example}

\item \cppinline{std::size_t vec_t::size() const}

This function will return the total number of elements in this vector. If the vector is empty, then the function returns \cppinline{0}. If the vector is multidimensional, then the function returns the product of all the dimensions.

\begin{example}
\begin{cppcode}
vec1i v;
v.size(); // 0
vec1i w = {1,2,3};
w.size(); // 3
vec2i z = {{1,2,3}, {4,5,6}};
z.size(); // 6
\end{cppcode}
\end{example}

\item \cppinline{void vec_t::resize(...)}

This function can be used to explicitly change the size of a vector. The parameters it accepts are the same as the dimension constructor (\ref{SEC:core:vec:constructor}), i.e., either integral values for individual dimensions, or an \cppinline{std::array} containing multiple dimensions, or any combination of these. However, the total number of dimensions of the vector must remain unchanged.

After the vector has been resized, its content will have changed. For a monodimensional vector, if the resize operation \emph{decreased} the total number of elements, then the last elements will be erased, but the other ones will remain untouched. On the other hand, if the resize operation \emph{increased} the total number of elements, all the previous elements are unchanged, and new elements are inserted at the end of the vector, default constructed (i.e., zeroes for integral types, etc.). For a multidimensional vector, its content is left in an \emph{undefined state}, and can be assumed to be destroyed\footnote{This is just out of laziness. In the future, this will probably be specified to behave like the monodimensional vector. The issue is that it involves non-trivial reshuffling of the elements to preserve the original structure after the dimensions have changed. I have not needed this feature so far.}.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.resize(5); // {1,2,3,0,0}
v.resize(2); // {1,2}
v.resize(3); // {1,2,0}

vec2f w = {{1,2},{2,3}};
w.resize(2,3); // w has been resized, but its content is unspecified
w(0,0); // ?
\end{cppcode}
\end{example}

\item \cppinline{void vec_t::clear()}

This function removes all elements from the vector, and sets all dimensions to zero.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.clear(); // v is now empty
v.empty(); // true
v.size();  // 0
v.dims;    // {0}
\end{cppcode}
\end{example}

\item \cppinline{T& vec_t::back()}

This function is only available for monodimensional vectors. It returns the last element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.back(); // 3
v.back() == v[v.size()-1]; // always true
\end{cppcode}
\end{example}

\item \cppinline{T& vec_t::front()}

This function is only available for monodimensional vectors. It returns the first element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.front(); // 1
v.front() == v[0]; // always true
\end{cppcode}
\end{example}

\item \cppinline{void vec_t::push_back(...)}

The behavior of this function is different for monodimensional and multidimensional vectors. For monodimensional vectors, this function appends a new element at the end of the vector, and therefore takes for argument a single value of type \cppinline{T} (or convertible to \cppinline{T}). For multidimensional vectors, this function takes for argument another vector of \cppinline{D-1} dimensions, and whose lengths match the \emph{last} \cppinline{D-1} dimensions of the first vector. This new vector is inserted after the existing elements, and the first dimension of the first vector is increased by one.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.push_back(4); // {1,2,3,4}

vec2i w = {{1,2,3}, {4,5,6}};
w.push_back({7,8,9}); // {{1,2,3}, {4,5,6}, {7,8,9}}
w.push_back({7,8});   // error: dimensions do not match, 2 != 3
\end{cppcode}
\end{example}

\item \cppinline{void vec_t::reserve(std::size_t)}

This function is used for optimization, and is similar to \cppinline{std::vector::reserve()} (actually, this function is called internally). To understand what this function actually does, one needs to know the internal behavior of \stdvec. By default, the \stdvec only allocates enough memory to hold a few elements. Once the allocated memory is full, \stdvec allocates a larger amount of memory, copies the existing elements inside this new memory, and frees the old memory. This strategy allows virtually unlimited growth of a given vector, and is quite efficiently tuned. However, it is still an expensive operation, and performances can be greatly improved if one knows \emph{in advance} the total number of objects that need to be stored in the vector, so that the right amount of memory is allocated from the beginning, and no copy is required. This function does just that, it tells \stdvec how many elements it \emph{will} (or might) contain at some point, so that the vector can already allocate enough memory. This is also useful if you only have a rough idea of the future number of elements.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,...};

// Let's imagine you have an algorithm that will produce an
// unknown number of values, but you know that on average
// it is close to N*N.
vec1i w;
// Reserve roughly enough memory in advance
w.reserve(v.size()*v.size());

// Now the algorithm will run close to the optimal memory
// efficiency
for (...) {
    w.push_back(...);
}
\end{cppcode}
\end{example}

\item \cppinline{uint_t vec_t::pitch(uint_t) const}

This is only useful for multidimensional vectors. This function returns the ``pitch'' factor associated to a given dimension. This factor is number of elements in memory that separate two consecutive indices of this dimension. By definition, the pitch factor is \cppinline{1} for the last dimension. For the other dimensions, this is the product of all the other dimensions located between the one considered and the last dimension.

\begin{example}
\begin{cppcode}
vec3f v(5,8,6);
v.pitch(2); // 1
v.pitch(1); // 6 = v.dims[2]
v.pitch(0); // 48 = v.dims[2]*v.dims[1]
\end{cppcode}
\end{example}

\item \cppinline{bool vec_t::is_same(const vec_t<D,T>&) const}

This function tests if the provided vector is a view inside this vector.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
vec1f w = {1,2,3};
vec1u id = {1,2};
v.is_same(v[id]); // true
v.is_same(w[id]); // false
\end{cppcode}
\end{example}

\item \cppinline{const vec_t& vec_t::concretize() const}

This function just returns a reference to this vector, and is only present to mirror the interface of the view class.

\item \cppinline{iterator vec_t::begin()} and \cppinline{iterator vec_t::end()}

These functions allow iteration over the values of this vector. The only reason one may use these functions explicitly is when using algorithms from the standard C++ library, which often work on a pair of iterators as returned by \cppinline{begin()} and \cppinline{end()}.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
// The presence of these functions allow to use vectors
// in range-based loops
for (float& f : v) {
    f += 1;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Indexing \label{SEC:core:vec:indexing}}

There are two ways to index a given vector, for both mono- and multidimensional vectors. The first way is through ``flat'' indices and the bracket indexing \cppinline{v[i]}, i.e., a single index that runs contiguously in memory, and the second way is through multidimensional indices and parenthesis indexing \cppinline{v(i)} (\ref{SEC:core:overview:multidim}). For monodimensional vectors, these two methods are perfectly identical.

Flat indexing does not care about the details of the dimensions of a given vector. The only important thing is the total number of elements in the vector. This is the simplest and fastest\footnote{Actually there is a faster way using the \cppinline{safe} wrapper, which does not do bounds checking. See the ``Advanced'' note at the end of this section.} way to access the data inside a vector.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.size(); ++i) {
    // Here we traverse the vector v regardless of its dimensions
    v[i] = 12.0 + i*i - sqrt(5.0*i) + v[i/4];
}
\end{cppcode}
\end{example}

Multidimensional indexing is more involved computationally, because it implies some index arithmetic to compute the flat index and find the right place to read in memory. However it is much more expressive and easier to read and understand. Furthermore, except for very critical code sections, the performance gap is usually negligible, as long as you iterate over the dimensions properly, i.e., following the example below, that you do the \emph{last} nested loop to iterate on the \emph{last} index. This will guarantee as much memory locality as possible, and will take best advantage of CPU caches.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.dims[0]; ++i)
for (std::size_t j = 0; j < v.dims[1]; ++j)
for (std::size_t k = 0; k < v.dims[2]; ++k) {
    // Here we traverse the vector v keeping its dimensional structure
    v(i,j,k) = 42.0 + i + j + k/(j+1);
}
\end{cppcode}
\end{example}

Indexing a vector can only be done with integers, e.g., \cppinline{int}, \cppinline{unsigned int}, \cppinline{int_t}, \cppinline{uint_t}, \cppinline{std::size_t}, etc. Indexing with \emph{unsigned} integers is faster because it removes the need to check for the positivity of the index, and should therefore be preferred when possible. Negative indices are allowed though, and they are interpreted as \emph{reverse} indices, where \cppinline{-1} refers to the last element of the vector, \cppinline{-2} the one before the last, etc.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v[0];    // 1, int index
v[0u];   // 1, unsigned int index (faster, but more cumbersome)
vec[-1]; // 4, int index
vec[-2]; // 3, int index
vec[-1] == vec[vec.size()-1]; // always true

v[0.1]; // error: can only access using integers
\end{cppcode}
\end{example}

As discussed in the overview (\ref{SEC:core:overview:views}), one can also use  vector to index another one. This is called array indexing, by opposition to the scalar indexing we have seen just above. Similarly to scalar indexing, array indexing is only allowed by using integers, i.e., \cppinline{vec1u}, \cppinline{vec1i} and their multidimensional counterparts. Again, unsigned integers should be preferred when possible.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,2,3};
v[id]; // 1,3,4
\end{cppcode}
\end{example}

Sometimes, one will want to use array indexing to access all the elements at once, for example to set all the elements of a vector to a specific value. This can be done with a loop, of course, but it can be boring to write. To do so without explicitly writing the loop, one typically has to create first an index vector containing all the indices of the target vector, and then apply the operation:

\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,1,2,3}; // all the indices of v
v[id] = 12;

// Note that the following will not work
v = 12; // now v only contains a single element equal to 12
\end{cppcode}

Not only is this not very practical to write, it is error prone and not very clear. If we decide to add an element to \cppinline{v}, we also have to modify \cppinline{id}. Not only this, but it will most likely be slower than writing the loop directly, because the compiler may not realize that you are accessing all the elements contiguously, and will fail to optimize it properly. For this reason, we also introduce the ``placeholder'' symbol, defined as a single underscore \cppinline{_}. When used as an index, it means ``all the indices in the range''. Coming back to our example:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_] = 12; // it cannot get much shorter
\end{cppcode}

This placeholder index can be used in all situations, with both flat and multidimensional indexing. It can be further refined to only encompass a fraction of the whole range, using a peculiar syntax\footnote{Be warned that this feature has been introduced recently and may not survive in the future.}:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_-2] = 12;   // only access the indices 0 to 2
v[2-_] = 12;   // only access the indices 2 to 3
v[1-_-2] = 12; // only access the indices 1 to 2
\end{cppcode}

Except for the special case of the placeholder index \cppinline{_}, all the indexing methods described above perform \emph{bound checks} before accessing each element. In other words, the vector class makes sure that each index is smaller than either the total size of the vector (for flat indices) or the length of its corresponding dimension (for multidimensional indices). If this condition is not satisfied, an assertion is raised explaining the problem, and the program is stopped immediately to prevent memory corruption.

\begin{advanced}
This bound checking has a small but noticeable impact on performances. In most cases, the added security is definitely worth it. Indeed, accessing a vector with an out of bounds index has very unpredictable impacts on the behavior of the program: sometimes it will crash, but most of the time it will not. Memory will be silently corrupted, the problem will be hard to notice, but the consequences can be terrible... Then, identifying the root of the problem to fix it may prove even more challenging. This is why bound checking is enabled by default.

However, there are cases where bound checking is superfluous, for example if we already know \emph{by construction} that the indices we are dealing with will always be valid. Sometimes the compiler may realize that and optimize the checks away, but one should not rely on it. If these situations are computation-limited, i.e., a lot of time is spent doing some number crushing for each element, then the performance hit of bound checking will be negligible, and one should not worry about it. On the other hand, if very little work is done per element, then most of the time will be spent iterating from one index to the next and loading the value in the CPU cache, and bound checking can take a significant amount of the total time.

For this reason, the \phypp vector also offers an alternative indexing interface, the \emph{safe} interface, that behaves exactly like the standard interface described above, except that it does not perform bound checking. One may access it using \cppinline{v.safe[i]} for flat indexing, or \cppinline{v.safe(x,y)} for multidimensional indexing, and it can also be used to create views. This interface is not meant to be used in daily coding, but rather for computationally intensive functions that you write once but use many times.
\end{advanced}

\subsection{Operators \label{SEC:core:vec:operator}}

The set of available operators depend on the type of the elements contained in the vector.

\begin{itemize}
\item For arithmetic types (\cppinline{int}, \cppinline{unsigned int}, \cppinline{float} and \cppinline{double}): addition (\cppinline{+}), subtraction (\cppinline{-}), multiplication (\cppinline{*}), division (\cppinline{/}) and (integer types only) modulo (\cppinline{%}).

\item For \cppinline{bool}: and (\cppinline{&&}), or (\cppinline{||}) and negation (\cppinline{!}).

\item For \cppinline{std::string}: concatenation (\cppinline{+}).

\item For all types: less than (\cppinline{<}), less than or equal (\cppinline{<=}), greater than (\cppinline{>}), greather than or equal (\cppinline{>=}), equal (\cppinline{==}) and not equal (\cppinline{!=}).
\end{itemize}

In all cases, the operator overloading allows mixing together vectors of different types (as long as they are convertible one to another) and scalar values.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v + 2; // {3,4,5,6}
v + v; // {2,4,6,8}

vec1s fruits = {"apple", "orange"};
"I ate an "+fruits; // {"I ate an apple", "I ate an orange"}
2+fruits;           // error: no operator found for int + std::string
\end{cppcode}
\end{example}

\section{The view class \label{SEC:core:view}}

The full type of the view class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec_t<Dimension,ElementType*>;
//              note the asterisk ^
\end{cppcode}

The public interface of the view class is very similar to that of the normal vector, and we will not repeat it here. There are some important differences though, which are inherent to the goal of this class. In particular, there is no available constructor (you do now create a view yourself, you ask for it from an existing vector that will create it for you), and the \cppinline|resize()| function is not available. Lastly, the view implements \cppinline|concretize()|, differently.

Thanks to their strong similarity, we will not distinguish in the other sections between vectors and views, and will consider views as just another kind of vectors. Indeed, the interface of these two classes has been designed for views to be completely interchangeable with vectors, and vice versa, so that the code of any given function is generally written once and is valid for both types.

\subsection{Member functions \label{SEC:core:view:member_fun}}

\begin{itemize}
\item \cppinline|vec_t<D,T> vec_t<D,T*>::concretize() const|

This function creates a new vector out of the elements of this view. The returned vector is completely independent from this view, or the original vector this view is currently pointing to. This function is mostly useful when writing generic functions. Indeed, views are implicitly convertible to normal vectors on assignment (\ref{SEC:core:vec:constructor}).
\end{itemize}

\section{Metaprogramming traits and functions (WIP) \label{SEC:core:meta}}

\begin{warning}
This whole section is more advanced than the rest. It is describing the sets of helper types and metaprogramming functions that one can use to write new functions. It is intended to be followed by readers already familiar with the \phypp library, and with good knowledge of C++ metaprogramming.
\end{warning}


% Functions:

% n_elements

% dim

% element
% first
% last

\chapter{Support libraries \label{SEC:support}}

In this chapter we describe the set of helper functions that are part of the \phypp support library. These functions are not essential to the use of the \phypp library, but are mostly modular components that one may choose to use or not. All the support functions are sorted into broad categories to help you discover new functions and algorithm. Alternatively, if you know the name of a function and would like to read its documentation, an index is available at the end of this document.

Note that, in all this section, the signature of the functions is given in pseudo-code, both for conciseness and readability. In particular, the following rules apply.

\begin{itemize}
\item The presence of the \vectorfuncsym symbol in front of the signature of the function means that this function is also available in a \emph{vectorized} form. This only applies to functions whose first argument is a scalar (i.e., not a vector). In this case, the vectorized form shares the same signature as the original form, but the first argument is promoted to a vector. Calling the vectorized version is the same as writing a loop to call the original version on each element of the vector. If the original function had a return value, the vectorized form returns a vector whose elements are the return value of each call, corresponding to each element of the input vector. The vectorized version can be faster than writing the loop manually.

\begin{example}
\begin{cppcode}
// Suppose this function is marked as vectorized
bool is_odd(uint_t)
// It means that there is another function with the
// same name, but that acts on a vector instead
vec_t<D,bool> is_odd(vec_t<D,uint_t>)

// It is used like this
vec1u v = {1,2,3,4,5};
vec1b b = is_odd(v);
// ... and is equivalent to
vec1b b(v.dims);
for (uint_t i : range(v)) {
    b[i] = is_odd(v[i]);
}
\end{cppcode}
\end{example}

\item If the function depends on an external library, the name of this library will be written before the signature, for example if LAPACK is needed you will find the symbol \lapacksym.

\item Template parameters are not declared explicitly. They are always written in uppercase, usually with a single character (e.g., \cppinline{T}, \cppinline{D}), or possibly two (e.g., a letter and a number), but never more. Letters \cppinline{T} and \cppinline{U} refer to template \emph{types}, while letters \cppinline{D}, \cppinline{N} or \cppinline{I} refer to template \emph{integers}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void foo(T)
// Corresponding C++ code
template<typename T>
void foo(T);

// Pseudo-code used in this section
void foo(vec_t<D,T> v, U u)
// Corresponding C++ code
template<std::size_t D, typename T, typename U>
void foo(vec_t<D,T> v, U u);
\end{cppcode}
\end{example}

\item Template parameters are omitted when not relevant to the description of the function. In this case, it is implicitly assumed that the function will work for any type/value of these template parameters.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void sort(vec_t&)
// Corresponding C++ code
template<std::size_t D, typename T>
void sort(vec_t<D,T>&);
\end{cppcode}
\end{example}

\item There are only two kinds of arguments: input arguments, and input/output arguments. Input arguments are always spelled as plain types, e.g. \cppinline{T}, even if the actual signature of the function uses a constant reference, an r-value reference or a universal reference. The reason is that this implementation choice does not matter to the end user. What matters is the interface. The input/output parameters are always C++ references, e.g. \cppinline{T&}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
vec1u dims(vec_t)
// Corresponding C++ code could be either
template<std::size_t D, typename T>
vec1u dims(vec_t<D,T>);
// ... or
template<std::size_t D, typename T>
vec1u dims(const vec_t<D,T>&);
// The only difference is that the first version will
// always make a copy (or move) of its parameter, while
// the second may not. This optimization choice depends
// on the actual code inside the function, and has no
// consequence on how the function is actually used.
\end{cppcode}
\end{example}

\item The ellipsis \cppinline{...} is used to symbolize a list of multiple arguments whose length can vary depending on the context. These arguments are not spelled out explicitly, but the description of the function must make it clear what they are used for. Optionally, a type may be placed before the ellipsis to indicate that all the arguments must be of this same type.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t flat_id(vec_t, ...)
// Corresponding C++ code
template<std::size_t D, typename T, typename ... Args>
uint_t flat_id(vec_t<D,T>, Args&& ...);
\end{cppcode}
\end{example}

\item The \cppinline{std} namespace is omitted for common standard types, like \cppinline{std::string} or \cppinline{std::array}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t length(string)
// Corresponding C++ code
uint_t length(const std::string&);
\end{cppcode}
\end{example}

\item For the particular case of \cppinline{std::array}, the individual elements inside the array can be named by placing the names inside curly braces after the type of the array.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t distance(array {x,y})
// Corresponding C++ code
template<typename T>
uint_t length(const std::array<T,2>& a) {
    // x := a[0]
    // y := a[1]
}
\end{cppcode}
\end{example}

\item If the return type of a function in pseudo-code is \cppinline{auto}, it means that this return value is ``complex'' (usually a structure or a class) and it is not important to know its precise type. The description of the function must therefore make it clear how this return value can be used.

\end{itemize}

With this in mind, it is clear that this chapter focuses on the \emph{interface} that is provided by the library, rather than on the individual function themselves. In fact, a single interface may be composed of many different functions to take care of all the combination of types that the interface supports. If the reader is interested in all these overloads, or is experiencing a particular compiler error that cannot be easily fixed just by looking at the interface, then it is best to look directly into the code of the library. Although less readable than the pseudo-code used in this document, most of the time an effort is made to make the code as clear as possible. However, if a function is too hard to understand, I consider this as a bug that should be reported on the \texttt{github} issue tracker (seriously). Similarly, if you end up doing something wrong with the library, but that the compiler error message is too cryptic or too long, you may also fill in a bug report. Ensuring that clear error messages are sent to the user is a shared responsibility between compiler writers and library authors.

\section{Generic vector functions \label{SEC:support:generic}}

The vector and view classes are useful and complete tools. However, there are a number of tasks that one repeatedly need to do, like generating a sequence of indices, or sorting a vector, and that would be tedious to write each time they are needed. For this reason, the \phypp library comes with a large set of utility functions to sort, rearrange, and select data inside vectors. In this section we list these functions and algorithms.

This support library also introduces a global constant called \cppinline{npos}\itt{npos}. This is an unsigned integer whose value is the largest possible integer that the \cppinline{uint_t} type can hold. It is meant to be used as an error value, or the value to return if no normal value would make sense. It is very similar in concept to the \cppinline{std::string::npos} provided by the C++ standard library. In particular, it is worth noting that converting \cppinline{npos} to a \emph{signed} integer produces the value \cppinline{-1}.

We now describe the functions provided by this library, sorted by categories.

\subsection{Range-based iteration}

\begin{itemize}
\item \cppinline{auto range(vec_t v)} \itt{range}

\cppinline{auto range(uint_t n)}

\cppinline{auto range(uint_t i0, uint_t n)}

This function returns a C++ \emph{range}, i.e., an object that can be used inside the C++ range-based \cppinline{for} loop. This range will generate integer values starting from \cppinline{0} (first and second version) or \cppinline{i0} (third version) to \cppinline{v.size()} (first version) or \cppinline{n} (second and third versions), that last value being \emph{excluded} from the range. This nice way of writing an integer \cppinline{for} loop actually runs as fast as (if not faster than) the classical way, and is less error prone.

\begin{example}
\begin{cppcode}
vec1i v = {4,5,6,8};

// First version
for (uint_t i : range(v)) {
    // 'i' goes from 0 to 3
    v[i] = ...;
}

// Note that the loop above generates
// *indices* inside the vector, while:
for (int i : v) { /* ... */ }
// ... generates *values* from the vector.

// Second version
for (uint_t i : range(3)) {
    // 'i' goes from 0 to 2
    v[i] = ...;
}

// Third version
for (uint_t i : range(1,3)) {
    // 'i' goes from 1 to 3
    v[i] = ...;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Index manipulation}

\begin{itemize}
\item \cppinline{vec1u mult_ids(vec_t v, uint_t i)} \itt{mult_ids}

This is only useful for multidimensional vectors. This function converts a ``flat'' index \cppinline{i} (\ref{SEC:core:vec:indexing}) into an array of multidimensional indices, following the dimensions of the provided vector \cppinline{v}. The \cppinline{flat_id} function does the inverse job.

\begin{example}
\begin{cppcode}
vec2i v(2,3);
mult_ids(v,0); // {0,0}
mult_ids(v,1); // {0,1}
mult_ids(v,2); // {0,3}
mult_ids(v,3); // {1,0}
v[3] == v(1,0); // true
\end{cppcode}
\end{example}

\item \cppinline{uint_t flat_id(vec_t v, ...)} \itt{flat_id}

This is only useful for multidimensional vectors. This function converts a group of multidimensional indices into a ``flat'' index (\ref{SEC:core:vec:indexing}), following the dimensions of the provided vector \cppinline{v}. The \cppinline{mult_ids} function does the inverse job.

\begin{example}
\begin{cppcode}
vec2i v(2,3);
flat_id(v,0,0); // 0
flat_id(v,0,1); // 1
flat_id(v,0,2); // 2
flat_id(v,1,0); // 3
v(1,0) == v[3]; // true
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Integer sequences}

\begin{itemize}
\item \cppinline|vec_t<D,int_t>  indgen(...)| \itt{indgen}

\cppinline|vec_t<D,uint_t> uindgen(...)| \itt{uindgen}

\cppinline|vec_t<D,float>  findgen(...)| \itt{findgen}

\cppinline|vec_t<D,double> dindgen(...)| \itt{dindgen}

These functions will create a new vector, whose dimensions are specified in argument (like in the dimension constructor, \ref{SEC:core:vec:constructor}, or \cppinline{vec_t::resize()}, \ref{SEC:core:vec:member_fun}). After this vector is created, the function will fill it with values that start at \cppinline{0} and increment by steps of \cppinline{1} until the end of the vector.

\begin{example}
\begin{cppcode}
vec1i v = indgen(5);    // {0,1,2,3,4}
vec2u w = uindgen(3,2); // {{0,1}, {2,3}, {4,5}}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Rearranging elements}

\begin{itemize}
\item \cppinline|vec1u sort(vec_t)| \itt{sort}

\cppinline|void inplace_sort(vec_t&)| \itt{inplace_sort}

These functions will change the order of the elements inside a given vector so that they are sorted from the smallest to the largest. The difference between the two versions is that \cppinline{sort} does not actually modify the provided vector, but rather returns a vector containing indices inside the provided vector, and \cppinline{inplace_sort} directly modifies the provided vector. The later is the fastest of the two, but it is less powerful.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {1,5,6,3,7};
vec1u id = sort(v); // {0,3,1,2,4}
v[id]; // {1,3,5,6,7} is sorted
// now, id can also be used to modify the order of
// another vector of the same dimensions

// Second version
inplace_sort(v);
v; // {1,3,5,6,7} is sorted
\end{cppcode}
\end{example}

\item \cppinline|bool is_sorted(vec_t)| \itt{is_sorted}

This function just traverses the whole input vector and checks if its elements are sorted by increasing value.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {1,5,6,3,7};
is_sorted(v); // false
inplace_sort(v);
v; // {1,3,5,6,7}
is_sorted(v); // true
\end{cppcode}
\end{example}

\item \cppinline|vec_t<1,T> reverse(vec_t<1,T>)| \itt{reverse}

This function will inverse the order of all the elements inside the provided vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5,6};
vec1i w = reverse(v); // {6,5,4,3,2,1}
\end{cppcode}
\end{example}

\item \cppinline|vec_t<1,T> shift(vec_t<1,T> v, int_t n, T d = 0)| \itt{shift}

This function will shift the position of the elements inside the provided vector \cppinline{v} by a given amount of indices \cppinline{n}. Elements that would go outside of the bounds of the vector are destroyed. New elements are inserted and default constructed, or assigned the default value \cppinline{d} (optional argument).

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5};
vec1i sr = shift(v, 2);
sr; // {0,0,1,2,3}
vec1i sl = shift(v, -2, 99);
sl; // {3,4,5,99,99};
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Finding elements}

\begin{itemize}
\item \cppinline|vec1u where(vec_t<D,bool>)| \itt{where}

This function will scan the \cppinline{bool} vector provided in argument, will store the flat indices (\ref{SEC:core:vec:indexing}) of each element which is \cppinline{true}, and will return all these indices in a vector. This is a very useful tool to filter and selectively modify vectors, and probably one of the most used function of the whole library.

\begin{example}
\begin{cppcode}
vec1i v = {4,8,6,7,5,2,3,9,0};
// We want to select all the elements which are greater than 3
// We use where() to get their indices
vec1u id = where(v > 3); // {0,1,2,3,4,7}
// Now we can check
v[id]; // {4,8,6,7,5,9}, good!

// The argument of where() can by as complex as you want
id = where(v < 3 || (v > 3 && v % 6 < 2)); // now guess

// It can also involve multiple vectors, as long as they have
// the same dimensions
vec1i w = {9,8,6,1,-2,0,8,5,1};
id = where(v > w || (v + w) % 5 == 0);
// The returned indices are valid for both v and w
v[id]; // {8,6,7,5,2,9}
w[id]; // {8,6,1,-2,0,5}
\end{cppcode}
\end{example}

\item \cppinline|vec1u complement(vec_t v, vec1u id)| \itt{complement}

This function works in tandem with \cppinline{where}. Given a vector \cppinline{v} and a set of flat indices \cppinline{id} (\ref{SEC:core:vec:indexing}), it will return the complementary set of indices inside this vector, i.e., all the indices of \cppinline{v} that are \emph{not} present in \cppinline{id}.

\begin{example}
\begin{cppcode}
vec1i v = {1,5,6,3,7};
vec1u id = where(v > 4); // {1,2,4}
vec1u cid = complement(v, id); // {0,3}
\end{cppcode}
\end{example}

\item \cppinline|uint_t lower_bound(T x, vec_t v)| \itt{lower_bound}

\cppinline|uint_t upper_bound(T x, vec_t v)| \itt{upper_bound}

\cppinline|array<uint_t,2> bounds(T x, vec_t v)| \itt{bounds}

\cppinline|array<uint_t,2> bounds(T x1, U x2, vec_t v)|

These functions use a binary search algorithm to locate the element in the input vector \cppinline{v} that is equal to or closest to the provided value \cppinline{x}. It is important to note that the binary search assumes that the elements in the input vector are \emph{sorted} by increasing value. This algorithm also assumes that the input vector does not contain any NaN value (\ref{SEC:support:math}).

The \cppinline{lower_bound} function locates the last element in \cppinline{v} that is less or equal to \cppinline{x}. If no such element is found, \cppinline{npos} is returned.

The \cppinline{upper_bound} function locates the first element in \cppinline{v} that is greater than \cppinline{x}. If no such element is found, \cppinline{npos} is returned.

The first \cppinline{bounds} function combines what both \cppinline{lower_bound} and \cppinline{upper_bound} do, and returns both indices in an array. The second \cppinline{bounds} function calls \cppinline{lower_bound} to look for \cppinline{x1}, and \cppinline{upper_bound} to look for \cppinline{x2}.

\begin{example}
\begin{cppcode}
vec1i v = {2,5,9,12,50};
bounds(0, v);   // {npos,0}
bounds(9, v);   // {2,3}
bounds(100, v); // {4,npos}
\end{cppcode}
\end{example}

\item \cppinline|vec1u equal_range(T x, vec_t v)| \itt{equal_range}

Similarly to \cppinline{lower_bound}, \cppinline{upper_bound} and \cppinline{bounds}, this function uses a binary search algorithm to locate all the values in the input vector \cppinline{v} that are equal to \cppinline{x}. It then returns the flat indices of all these values in a vector. It is important to note that the binary search assumes that the elements in the input vector are \emph{sorted} by increasing value. This algorithm also assumes that the input vector does not contain any NaN value (\ref{SEC:support:math}).

If no such value is found, an empty vector is returned.

\begin{example}
\begin{cppcode}
vec1i v = {2,2,5,9,9,9,12,50};
equal_range(9, v); // {3,4,5}

// It's a faster version of
where(v == 9);
\end{cppcode}
\end{example}

\item \cppinline|vec1u uniq(vec_t v)| \itt{uniq}

\cppinline|vec1u uniq(vec_t v, vec1u sid)|

This function will traverse the provided vector \cppinline{v} and find all the unique values. It will store the indices of these values (if a value is present more than once inside \cppinline{v}, the index of the first one will be used) and return them inside an index vector. The first version assumes that the values in \cppinline{v} are \emph{sorted} from the smallest to the largest. In the second version, \cppinline{v} may not be sorted, but the second argument \cppinline{id} contains indices that will sort \cppinline{v} (e.g., \cppinline{id} can be the return value of \cppinline{sort(v)}).

\begin{example}
\begin{cppcode}
// For a sorted vector
vec1i v = {1,1,2,5,5,6,9,9,10};
vec1u u = uniq(v); // {0,2,3,5,6,8}
v[u]; // {1,2,5,6,9,10} only unique values

// For an non-sorted vector
vec1i w = {5,6,7,8,6,5,4,1,2,5};
vec1u u = uniq(w, sort(w));
w[u]; // {1,2,4,5,6,7,8}
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|bool is_any_of(T1 v1, vec_t<D2,T2> v2)| \itt{is_any_of}

This function looks if there is any value inside \cppinline{v2} that is equal to \cppinline{v1}. If so, it returns \cppinline{true}, else it returns \cppinline{false}.

\begin{example}
\begin{cppcode}
vec1i v = {7,4,2,1,6};
vec1i d = {5,6,7};
vec1b b = is_any_of(v, d); // {true, false, false, false, true}
\end{cppcode}
\end{example}

\item \cppinline|void match(vec_t v1, vec_t v2, vec1u& id1, vec1u& id2)| \itt{match}

This function traverses \cppinline{v1} and, for each value in \cppinline{v1}, looks for elements in \cppinline{v2} that have the same value. If one is found, the flat index of the element of \cppinline{v1} is added to \cppinline{id1}, and the flat index of the element of \cppinline{v2} is added to \cppinline{id2}. Then the function goes on to the next value in \cppinline{v1}. Note that, contrary to \cppinline{match_dictionary}, each value in \cppinline{v1} is matched to \emph{at most} one value in \cppinline{v2}, and vice versa. In other words, if \cppinline{v1} or \cppinline{v2} contain duplicates, only the first value will be matched and the others will be ignored. This function is symmetric: the result will be the same if you swap the two input vectors (of course, the output vectors have to be swapped also).

\begin{example}
\begin{cppcode}
vec1i v = {7,4,2,1,6};
vec1i w = {2,6,5,3};
vec1u id1, id2;
match(v, w, id1, id2);
id1; // {2,4}
id2; // {0,1}
v[id1] == w[id2]; // always true
\end{cppcode}
\end{example}

\item \cppinline|void match_dictionary(vec_t v1, vec_t v2, vec1u& id1, vec1u& id2)| \itt{match_dictionary}

This function traverses \cppinline{v1} and, for each value in \cppinline{v1}, looks for an element in \cppinline{v2} that has the same value. If one is found, the flat index of the element of \cppinline{v1} is added to \cppinline{id1}, and the flat index of the element of \cppinline{v2} is added to \cppinline{id2}. Then the function goes on to the next value in \cppinline{v1}. Contrary to \cppinline{match}, each value in \cppinline{v2} can be matched to multiple values in \cppinline{v1}. Therefore this function is not symmetric: the second vector should be considered as a ``dictionary'', hence the name of this function. It is assumed that \cppinline{v2} does not contain any duplicates.

\begin{example}
\begin{cppcode}
vec1i v = {7,6,2,1,6};
vec1i w = {2,6,5,3};
vec1u id1, id2;
match_dictionary(v, w, id1, id2);
id1; // {1,2,4}
id2; // {1,0,1}
v[id1] == w[id2]; // always true
\end{cppcode}
\end{example}

\item \cppinline|bool astar_find(vec2b m, uint_t& x, y)| \itt{astar_find}

This function uses the $A^\star$ (``A star'') algorithm to look inside a 2D boolean map \cppinline{m} and, starting from the position \cppinline{x} and \cppinline{y} (i.e. \cppinline{m(x,y)}), find the closest point that has a value of \cppinline{true}. Once this position is found, its indices are stored inside \cppinline{x} and \cppinline{y}, and the function returns \cppinline{true}. If no element inside \cppinline{m} is \cppinline{true}, then the function returns \cppinline{false}.

\begin{example}
\begin{cppcode}
// Using '@' for true and '.' for false,
// assume we have the following boolean map,
// and that we start at the position indicated
// by 'S', the closest point whose coordinates
// will be returned by astar_find is indicated
// by an 'X'
vec2b m;
// .................
// .................
// .................
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@X.........
// .............S...
// .................
// .................

uint_t x = 13, y = 2;
astar_find(m, x, y);
x; // 7
y; // 3
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Modifying dimensions}

\begin{itemize}
\item \cppinline|vec_t<1,T> flatten(vec_t<D,T>)| \itt{flatten}

This function transforms a multidimensional vector into a monodimensional vector. The content in memory is exactly the same, so the operation is fast. In particular, if the argument of this function is a temporary, this function is extremely cheap as it produces no copy. The \cppinline{reform} function does the inverse job, and more.

\begin{example}
\begin{cppcode}
vec2i v = {{1,2,3}, {4,5,6}};
vec1i w = flatten(v); // {1,2,3,4,5,6}
\end{cppcode}
\end{example}

\item \cppinline|vec_t<D1,T> reform(vec_t<D2,T>, ...)| \itt{reform}

This function transforms a vector into another vector just by changing its dimensions. The content in memory is exactly the same, so the operation is fast. In particular, if the argument of this function is a temporary, this function is extremely cheap as it produces no copy. However, the new dimensions have to generate the same number of elements as the provided vector contains. The \cppinline{flatten} function is a special case of \cppinline{reform}.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5,6};
vec2i w = reform(v, 2, 3); // {{1,2,3}, {4,5,6}}
\end{cppcode}
\end{example}

\item \cppinline|vec_t<N,T>   replicate(T, ...)| \itt{replicate}

      \cppinline|vec_t<D+N,T> replicate(vec_t<D,T>, ...)|


This function will take the provided scalar (first version) or vector (second version), and replicate it multiple times according to the provided additional parameters, to generate additional dimensions.

\begin{example}
\begin{cppcode}
// First version
vec1i v = replicate(2, 5); // {2,2,2,2,2} 5 times 2
vec2i w = replicate(2, 3, 2); // {{2,2},{2,2},{2,2}} 3 x 2 times 2

// Second version
vec2i z = replicate(vec1i{1,2}, 3); // {{1,2},{1,2},{1,2}} 3 times {1,2}
// Note that it is not possible to just use a plain initializer list
vec2i z = replicate({1,2}, 3); // error, unfortunately
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Adding/removing elements}

\begin{itemize}
\item \cppinline|vec_t<1,T> remove(vec_t<1,T> v, vec1u id)| \itt{remove}

\cppinline|void inplace_remove(vec_t<1,T>& v, vec1u id)| \itt{inplace_remove}

These functions will remove the elements in \cppinline{v} that have their indices in \cppinline{id}. The only difference between the first and the second version is that the former will first make a copy of the provided vector, remove elements inside this copy, and return it. The second version modifies directly the provided vector, and is therefore faster.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {4,5,2,8,1};
vec1i w = remove(v, {1,3}); // {4,2,1}

// Second version
inplace_remove(v, {1,3});
v; // {4,2,1}
\end{cppcode}
\end{example}

\item \cppinline|void append<N>(vec_t<D,T1>& t1, vec_t<D,T2> t2)| \itt{append}

\cppinline|void append(vec_t<1,T1>& t1, vec_t<1,T2> t2)|

\cppinline|void prepend<N>(vec_t<D,T1>& t1, vec_t<D,T2> t2)| \itt{prepend}

\cppinline|void prepend(vec_t<1,T1>& t1, vec_t<1,T2> t2)|

These functions behave similarly to \cppinline{vec_t::push_back}, in that they will add new elements at the end (\cppinline{append}), but also at the beginning (\cppinline{prepend}) of the provided vector. However, when \cppinline{vec_t::push_back} can only add new elements from a vector that is one dimension less than the original vector (or a scalar, for monodimensional vectors), these functions will add new elements from a vector of the \emph{same} dimension. These functions are also more powerful than \cppinline{vec_t::push_back}, because they allow you to choose along which dimension the new elements will be added, through the template parameter \cppinline{N} (note that this parameter is useless and therefore does not exist for monodimensional vectors). The other dimensions must be identical. They are clearly dedicated to a more advanced usage.

\begin{example}
\begin{cppcode}
// For monodimensional vectors
vec1i v = {1,2,3};
vec1i w = {4,5,6};
append(v, w);
v; // {1,2,3,4,5,6}
prepend(v, w);
v; // {4,5,6,1,2,3,4,5,6}

// For multidimensional vectors
vec2i x = {{1,2}, {3,4}};         // x is (2x2)
vec2i y = {{0}, {0}};             // y is (1x2)
vec2i z = {{5,6,7}};              // z is (3x1)
append<1>(x, y);
x; // {{1,2,0}, {3,4,0}}          // x is (2x3)
prepend<0>(x, z);
x; // {{5,6,7}, {1,2,0}, {3,4,0}} // x is (3x3)
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Error checking}

\begin{itemize}
\item \cppinline|void phypp_check(bool b, ...)| \itt{phypp_check}

This function makes error checking easier. When called, it checks the value of \cppinline{b}. If \cppinline{b} is \cppinline{true}, then nothing happens. However if \cppinline{b} is \cppinline{false}, then the current file and line are printed to the standard output, followed by the other arguments of this function (they are supposed to be an error message explaining what went wrong), and an assertion is raised, immediately stopping the program. This function is used everywhere in the \phypp library to make sure that certain conditions are properly satisfied before doing a calculation, and it is essential to make the program crash in case something is unexpected (rather than letting it run hoping for the best, and often getting the worst).

Since this function is actually implemented by a preprocessor macro, you should not worry about its performance impact. It will only affect the performances when something goes wrong and the program is about to crash. However the calculation of \cppinline{b} can itself be costly (for example, you may want to check that a vector is sorted), and there is no way around this.

\begin{example}
\begin{cppcode}
vec1i v;
// Suppose v is read from the command line arguments.
v = read_from_somewhere();

// The following code needs at least 3 elements in the
// vector v, so we need to check that first.
phypp_check(v.size() >= 3, "this algorithm needs at least "
    "3 values in the input vector, but only ", v.size(),
    " were found");

// If we get past this point, then v has the right number
// of elements, and we can proceed
do_stuff(v);
\end{cppcode}
\end{example}
\end{itemize}

\section{Parsing command line arguments \label{SEC:support:cmd}}
% argv.hpp

\begin{itemize}
\item \cppinline|void read_args(int argc, char* argv[], ...)| \itt{read_args}
\end{itemize}

\section{File input/output \label{SEC:support:file}}
% file.hpp

\begin{itemize}
\item \vectorfunc \cppinline|bool file::exists(string)| \itt{file::exists}
\item \cppinline|bool file::is_older(string f1, string f2)| \itt{file::is_older}
\item \cppinline|vec1s file::list_directories(string)| \itt{file::list_directories}
\item \cppinline|vec1s file::list_files(string)| \itt{file::list_files}
\item \vectorfunc \cppinline|string file::directorize(string)| \itt{file::directorize}
\item \vectorfunc \cppinline|string file::get_basename(string)| \itt{file::get_basename}
\item \vectorfunc \cppinline|string file::get_directory(string)| \itt{file::get_directory}
\item \vectorfunc \cppinline|bool file::mkdir(string)| \itt{file::mkdir}
\item \cppinline|void file::read_table(string f, uint_t s, ...)| \itt{file::read_table}
\item \cppinline|void file::write_table(string f, uint_t w, ...)| \itt{file::write_table}

\cppinline|void file::write_table_csv(string f, uint_t w, ...)| \itt{file::write_table_csv}

\cppinline|void file::write_table_hdr(string f, uint_t w, vec1s hdr, ...)| \itt{file::write_table_hdr}
\end{itemize}

\section{String manipulation \label{SEC:support:string}}
% string.hpp

\begin{itemize}
\item \cppinline|string strn(T)| \itt{strn}

\cppinline|string strn(T v, uint_t n, char fill = '0')|

\cppinline|string strn_sci(T v)| \itt{strn_sci}

\item \cppinline|vec_<D,string> strna(vec_t<D,T>)| \itt{strna}

\cppinline|vec_<D,string> strna(vec_t<D,T> v, uint_t n, char fill = '0')|

\cppinline|vec_<D,string> strna_sci(vec_t<D,T> v)| \itt{strna_sci}

\item \vectorfunc \cppinline|bool from_string(string s, T& v)| \itt{from_string}

\item \vectorfunc \cppinline|bool empty(string s)| \itt{empty}
\item \vectorfunc \cppinline|uint_t length(string s)| \itt{length}

\item \vectorfunc \cppinline|string trim(string s, string cs)| \itt{trim}

\item \vectorfunc \cppinline|string toupper(string s)| \itt{toupper}

\item \vectorfunc \cppinline|string tolower(string s)| \itt{tolower}

\item \vectorfunc \cppinline|string replace(string s, string p, string r)| \itt{replace}

\item \cppinline|vec1s split(string s, string p)| \itt{split}

\item \cppinline|vec1s cut(string s, uint_t n)| \itt{cut}

\item \cppinline|vec1s wrap(string s, uint_t w, string i = "", bool e = false)| \itt{wrap}

\item \cppinline|string collapse(vec_t<D,string>)| \itt{collapse}

\cppinline|string collapse(vec_t<D,string> v, string s)|

\item \vectorfunc \cppinline|uint_t find(string s, string p)| \itt{find}

\item \vectorfunc \cppinline|bool match(string s, string r)| \itt{match}

\vectorfunc \cppinline|bool match_any_of(string s, vec1s r)| \itt{match_any_of}

\item \vectorfunc \cppinline|bool start_with(string s, string p)| \itt{start_with}

\vectorfunc \cppinline|bool end_with(string s, string p)| \itt{end_with}

\item \vectorfunc \cppinline|string erase_begin(string s, string p)| \itt{erase_begin}

\vectorfunc \cppinline|string erase_begin(string s, uint_t n)|

\vectorfunc \cppinline|string erase_end(string s, string p)| \itt{erase_end}

\vectorfunc \cppinline|string erase_end(string s, uint_t n)|

\item \vectorfunc \cppinline|string keep_start(string s, uint_t n = 1)| \itt{keep_start}

\vectorfunc \cppinline|string keep_end(string s, uint_t n = 1)| \itt{keep_end}

\item\vectorfunc  \cppinline|string remove_extension(string)| \itt{remove_extension}

\item \vectorfunc \cppinline|string align_left(string s, uint_t w, char f = ' ')| \itt{align_left}

\vectorfunc \cppinline|string align_center(string s, uint_t w, char f = ' ')| \itt{align_center}

\vectorfunc \cppinline|string align_right(string s, uint_t w, char f = ' ')| \itt{align_right}

\item \vectorfunc \cppinline|uint_t distance(string s1, string s2)| \itt{distance}

\end{itemize}

\section{OS interaction \label{SEC:support:os}}

\begin{itemize}

\item \cppinline|string system_var(string v, string d = "")| \itt{system_var}

\end{itemize}

\section{Printing to the terminal \label{SEC:support:print}}
% print.hpp

\begin{itemize}

\item \cppinline|void print(...)| \itt{print}

\cppinline|void error(...)| \itt{error}

\cppinline|void warning(...)| \itt{warning}

\cppinline|void note(...)| \itt{note}

\end{itemize}

\section{Measuring time \label{SEC:support:time}}
% time.hpp

\begin{itemize}

\item \cppinline|double now()| \itt{now}

\item \cppinline|string today()| \itt{today}

\item \cppinline|string time_str(double)| \itt{time_str}

\item \cppinline|string seconds_str(double)| \itt{seconds_str}

\item \cppinline|auto progress_start(uint_t)| \itt{progress_start}

\cppinline|void progress(auto p, uint_t m)| \itt{progress}

\cppinline|void print_progress(auto p, T i, uint_t m)| \itt{print_progress}

\end{itemize}

\section{Mathematics \label{SEC:support:math}}
% math.hpp
% mpfit.hpp

The mathematics support library is among the largest inside \phypp. It contains many functions, as well as a handful of useful constants. Some functionalities of this library are only available if you have installed the \texttt{fftw} and \texttt{gsl} libraries. If not, the specific functions that depend on these libraries will not be available, or will be slow, but the rest of the library will function properly.

This library provides the following global constants:
\begin{itemize}
\item \cppinline{fnan}\itt{fnan} and \cppinline{dnan}\itt{dnan}. These are the \cppinline{float} and \cppinline{double} representation of the ``not-a-number'' (NaN) special value. This value is returned by some operations that are mathematically undefined in the real domain. For example, dividing zero by zero, or taking the square root of a negative number. NaN has some very peculiar properties that can surprise the newcomer. In particular, it propagates extremely fast, since any operation involving at least a NaN value will always return NaN, e.g., \cppinline{2.0 + fnan == fnan}). More troubling, any comparison operation involving a NaN will return \cppinline{false}, e.g., \cppinline{(10.0 < fnan) == false} and \cppinline{(10.0 >= fnan) == false} too. The only notable exception to this rule is that \cppinline{(fnan != fnan) == true}. Knowing this, NaN is a very useful return value to indicate that giving an actual value would not make sense. For example, in a galaxy catalog, some galaxies may have been observed at a certain wavelength, but not all of them. For those that are not observed, we do not know their flux. In this case, astronomers typically assign them a special, weird value, such as \cppinline{-99}. Using NaN in this case is clearer.

\item \cppinline{fpi}\itt{fpi} and \cppinline{dpi}\itt{dpi}. This is the \cppinline{float} and \cppinline{double} closest representation of the number $\pi = 3.14519...$.

\item \cppinline{finf}\itt{finf} and \cppinline{dinf}\itt{dinf}. This is the \cppinline{float} and \cppinline{double} representation of the positive infinity. The positive infinity is larger than any other finite value.
\end{itemize}

We now present the functions provided by this support library. One of the responsibilities of this library is to bring vectorized versions of standard mathematical functions that only work for scalar values. Since these functions are fairly common and well known, we will not describe their signature and behavior, and instead just list them here:

\begin{itemize}
\item exponentiation: \cppinline{sqrt}\itt{sqrt}, \cppinline{pow}\itt{pow},
\item trigonometry: \cppinline{cos}\itt{cos}, \cppinline{sin}\itt{sin}, \cppinline{tan}\itt{tan}, \cppinline{acos}\itt{acos}, \cppinline{asin}\itt{asin}, \cppinline{atan}\itt{atan}, \cppinline{cosh}\itt{cosh}, \cppinline{sinh}\itt{sinh}, \cppinline{tanh}\itt{tanh}, \cppinline{acosh}\itt{acosh}, \cppinline{asinh}\itt{asinh}, \cppinline{atanh}\itt{atanh},
\item exponentials and logarithms: \cppinline{exp}\itt{exp}, \cppinline{log}\itt{log}, \cppinline{log2}\itt{log2}, \cppinline{log10}\itt{log10},
\item special functions: \cppinline{erf}\itt{erf}, \cppinline{erfc}\itt{erfc}, \cppinline{tgamma}\itt{tgamma},
\item rounding: \cppinline{ceil}\itt{ceil}, \cppinline{floor}\itt{floor}, \cppinline{round}\itt{round},
\item absolute value: \cppinline{fabs}\itt{fabs}.
\end{itemize}

We also introduce the functions \cppinline{bessel_j0}\itt{bessel_j0}, \cppinline{bessel_j1}\itt{bessel_j1}, \cppinline{bessel_y0}\itt{bessel_y0}, \cppinline{bessel_y1}\itt{bessel_y1}, \cppinline{bessel_i0}\itt{bessel_i0}, \cppinline{bessel_i1}\itt{bessel_i1}, \cppinline{bessel_k0}\itt{bessel_k0}, \cppinline{bessel_k1}\itt{bessel_k1}. The scalar version of the first four are provided by the C++ standard, while the last four are provided by the \texttt{gsl}.

We now list the other, less common functions provided in this library. These are grouped by sections.

\subsection{Low level mathematics}

\begin{itemize}
\item \vectorfunc \cppinline|double e10(double)| \itt{e10}

\item \vectorfunc \cppinline|T sqr(T)| \itt{sqr}

\item \vectorfunc \cppinline|T invsqr(T)| \itt{invsqr}

\item \vectorfunc \cppinline|T clamp(T t, U mi, V ma)| \itt{clamp}

\item \vectorfunc \cppinline|bool finite(T)| \itt{finite}

\item \vectorfunc \cppinline|bool nan(T)| \itt{nan}

\item \vectorfunc \cppinline|int_t sign(T)| \itt{sign}
\end{itemize}

\subsection{Sequences and bins}

\begin{itemize}
\item \cppinline|vec1u rgen(T)| \itt{rgen}

\cppinline|vec_t<1,T> rgen(T i, U j)|

\cppinline|vec1d rgen(T i, U j, V n)|

\cppinline|vec1d rgen_log(T i, U j, V n)| \itt{rgen_log}

\item \cppinline|vec_t<2,T> make_bins(T mi, T ma)| \itt{make_bins}

\cppinline|vec_t<2,T> make_bins(T mi, T ma, uint_t n)|

\cppinline|vec_t<2,T> make_bins(vec_t<1,T>)|

\item \vectorfunc \cppinline|bool in_bin(T v, vec_t<1,U> b)| \itt{in_bin}

\vectorfunc \cppinline|bool in_bin(T v, vec_t<2,U> b, uint_t ib)|

\vectorfunc \cppinline|bool in_bin_open(T v, vec_t<2,U> b, uint_t ib)| \itt{in_bin_open}

\item \cppinline|vec_t<1,T> bin_center(vec_t<2,T>)| \itt{bin_center}
\cppinline|T bin_center(vec_t<1,T>)|

\item \cppinline|vec_t<1,T> bin_width(vec_t<2,T>)| \itt{bin_width}
\cppinline|T bin_width(vec_t<1,T>)|
\end{itemize}

\subsection{Randomization}

\begin{itemize}
\item \cppinline|auto make_seed(T)| \itt{make_seed}

\item \cppinline|double randomn(auto seed)| \itt{randomn}

\cppinline|vec_t<N,double> randomn(auto seed, ...)|

\item \cppinline|double randomu(auto seed)| \itt{randomn}

\cppinline|vec_t<N,double> randomu(auto seed, ...)|

\item \cppinline|T randomi(auto seed, T mi, T ma)| \itt{randomi}

\cppinline|vec_t<N,T> randomi(auto seed, T mi, T ma, ...)|

\item \cppinline|T random_pdf(auto seed, vec_t<1,T> x, vec_t<1,U> y, ...)| \itt{random_pdf}

\item \cppinline|bool random_coin(auto seed, double p)| \itt{random_coin}

\cppinline|vec_t<N,bool> random_coin(auto seed, double p, ...)|

\item \cppinline|vec_t shuffle(vec_t, auto seed)| \itt{shuffle}

\cppinline|void inplace_shuffle(vec_t&, auto seed)| \itt{inplace_shuffle}
\end{itemize}

\subsection{Reduction}

\begin{itemize}
\item \cppinline|void run_dim_idx(uint_t d, F f, ...)| \itt{run_dim_idx}

\item \cppinline|vec_t<D-1,T> run_dim(vec_t<D,T> v, uint_t d, F f)| \itt{run_dim}

\item \cppinline|T total(vec_t<D,T> v)| \itt{total}

\cppinline|vec_t<D-1,T> partial_total(uint_t d, vec_t<D,T> v)| \itt{partial_total}

\item \cppinline|uint_t count(vec_t<D,bool> v)| \itt{count}

\cppinline|vec_t<D-1,uint_t> partial_count(uint_t d, vec_t<D,bool> v)| \itt{partial_count}

\item \cppinline|uint_t fraction_of(vec_t<D,bool> v)| \itt{fraction_of}

\cppinline|vec_t<D-1,uint_t> partial_fraction_of(uint_t d, vec_t<D,bool> v)| \itt{partial_fraction_of}

\item \cppinline|double mean(vec_t v)| \itt{mean}

\cppinline|vec_t<D-1,double> partial_mean(uint_t d, vec_t<D,T> v)| \itt{partial_mean}

\item \cppinline|T median(vec_t<D,T> v)| \itt{median}

\cppinline|T inplace_median(vec_t<D,T>& v)| \itt{inplace_median}

\cppinline|vec_t<D-1,T> partial_median(uint_t d, vec_t<D,T> v)| \itt{partial_median}

\item \cppinline|T percentile(vec_t<D,T> v, double p)| \itt{percentile}

\cppinline|vec_t<D-1,T> partial_percentile(uint_t d, vec_t<D,T> v, double p)| \itt{partial_percentile}

\cppinline|vec_t<1,T> percentiles(vec_t<D,T> v, double ...)| \itt{percentiles}

\item \cppinline|T min(vec_t<D,T> v)| \itt{min}

\cppinline|T min(vec_t<D,T> v, uint_t& i)|

\cppinline|vec_t<D-1,T> partial_min(uint_t d, vec_t<D,T> v)| \itt{partial_min}

\cppinline|T max(vec_t<D,T> v)| \itt{max}

\cppinline|T max(vec_t<D,T> v, uint_t& i)|

\cppinline|vec_t<D-1,T> partial_max(uint_t d, vec_t<D,T> v)| \itt{partial_max}

\item \cppinline|uint_t min_id(vec_t<D,T> v)| \itt{min_id}

\cppinline|uint_t max_id(vec_t<D,T> v)| \itt{max_id}

\item \cppinline|vec1u histogram(vec_t v, vec_t<2,V> b)| \itt{histogram}

\cppinline|vec_t<1,T2> histogram(vec_t<D,T1> v, vec_t<D,T2> w, vec_t<2,U> b)|

\item \cppinline|vec2u histogram2d(vec_t<D,T1> x, vec_t<D,T2> y, vec_t<2,U1> bx, vec_t<2,U2> by)| \itt{histogram2d}

\item \cppinline|vec_t<D,bool> sigma_clip(vec_t<D,T> v, double pl, double pu)| \itt{sigma_clip}

\item \cppinline|vec_t<D,bool> mad_clip(vec_t<D,T> v, double s)| \itt{mad_clip}

\end{itemize}

\subsection{Interpolation}

\begin{itemize}
\item \cppinline|double interpolate(double y1, y2, x1, x2, x)| \itt{interpolate}

\cppinline|T interpolate(vec_t<D,T> y, vec_t<D,U> x, V nx)|

\cppinline|vec_t<D2,T> interpolate(vec_t<D1,T> y, vec_t<D1,U> x, vec_t<D2,V> nx)|

\item \cppinline|T bilinear(vec_t<2,T> m, double x, double y)| \itt{bilinear}

\item \cppinline|vec_t<2,T> rebin(vec_t<2,T> m, vec1d mx, vec1d my, vec1d nx, vec1d ny)| \itt{rebin}
\end{itemize}

\subsection{Calculus}

\begin{itemize}
\item \cppinline|double derivate1(F f, double x, double e)| \itt{derivate1}

\cppinline|double derivate1(F f, vec1d x, double e, uint_t i)| \itt{derivate1}

\item \cppinline|double derivate2(F f, double x, double e)| \itt{derivate2}

\cppinline|double derivate2(F f, vec1d x, double e, uint_t i)| \itt{derivate2}

\item \cppinline|double integrate_trap(F f, double x, uint_t n)| \itt{integrate_trap}

\cppinline|double integrate(F f, double x, double e = default)| \itt{integrate}

\item \cppinline|double integrate(vec_t<1,T> x, vec_t<1,U> y)| \itt{integrate}

\cppinline|double integrate(vec_t<1,T> x, vec_t<1,U> y, double x0, double x1)|

\cppinline|double integrate(vec_t<2,T> x, vec_t<1,U> y)|

\cppinline|double integrate(vec_t<2,T> x, vec_t<1,U> y, double x0, double x1)|

\end{itemize}

\subsection{Algebra}

\begin{itemize}
\item \cppinline|vec_t<2,V> mmul(vec_t<2,T> a, vec_t<2,U> b)| \itt{mmul}

\cppinline|vec_t<1,V> mmul(vec_t<2,T> a, vec_t<1,U> b)|

\cppinline|vec_t<1,V> mmul(vec_t<1,T> b, vec_t<2,U> a)|

\item \cppinline|vec_t<2,T> transpose(vec_t<2,T>)| \itt{transpose}

\item \cppinline|vec_t<1,T*> diagonal(vec_t<2,T>)| \itt{diagonal}

\item \cppinline|vec2d identity_matrix(uint_t)| \itt{identity_matrix}

\item \cppinline|vec2d scale_matrix(double sx, double sy)| \itt{scale_matrix}

\cppinline|vec2d scale_matrix(double s)|

\item \cppinline|vec2d translation_matrix(double dx, double dy)| \itt{translation_matrix}

\item \cppinline|vec2d rotation_matrix(double a)| \itt{rotation_matrix}

\item \cppinline|vec1d point2d(double x, double y)| \itt{point2d}

\item \lapack \cppinline|bool invert(vec2d a, vec2d& i)| \itt{invert}

\lapack \cppinline|bool inplace_invert(vec2d&)| \itt{inplace_invert}

\item \lapack \cppinline|bool invert_symmetric(vec2d a, vec2d& i)| \itt{invert_symmetric}

\lapack \cppinline|bool inplace_invert_symmetric(vec2d&)| \itt{inplace_invert_symmetric}

\item \lapack \cppinline|bool solve_symmetric(vec2d a, vec1d b, vec1d& r)| \itt{solve_symmetric}

\lapack \cppinline|bool inplace_solve_symmetric(vec2d& a, vec1d& b)| \itt{inplace_solve_symmetric}

\item \lapack \cppinline|bool eigen_symmetric(vec2d a, vec1d& va, vec1d& ve)| \itt{eigen_symmetric}

\lapack \cppinline|bool inplace_eigen_symmetric(vec2d& a, vec1d& va)| \itt{inplace_eigen_symmetric}

\item \fftw \cppinline|vec2cd fft(vec2d)| \itt{fft}

\fftw \cppinline|vec2d ifft(vec2cd)| \itt{ifft}

\item \cppinline|vec_t<1,W> convolve(vec_t<1,T> x, vec_t<1,U> y, vec_t<1,V> k)| \itt{convolve}

\end{itemize}

\subsection{Fitting}

\begin{itemize}
\item \cppinline|auto linfit(vec_t y, vec_t e, ...)| \itt{linfit}

\cppinline|auto linfit_pack(vec_t<D,T> y, vec_t<D,U> e, vec_t<D+1,V> x)| \itt{linfit_pack}

\item \cppinline|auto affinefit(vec_t<D,T> y, vec_t<D,U> e, vec_t<D,V> x)| \itt{affinefit}

\item \cppinline|auto mpfit(F d, vec1d p, auto opt = default)| \itt{mpfit}

\item \cppinline|auto mpfitfun(vec_t<D,T> y, vec_t<D,U> e, vec_t<D,V> x, F f, vec1d p, auto opt = default)| \itt{mpfitfun}

\end{itemize}

\subsection{Geometry}

\begin{itemize}
\item \cppinline|vec1u convex_hull(vec_t<D,T1> x, vec_t<D,T2> y)| \itt{convex_hull}

\item \cppinline|bool is_hull_closed(vec1u h, vec_t<D,T1> hx, vec_t<D,T2> hy)| \itt{is_hull_closed}

\item \cppinline|bool in_convex_hull(T1 x, T2 y, vec1u h, vec_t<D,U1> hx, vec_t<D,U2> hy)| \itt{in_convex_hull}

\cppinline|vec_t<D,bool> in_convex_hull(vec_t<D,T1> x, vec_t<D,T2> y, vec1u h, vec_t<D,U1> hx, vec_t<D,U2> hy)|

\item \cppinline|double convex_hull_distance(T1 x, T2 y, vec1u h, vec_t<D,U1> hx, vec_t<D,U2> hy)| \itt{convex_hull_distance}

\cppinline|vec_t<D,double> convex_hull_distance(vec_t<D,T1> x, vec_t<D,T2> y, vec1u h, vec_t<D,U1> hx, vec_t<D,U2> hy)|

\item \cppinline|double angdistr(double ra1, dec1, ra2, dec2)| \itt{angdistr}

\cppinline|double angdist(double ra1, dec1, ra2, dec2)| \itt{angdist}

\cppinline|vec_t<D,double> angdist(vec_t<D,double> ra1, dec1, ra2, dec2)|

\cppinline|vec_t<D,double> angdist(vec_t<D,double> ra1, dec1, double ra2, dec2)|

\item \cppinline|vec_t<D,bool> angdist_less(vec_t<D,double> ra1, dec1, double ra2, dec2)| \itt{angdist_less}

\item \cppinline|void move_ra_dec(double& ra, dec, double dra, ddec)| \itt{move_ra_dec}

\cppinline|void move_ra_dec(vec_t<D,double>& ra, dec, double dra, ddec)|

\end{itemize}

\subsection{Debug functions}

\begin{itemize}
\item \cppinline|void data_info(vec_t)| \itt{data_info}
\item \cppinline|void mprint(vec_t<2,T>)| \itt{mprint}
\end{itemize}

\section{Parallel execution \label{SEC:support:thread}}
% thread.hpp

\begin{itemize}
\item \cppinline|void fork(string)| \itt{fork}

\cppinline|void spawn(string)| \itt{spawn}

\item \cppinline|auto thread::pool(uint_t)| \itt{thread::pool}

\item \cppinline|void thread::sleep_for(double)| \itt{thread::sleep_for}
\end{itemize}

\section{FITS input/output \label{SEC:support:fits}}
% fits.hpp

The FITS (Flexible Image Transport System) format is a general purpose file format developed for astrophysics data. In particular, FITS files can store images with floating point pixel values, image cubes, but also binary data tables with an arbitrary number of columns and rows. Using a meta-data system (FITS keywords), FITS files usually carry a number of important additional informations about their content. E.g., for images files, the mapping between image pixels and sky coordinates (WCS coordinates), or the physical unit of the pixel values.

Storying data tables in binary inside FITS files is a space-efficient and fast way to store and read non-image data. FITS tables come in two fashions: row-oriented and column-oriented tables. In row-oriented tables, all the data about one row (e.g., about one galaxy in the table) is stored contiguously on disk. This means that it is very fast to retrieve all the information about a given object. In column-oriented tables however, a whole column is stored contiguously in memory. This means that it is very fast to read a given column for all the objects in the table. Due to the way the \phypp library is designed, it is more efficient to use the latter format, since a given column of the file will be represented by a single \phypp vector. It also brings the nice advantage of allowing to store columns of different lengths, e.g.~to combine two tables in the same file, or to carry meta-data that would be hard to store in the standard FITS keywords. The column-oriented format is not well known, but most softwares and libraries do support it\footnote{Topcat does. In IDL, column-oriented FITS files are supported by the \cppinline{mrdfits} and \cppinline{mwrfits} procedures.}.

Finally, note that this support library introduces a new type: \cppinline{fits::header} (that we will shorten to \cppinline{header} in the following). This type is used to store the header of any FITS file. For now, it is actually just a raw \cppinline{std::string}, but that might change in the future.

We now describe the various functions offered by this library, split into categories.

\subsection{Generic header functions}

\begin{itemize}
\item \cppinline|header fits::read_header(string f)| \itt{fits::read_header}

\cppinline|header fits::read_header(string f, uint_t s)|

\item \cppinline|bool fits::getkey(header hdr, string k, T& v)| \itt{fits::getkey}

\item \cppinline|bool fits::setkey(header hdr, string k, T& v, string c = "")| \itt{fits::setkey}


\end{itemize}

\subsection{FITS images}

\begin{itemize}
\item \cppinline|uint_t fits::file_axes(string)| \itt{fits::file_axes}

\item \cppinline|vec1u fits::file_dimensions(string)| \itt{fits::file_dimensions}

\item \cppinline|bool fits::is_cube(string)| \itt{fits::is_cube}

\item \cppinline|bool fits::is_image(string)| \itt{fits::is_image}

\item \cppinline|void fits::read(string f, vec_t& v)| \itt{fits::read}

\cppinline|void fits::read(string f, vec_t& v, header& hdr)|

\cppinline|void fits::read_hdu(string f, vec_t& v, uint_t hdu)| \itt{fits::read_hdu}

\cppinline|void fits::read_hdu(string f, vec_t& v, uint_t hdu, header& hdr)|

\item \cppinline|vec1s fits::read_sectfits(string f)| \itt{fits::read_sectfits}

\item \cppinline|void fits::write(string f, vec_t v)| \itt{fits::write}

\cppinline|void fits::write(string f, vec_t v, header hdr)|

\item \cppinline|void fits::display(string f)| \itt{fits::display}

\cppinline|void fits::display(string r, string g)|

\cppinline|void fits::display(string r, string g, string b)|

\end{itemize}

\subsection{WCS coordinates}

\begin{itemize}
\item \cppinline|bool fits::make_wcs_header(auto p, header& hdr)| \itt{fits::make_wcs_header}

\cppinline|bool fits::make_wcs_header(vec1s p, header& hdr)|

\item \cppinline|header fits::filter_wcs(header)| \itt{fits::filter_wcs}

\item \cppinline|auto fits::extast(header)| \itt{fits::extast}

\item \cppinline|void fits::ad2xy(auto wcs, vec_t ra, dec, vec_t& x, y)| \itt{fits::ad2xy}

\cppinline|void fits::xy2ad(auto wcs, vec_t ra, dec, vec_t& x, y)| \itt{fits::xy2ad}

\item \cppinline|bool fits::get_pixel_size(string file, double& a)| \itt{fits::get_pixel_size}

\end{itemize}

\subsection{FITS tables}

\begin{itemize}
\item \cppinline|vec_t<1,auto> fits::read_table_columns(string)| \itt{fits::read_table_columns}

\item \cppinline|void fits::read_table(string f, ...)| \itt{fits::read_table}

\cppinline|void fits::read_table_loose(string f, ...)| \itt{fits::read_table_loose}

\item \cppinline|void fits::write_table(string f, ...)| \itt{fits::write_table}

\cppinline|void fits::update_table(string f, ...)| \itt{fits::update_table}

\end{itemize}


\section{Image processing \label{SEC:support:image}}
% image.hpp

\begin{itemize}
\item \cppinline|vec_t<2,T> enlarge(vec_t<2,T> v, array {l1, l2, u1, u2}, T d = 0)| \itt{enlarge}

\cppinline|vec_t<2,T> enlarge(vec_t<2,T> v, uint_t u, T d = 0)|

\item \cppinline|vec_t<2,T> shrink(vec_t<2,T> v, array {l1, l2, u1, u2})| \itt{shrink}

\cppinline|vec_t<2,T> shrink(vec_t<2,T> v, uint_t u)|

\item \cppinline|void subregion(vec_t<2,T> v, vec1i r, vec1u& rr, vec1u& rs)| \itt{subregion}

\cppinline|void subregion(vec_t<2,T> v, vec1i r, T d = 0)|

\item \cppinline|vec_t<2,T> translate(vec_t<2,T> v, double x, double y, T d = 0)| \itt{translate}

\item \cppinline|vec2d circular_mask(vec1u d, vec1d c, double r)| \itt{circular_mask}

\item \cppinline|vec_t<1,T> radial_profile(vec_t<2,T> m, uint_t n)| \itt{radial_profile}

\item \cppinline|vec_t<2,T> generate_img(array {w,h}, F f)| \itt{generate_img}

\item \cppinline|vec2d gaussian_profile(array {w,h}, double sigma)| \itt{gaussian_profile}

\item \cppinline|vec_t<2,T> convolve2d(vec_t<2,T> m, vec_t<2,U> k)| \itt{convolve2d}

\item \cppinline|vec_t<2,T> boxcar(vec_t<2,T> m, uint_t n, F f)| \itt{boxcar}
\end{itemize}

\section{Astrophysics \label{SEC:support:astro}}
% astro.hpp

\subsection{PSF fitting}

\begin{itemize}
\item \cppinline|bool make_psf(array<uint_t> {w, h}, double x0, y0, string model, vec2d& psf)| \itt{make_psf}

\item \cppinline|auto psffit(vec_t<2,T> m, vec_t<2,U> e, vec_t<2,V> psf, vec1i pos)| \itt{psffit}

\cppinline|auto psffit(vec_t<2,T> m, vec_t<2,U> e, vec_t<2,V> psf)|
\end{itemize}

\subsection{Cosmology}

\begin{itemize}
\item \cppinline|auto get_cosmo()| \itt{get_cosmo}

\cppinline|auto cosmo_wmap()| \itt{cosmo_wmap}

\cppinline|auto cosmo_std()| \itt{cosmo_std}

\item \vectorfunc \cppinline|T lumdist(T z, auto cosmo)| \itt{lumdist}

\item \vectorfunc \cppinline|T lookback_time(T z, auto cosmo)| \itt{lookback_time}

\item \vectorfunc \cppinline|T vuniverse(T z, auto cosmo)| \itt{vuniverse}
\end{itemize}

\subsection{Fluxes, magnitudes and luminosities}

\begin{itemize}
\item \cppinline|X lsun2uJy(T z, U d, V lam, W lum)| \itt{lsun2uJy}

\cppinline|X uJy2lsun(T z, U d, V lam, W lum)| \itt{uJy2lsun}

\item \cppinline|W lsun2mag(T lam, U lum, double zp = 23.9)| \itt{lsun2mag}

\cppinline|W mag2lsun(T lam, U lum, double zp = 23.9)| \itt{mag2lsun}

\item \cppinline|U uJy2mag(T flx, double zp = 23.9)| \itt{uJy2mag}

\cppinline|U mag2uJy(T mag, double zp = 23.9)| \itt{mag2uJy}

\item \cppinline|auto read_filter_db(string)| \itt{read_filter_db}

\item \cppinline|auto get_filter(auto db, string name)| \itt{get_filter}

\cppinline|auto get_filters(auto db, vec1s names)| \itt{get_filters}

\item \cppinline|double sed2flux(auto fil, vec_t<1,T> lam, vec_t<1,U> sed)| \itt{sed2flux}

\cppinline|vec1d sed2flux(auto fil, vec_t<2,T> lam, vec_t<2,U> sed)|

\item \cppinline|double sed_convert(auto from, auto to, double z, d, vec_t<1,T> lam, vec_t<1,U> sed)| \itt{sed_convert}

\item \cppinline|double lir_8_1000(vec_t<1,T> lam, vec_t<1,U> sed)| \itt{lir_8_1000}
\end{itemize}

\subsection{Sky coordinates}

\begin{itemize}
\item \cppinline|double field_area_hull(vec1u hull, vec_t<D,double> ra, dec)| \itt{field_area_hull}

\cppinline|double field_area_hull(vec_t<D,double> ra, dec)|

\item \cppinline|double field_area_h2d(vec_t<D,double> ra, dec)| \itt{field_area_h2d}

\item \cppinline|double field_area(vec_t<D,double> ra, dec)| \itt{field_area}

\item \cppinline|vec1d angcorrel(vec_t<D1,double> ra, dec, vec_t<D2,double> rra, rdec, vec_t<2,T> b)| \itt{angcorrel}

\item \cppinline|auto randpos_uniform(auto seed, vec1d rra, rdec, F in, vec_t<D,double>& ra, dec, auto options = default)| \itt{randpos_uniform}

\item \cppinline|auto randpos_power_circle(auto seed, double ra0, dec0, r0, vec_t<D,double>& ra, dec, auto options = default)| \itt{randpos_power_circle}

\item \cppinline|auto randpos_power(auto seed, vec1u h, vec_t<D1,double> hra, hdec, vec_t<D2,double>& ra, dec, auto options = default)| \itt{randpos_power}

\item \vectorfunc \cppinline|bool sex2deg(string sra, sdec, double& ra, dec)| \itt{sex2deg}

\vectorfunc \cppinline|void deg2sex(double ra, dec, string& sra, sdec)| \itt{deg2sex}

\item \vectorfunc \cppinline|auto qxmatch(vec1d ra1, dec1, ra2, dec2, auto options = default)| \itt{qxmatch}

\item \vectorfunc \cppinline|vec2d qdist(vec1d ra, dec, auto options = default)| \itt{qdist}
\end{itemize}

\subsection{Catalog management}
% astro/catalog_merge.hpp

\begin{itemize}
\item \cppinline|bool get_band(auto cat, string band, uint_t& b)| \itt{get_band}

\cppinline|bool get_band(auto cat, string band, string note, uint_t& b)| \itt{get_band}
\end{itemize}

\subsection{Image stacking}
% astro/qstack.hpp

\begin{itemize}
\item \cppinline|bool pick_sources(vec_t<2,T> m, vec1d x, y, uint_t hs, vec_t<3,T>& c, vec1u& ids)| \itt{pick_sources}

\item \cppinline|auto qstack(vec1d ra, dec, string ff, uint_t hs, vec_t<3,T>& fc, vec1u& i, auto options = default)| \itt{qstack}

\cppinline|auto qstack(vec1d ra, dec, string ff, fw, uint_t hs, vec_t<3,T>& fc, wc, vec1u& i, auto options = default)|

\item \cppinline|auto qstack_mean(vec_t<3,T> fc)| \itt{qstack_mean}

\cppinline|auto qstack_mean(vec_t<3,T> fc, wc)|

\item \cppinline|auto qstack_median(vec_t<3,T> fc)| \itt{qstack_median}

\item \cppinline|void qstack_bootstrap(vec_t<3,T> fc, uint_t nb, ns, auto seed, F f)| \itt{qstack_bootstrap}

\cppinline|void qstack_bootstrap(vec_t<3,T> fc, wc, uint_t nb, ns, auto seed, F f)|

\cppinline|void qstack_bootstrap(uint_t nb, ns, auto seed, F f, ...)|

\item \cppinline|vec_t<3,T> qstack_mean_bootstrap(vec_t<3,T> fc, uint_t nb, ns, auto seed)| \itt{qstack_mean_bootstrap}

\cppinline|vec_t<3,T> qstack_mean_bootstrap(vec_t<3,T> fc, wc, uint_t nb, ns, auto seed)|

\item \cppinline|vec_t<3,T> qstack_median_bootstrap(vec_t<3,T> fc, uint_t nb, ns, auto seed)| \itt{qstack_median_bootstrap}
\end{itemize}

\subsection{Template fitting}
% astro/qstack.hpp

\begin{itemize}
\item \cppinline|vec2d template_observed(auto lib, double z, d, auto filters)| \itt{template_observed}

\cppinline|vec2d template_observed(auto lib, vec1d z, d, auto filters)|

\item \vectorfunc \cppinline|double limweight(double)| \itt{limweight}

\item \cppinline|auto template_fit(auto lib, auto seed, T z, d, vec1d flux, err, auto filters, auto options = default)| \itt{template_fit}
\end{itemize}

\chapter{Tools \label{SEC:tool}}

\section{Astrophysics \label{SEC:tool:astro}}
\subsection{\texttt{angcorrel}} \itt{angcorrel}
\subsection{\texttt{catinfo}} \itt{catinfo}
\subsection{\texttt{deg2sex} and \texttt{sex2deg}} \itt{deg2sex} \itt{sex2deg}
\subsection{\texttt{findsrc}} \itt{findsrc}
\subsection{\texttt{fluxcube}} \itt{fluxcube}
\subsection{\texttt{getgal}} \itt{getgal}
\subsection{\texttt{photinfo}} \itt{photinfo}
\subsection{\texttt{psffit}} \itt{psffit}
\subsection{\texttt{qstack2}} \itt{qstack2}
\subsection{\texttt{qxmatch2}} \itt{qxmatch2}
\subsection{\texttt{randsrc}} \itt{randsrc}
\subsection{\texttt{subsrc}} \itt{subsrc}

\section{FITS and ASCII \label{SEC:tool:fits}}
\subsection{\texttt{fits2ascii}} \itt{fits2ascii}
\subsection{\texttt{fitstool}} \itt{fitstool}
\subsection{\texttt{imgtool}} \itt{imgtool}
\subsection{\texttt{qconvol}} \itt{qconvol}
\subsection{\texttt{remcol}} \itt{remcol}


\printindex

\end{document}
