\documentclass[12pt]{report}

\usepackage[T1]{fontenc}
% \usepackage{lmodern}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{txfonts}
\usepackage{xcolor}
\usepackage{xspace}
\usepackage{minted}
\usepackage{geometry}
\usepackage{imakeidx}
\makeindex
\usepackage[totoc]{idxlayout}
\usepackage{xparse}
\usepackage{mdframed}
\usepackage{footnote}
\usepackage{tikz}
\usepackage[colorlinks=true,linkcolor=blue,linktoc=page]{hyperref}

\makesavenoteenv{tabular}
\makesavenoteenv{table}

\newcommand{\via}{{\it via}\xspace}
% \newcommand{\phypp}{\texttt{phy++}\xspace}
\newcommand{\phypp}{\textit{phy}$_{\text{++}}$\xspace}
\newcommand{\cpp}[1]{\texttt{#1}\xspace}
\newcommand{\stdvec}{\cppinline|std::vector|\xspace}

\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
            \node[shape=circle,draw,inner sep=0.0pt] (char) {#1};}}

\newcommand{\vectorfuncsym}{\circled{$\hspace{-1pt}\mathcal{V}$}\xspace}
\newcommand{\vectorfunc}{\vectorfuncsym\hspace{2pt}\xspace}

\newcommand{\lapacksym}{\textsc{\small[lapack\small]}}
\newcommand{\lapack}{\lapacksym\hspace{2pt}\xspace}
\newcommand{\fftwsym}{\textsc{[fftw]}}
\newcommand{\fftw}{\fftwsym\hspace{2pt}\xspace}

\newcommand{\stwork}{works}
\newcommand{\sthwork}{half-working}
\newcommand{\stnwork}{not working}

\NewDocumentCommand\itt{v}{%
  \index{#1@\ittt{#1}}%
}

\NewDocumentCommand{\ittt}{v}{\texttt{#1}}

\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{advanced}{%
    linecolor=red,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{warning}{%
    linecolor=blue,linewidth=2pt,%
    leftmargin=0pt,rightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=2pt
}
\mdfsetup{skipabove=\topskip,skipbelow=\topskip}
\global\mdfdefinestyle{example}{%
    linecolor=black,linewidth=1pt,%
    leftmargin=0pt,rightmargin=0pt,%
    innerleftmargin=0pt,innerrightmargin=0pt,%
    leftline=false,rightline=false,topline=false,%
    frametitlerule=true, frametitlerulewidth=1pt
}

\newenvironment{advanced}
{
    \begin{mdframed}[style=advanced,frametitle={Advanced}]
}
{
    \end{mdframed}
}
\newenvironment{warning}
{
    \begin{mdframed}[style=warning,frametitle={Warning}]
}
{
    \end{mdframed}
}
\newenvironment{example}
{
    \begin{mdframed}[style=example,frametitle={Example}]
}
{
    \end{mdframed}
}

\newminted{cpp}{fontsize=\small}
\newmintinline{cpp}{fontsize=\small}
\newminted{bash}{fontsize=\small}
\newmintinline{bash}{fontsize=\small}

\newcommand{\cpptrue}{\cppinline{true}\xspace}
\newcommand{\cppfalse}{\cppinline{false}\xspace}

\newcommand{\footlabel}[2]{\footnote{\label{#1}#2}}
\newcommand{\footref}[1]{\textsuperscript{\ref{#1}}}

\DeclareFixedFont{\titlefont}{T1}{ppl}{b}{it}{0.5in}

\begin{document}
\begin{titlepage}

{\noindent \Huge \textbf{\phypp} \Large v1.0 \\[0.6cm]} \par
\noindent
\vspace{2cm}
\begin{center}
\Huge \textbf{Reference manual}
\end{center}
\null\vfill
\vspace*{1cm}
\hfill
\begin{minipage}{0.35\linewidth}
    \begin{flushright}
        \large Corentin Schreiber \\
        \today
    \end{flushright}
\end{minipage}
%
\begin{minipage}{0.02\linewidth}
    \rule{1pt}{40pt}
\end{minipage}
\end{titlepage}

\tableofcontents

\chapter{Introduction \label{SEC:intro}}

\section{Description of the library \label{SEC:intro:overview}}

\subsection{Overview}

\phypp is a set of library and tools built to provide user-friendly vector data manipulation, as offered in interpreted languages like IDL\footnote{\url{http://www.exelisvis.com/ProductsServices/IDL.aspx}}, its open source clone GDL\footnote{\url{http://gnudatalanguage.sourceforge.net/}}, or \texttt{python} \& \texttt{numpy}\footnote{\url{http://www.numpy.org/}}, but with the added benefit of C++: increased robustness, and optimal speed.

The library can be split into two components: the \emph{core} library (\ref{SEC:core}) and the \emph{support} library (\ref{SEC:support}). The core library introduces the \emph{vector} type, which is at the heart of \phypp, while the support library provides functions and other tools to manipulate these vectors and do some common tasks. You can think of the core library as ``the language'', and the support library as ``the function library''.

Below is an code sample written in \phypp that illustrates the most basic functionalities.

\begin{cppcode}
vec2f img = fits::read("img.fits"); // read a FITS image
img -= median(img);                 // subtract the median of the whole image
float imax = max(img);              // find the maximum of the image
vec1u ids = where(img > 0.5*imax);  // find pixels at least half as bright
float sum = total(img[ids]);        // compute the sum of these pixels
img[ids] = log(img[ids]/sum);       // modify these pixels with a logarithm
fits::write("new.fits", img);       // save the modified image to a FITS file
\end{cppcode}

\subsection{Why write something new?}

The immediate goal of \phypp is to provide a syntax as close as possible to that of IDL. IDL is an interpreted language that is widely used in the scientific community, in particular in astrophysics. Born in the late 1970s, this language provides intuitive manipulation of large arrays of data using vectorized operations: applying an operation on a given array does not require the user to write a loop to iterate over its elements and apply the operation. This leads to very concise code that easy to write and read. Unfortunately, IDL suffers from a number of problems. I will start with the \emph{political} and \emph{ethical} problems.
\begin{itemize}
\item It is a proprietary, mostly\footnote{The procedures from the IDL library that are written in IDL language are actually open-source, but all the procedures written in native language are compiled and only the binary is provided.} closed-source program. This means that IDL is a black box and that people using it have no choice but to rely on the IDL developers for writing accurate code. While there is an extensive documentation, the algorithms used by the procedures are not always described. This is hardly acceptable for scientific code.
\item IDL, like C++, combines several languages into one: a functional language and an object-oriented language. It also contains a huge support library providing many features (having used IDL for more than two years, I could not list them all). For this reason, and because it is proprietary, maintaining this language and adding new features costs a lot of money to its owner, Exelis. This money, in turn, is provided by science labs all around the world, who pay a yearly fee for a bunch of IDL licenses. This is totally fine in itself, but the fact is that most IDL users I have seen only make use of a small sub-set of IDL, one that has barely evolved in twenty years. In this context, the price that is paid is not justified.
\item On top of that, the licensing model is that of \emph{floating} licenses: only a fixed, maximum number of simultaneously running IDL instance is allowed in the whole lab. With the now common budget restrictions in research, labs typically buy fewer licenses than there are users. Even worse, it is often needed to run multiple instances of IDL on a single computer, e.g., when working on two projects simultaneously. This will consume two licenses, even though there is a single user. This leads to silly situations, typically when approaching specific deadlines (e.g., deadlines for requesting observing time on large telescopes) where everyone needs to use IDL at the same time, but there is not enough license available. Even worse, we have seen cases in our lab of users being unable to run IDL on their new shiny computer because of incompatibility, not with IDL itself, but with the licensing software. Lastly, it should be noted that this licensing model relies on having network connection with a license server. This means that one cannot use IDL while traveling unless a proper SSH tunneling is in place.
\end{itemize}

These issues can be solved by switching to one of the free and open-source alternatives, like GDL. The downside is that these implementations are lacking behind IDL in terms of features, as some useful functions are still to be implemented. Worse, some functions cannot \emph{legally} be implemented because they would violate IDL's copyright.

But that's only half of the story. Indeed, IDL and GDL also suffer from technical issues. I will list below the most important ones.
\begin{itemize}
\item Designed in the 1970s, IDL was born in an era where the available RAM was scarce, and that great care had to be taken to consume as few bytes of memory as possible. For this reason, the default integer type in IDL is a \cppinline{short}, i.e., it occupies only two bytes in memory, while most languages (including some that are older than IDL itself) encode their integers on four bytes by default. The biggest issue with this choice is that the largest number one can store in a \cppinline{short} is \cppinline{32768}. Being the default integer type, this creates quite a few surprises to the unexperienced user, and will fool even the expert from time to time.
\item IDL is an interpreted language, meaning that the code you write is continuously read and interpreted by the IDL executable. While this is not an issue if you make good use of vectorization (the art of writing IDL code), performances are severely degraded onces you write loops explicitly, because the content of the loop has to be \emph{interpreted} and then \emph{executed} on each iteration. And this is sometimes unavoidable.
\item Like many interpreted languages, IDL is dynamically typed. This means that the type of a variable can change from one line to another, and that a variable containing a string can be assigned a number. While sometimes convenient, this comes at a cost: performance. And the fact is that in most IDL programs this feature is not used.
\item But worse than dynamic typing, and this is my main concern, variables in IDL are not \emph{declared} before they are used. This means that if you do a typo in the name of one of your variables, chances are that the code will still run. Indeed, IDL cannot know that this was not intended, and will think that you want to create a new variable. It will then do its best to carry on, and the result will be unpredictable. This, together with the fact that variables are almost not \emph{scoped} (i.e., a variable created inside a \cppinline{for} loop is still valid outside of the loop) makes it very easy to write confusing and buggy code. The most frightening part is that, in a good fraction of the cases, the output will be meaningful, and you can go on with your calculation never realizing that something went wrong. And publish that.
\end{itemize}

Switching to more modern interpreted languages like \texttt{python} or Julia\footnote{\url{http://julialang.org/}} would solve a few of these issues, in particular the first one. But the other items on this list are unfortunately inherent to most interpreted languages\footnote{The best counter example is probably Java.}. To avoid these traps, the only solution today is to use \emph{statically typed}, compiled languages, like C++.

Now, there are already some libraries in C++ that are addressing the topic of vector data manipulation. One can cite \href{http://eigen.tuxfamily.org}{Eigen} or the more recent \href{https://code.google.com/p/blaze-lib/}{blaze-lib}. These are wonderful libraries that have inspired \phypp in some way, but their issue is that they are more oriented toward algebra, meaning that they have vectors and matrices, but no data type for arrays of higher dimensions (i.e., tensors\footnote{Eigen actually has a tensor module, but it is unsupported.}).

Therefore, seeing that a gap had to be filled, \phypp was created.

\subsection{Why C++?}

There are many different compiled languages that offer similar or better performances than C++. In particular, the most famous ones are Fortran and C. C is impractical to use because it has not been developed with user-friendliness in mind, and no mechanism exist to improve that. This is a system language, and it does that perfectly, but not much more. Fortran is known as the fastest of all, and it is particularly well suited for numerical analysis. While few languages as harder to read than Fortran 77, things have become much better since since Fortran 90 (which is not used as often as it should be). However, Fortran is relatively bad at doing anything else than numerical analysis, which is annoying the moment you want to do something that is a bit off the tracks. C++ on the other hand, with all its disadvantages, is probably the best fit thanks to its almost unlimited capacity for adaptation. And it also happens to be the language I am most familiar with.

Since the beginning, C++ has always been good at performances, first because it is a language that compiles directly into assembly, but also thanks to its philosophy: ``you only pay for what you ask for". But its main disadvantage is its \emph{complexity}: it contains almost the whole C language, plus all the layers that were added on top of it, one year after another, starting from classes, exceptions, then templates. The end result is that it is a challenging task to master all the aspects of this language.

But the good news is: you do not have to master all of C++, and for your sanity you probably should not. Indeed, there is a number of \emph{sub-languages} made out of a subset C++ that are completely self-sufficient, i.e.~you can use them to write any program. In other words, there are multiple, very different ways of writing the same program in C++. Typically, modern programs only use a small fraction of the whole language, e.g., leaving aside most of what was inherited from C (arrays, raw pointers, explicit memory management, etc.). A special class of such sub-languages are those that are tailored specifically to address a given task, as opposed to being open to any purpose. These are called \emph{domain-specific languages} (DSL), and only require learning a few of C++'s rules and concepts, plus the rules introduced by the sub-language itself. The \phypp library is an example of such domain-specific languages, its domain being vector data manipulation.

In short, although C++ is a very complex language, it is only necessary to learn a fraction of it to be able to use \phypp correctly. For example, you will find in \ref{SEC:instro:qstart:new} a self-consistent tutorial to get started with the library that does not require any preliminary knowledge of C++. Of course, the more you will know about C++, the more you will be able to take advantage of all the features of \phypp in an optimal way.

\section{Supported systems \label{SEC:intro:supported}}

The combination of operating systems and compilers on which this library has been tested is reported in the following table. If you have issues and your system is reported in this table as working, then there is probably something wrong in your configuration (e.g., a missing library). If you are using a system combination that is not listed here: if you managed to get it to work, please drop me an email and I will add it to the list; else, if you failed to compile or run programs with the library, please open a new issue on \texttt{github}\footnote{\url{https://github.com/cschreib/phypp/issues}} and we will try to get it fixed together.

\vspace*{0.5cm}
\begin{minipage}{\textwidth}
\begin{center}
\begin{tabular}{cccc}
\hline \hline
Operating system & Compiler & Status & Notes \\ \hline
Linux Mint 15 & gcc-4.8   & \stwork & \footlabel{foot:lm15}{\texttt{libclang} in the repository is too old. Use a more recent version from \href{https://launchpad.net/~h-rayflood/+archive/ubuntu/llvm}{ppa:h-rayflood/llvm}.} \\
 --           & clang-3.3 & \stwork & \footref{foot:lm15} \\
Linux Mint 17 & gcc-4.8   & \stwork & \footlabel{foot:lm17}{\texttt{libclang} in the repository crashes on valid C++ code. Fixed in \texttt{libclang-3.5}.} \\
 --           & clang-3.3 & \stwork & \footref{foot:lm17} \\
 --           & clang-3.4 & \stwork & \footref{foot:lm17} \\
 --           & clang-3.5 & \stwork & \footref{foot:lm17} \\
Ubuntu 14.04  & gcc-4.8   & \stwork & \footnote{Not all dependencies were tested.} \\
\hline
\end{tabular}
\end{center}
\end{minipage}

\section{Installing \label{SEC:intro:installing}}

\section{Quick-start guide \label{SEC:instro:qstart}}
\subsection{For users new to C++ \label{SEC:instro:qstart:new}}
\subsection{For users familiar with C++ \label{SEC:instro:qstart:fami}}


\chapter{Core library \label{SEC:core}}
% vec.hpp
% variadic.hpp
% reflex.hpp
% range.hpp
% iterator.hpp

\section{Overview \label{SEC:core:overview}}
At the core of the \phypp library is the \emph{vector} class. This is basically an enhanced \stdvec\footnote{In fact, \stdvec is used to implement the \phypp vectors internally.}, and it therefore shares most of its features and strengths. In particular, a vector can contain zero, one, or as many elements as your computer can handle. Its size is defined at \emph{runtime}, meaning that its content can vary depending on user input, but also that a vector can change its total number of elements at any time. These elements are stored contiguously in memory, which provides optimal performances in most situations. Lastly, a vector is an homogeneous container, meaning that a given vector can only contain a single type of elements (e.g., \cppinline|int| or \cppinline|float|, but not both at the same time).

Like most advanced C++ libraries, \phypp is essentially \emph{template} based. This means that most of the code is written to work for \emph{any} type \cppinline|T|, e.g., \cppinline|int|, \cppinline|float|, \cppinline|std::string|, or whatever you need. However, while templates are a fantastic tool for library writers, they can easily become a burden for the \emph{user} of the library. The good thing is, since \phypp is a numerical analysis library, we know in advance what types will most often be stored inside the vectors. So for this reason, to reduce typing and enhance readability, we introduce type aliases for the most commonly used vector types:
\begin{itemize}
\item \cppinline|vec1f|: vector of \cppinline|float|,
\item \cppinline|vec1d|: vector of \cppinline|double|,
\item \cppinline|vec1cf|: vector of \cppinline|std::complex<float>|,
\item \cppinline|vec1cd|: vector of \cppinline|std::complex<double>|,
\item \cppinline|vec1i|: vector of \cppinline|int| (precisely, \cppinline|int_t = std::ptrdiff_t|),
\item \cppinline|vec1u|: vector of \cppinline|unsigned int| (precisely, \cppinline|uint_t = std::size_t|),
\item \cppinline|vec1b|: vector of \cppinline|bool|,
\item \cppinline|vec1s|: vector of \cppinline|std::string|,
\item \cppinline|vec1c|: vector of \cppinline|char|.
\end{itemize}

On top of the \stdvec interface, the \phypp vector adds some extra functionalities. The most important ones are operator overloading, multi-dimensional indexing, and vector views.

\subsection{Operator overloading \label{SEC:core:overview:overloading}}

The only thing you can do to operate on all the elements of an \stdvec is to iterate over these elements explicitly, either using a C++11 range-based loop, or using indices:
\begin{cppcode}
// Goal: multiply all elements by two.
std::vector<float> v = {1,2,3,4};

// Either using a range-based loop,
for (float& x : v) {
    x *= 2;
}

// ... or an index-based loop.
for (std::size_t i = 0; i < v.size(); ++i) {
    v[i] *= 2;
}
\end{cppcode}

While this is fairly readable (especially the first version), it is still not very concise and expressive. In \phypp, we have \emph{overloaded} the usual mathematical operators on our vector type, meaning that it is possible to write the above code in a much simpler way:

\begin{cppcode}
// Using phy++ vector.
vec1f w = {1,2,3,4};
w *= 2; // {2,4,6,8}
\end{cppcode}

Not only this, but we can perform operations on a pair of vectors in the same way:
\begin{cppcode}
// Goal: sum the content of the two vectors.
vec1f x = {1,2,3,4}, y = {4,3,2,1};
vec1f z = x + y; // {5,5,5,5}
\end{cppcode}

\begin{warning}
The only issue with operator overloading concerns the hat operator \cppinline|^|. In most languages, this operator is used for exponentiation, e.g., \cppinline|4^2 == 16|. However, in C++ this value is actually \cppinline|6|, because the hat operator is the binary XOR (exclusive-or). Even worse, the hat operator in C++ does not have the same \emph{precedence} as in regular mathematics: it has a lower priority than any other mathematical operator. Both these reasons make it unwise to overload the hat operator in \phypp. In order to perform exponentiation, you will have to use a dedicated function such as \cppinline|pow(4,2)| (\ref{SEC:support:math}).
\end{warning}

\subsection{Multi-dimensional indexing \label{SEC:core:overview:multidim}}

The standard \stdvec is a purely linear container: one can access its elements using \cppinline|v[i]|, with \cppinline|i| ranging from \cppinline|0| up to \cppinline|std::vector::size()-1| (included). However, the \phypp vector allows N-dimensional indexing, i.e., using a group of indices to identify one element. For example, this is particularly useful to work on images, which are essentially 2-dimensional objects where one identifies a given pixel by its coordinates \cppinline|x| and \cppinline|y|. The natural syntax for this indexing would be to write \cppinline|img[x,y]|. This syntax is valid C++ code, but unfortunately will not do what you expect\footnote{This will call the \emph{comma} operator, which evaluates both elements \cppinline|x| and \cppinline|y| and returns the last one, i.e., \cppinline|y|. So this code actually means \cppinline|img[y]|. With proper configuration, most compiler will warn about this though, since in this context \cppinline|x| is a useless statement, so you should be safe should you make this mistake.} and there is no sane way around it. The alternative we chose here is to write instead \cppinline|img(x,y)|. While it is not as semantically clear as using brackets, it has the nice advantage of being compatible with the IDL syntax.

The multi-dimensional nature of a vector is determined at \emph{compile time}, i.e., it cannot be changed after the vector is declared. By default, a vector is mono-dimensional. To use the above feature, one needs to specify the number of needed dimensions in the type of the vector. For example, a 2D image of \cppinline|float| will be declared as \cppinline|vec2f|. These type aliases are provided for dimensions up to $6$. Here is an example of manipulation of a 2D matrix:

\begin{cppcode}
// Create a simple matrix.
vec2f m = {{1,2,3}, {4,5,6}, {7,8,9}};

// Index ordering is similar to C arrays: the last index
// is contiguous in memory. Note that this is *opposite*
// to the IDL convention.
m(0,0); // 1
m(0,1); // 2
m(1,0); // 4

// It is still possible to access elements as if in a
// "flat" vector
m[0]; // 1
m[1]; // 2
m[3]; // 4
\end{cppcode}

\begin{advanced}
If for some reason you need to use more than 6 dimensions, or if you need to declare a vector of some type which is not covered above, you can always fall back to the full template syntax:
\begin{cppcode}
// Need 12 dimensions?
using vec12f = vec<12,float>;
// Need 512 bit of floating point precision?
using vec3f512 = vec<3,mpfr::real<512>>;
\end{cppcode}

The hard limit on the number of dimensions will then depend on your compiler (each dimension involves an additional level of template recursion). The C++ standard does not guarantee anything, but you should be able to go as high as 256 on all major compilers. Beyond this, you should probably see a doctor first.

As for the types allowed inside the vector, there is no explicit restriction. However, some features may obviously not be available depending on the capabilities of your type (e.g., if your type has no \cppinline{operator*}, you will not be able to multiply together vectors of this type). Lastly, the \phypp vector shares the same restrictions as the \stdvec regarding the \emph{copyable} and \emph{movable} capabilities of the stored type.
\end{advanced}

\subsection{Vector views \label{SEC:core:overview:views}}

We have seen that, instead of accessing each element individually, we can use operator overloading to perform simple operations on all the elements of the vector at once: \cppinline|w *= 2|. We can also, like with \stdvec, modify each element individually, knowing their indices: \cppinline|w[2] *= 2|. One last important feature allowed by the \phypp vector is that one can create a \emph{view} inside a vector. Each element of the view is actually a \emph{reference} to an element in the original vector, and modifying the elements of the view actually modifies the elements in the original vector. As you will see later, views actually share most of the interface and capabilities of true vectors, so that most generic codes that work with vectors will also work with views.

\begin{cppcode}
// Create a simple vector.
vec1f w = {1,2,3,4,5,6};

// We want to "view" only the second, the third and the
// fifth elements. So we first create a vector containing
// the corresponding indices.
vec1u id = {1,2,4};

// Then we create the view.
// Note the usage of "auto" there. The type of the view is
// complex, and it is better not to worry about it.
auto v = w[id];

// Now we can modify these elements very simply, as if they
// were part of a real vector.
v;         // {2,3,5}
v *= 2;    // {4,6,10}
w;         // {1,4,6,4,10,6}
w[1] = 99; // {1,99,6,4,10,6}
v;         // {99,6,10}
\end{cppcode}

\begin{warning}
It is important to note that, since a view keeps references to the elements of the original vector, the lifetime of the view must not exceed that of the original vector. Else, it will contain \emph{dangling references}, i.e.~pointers to unused memory, and this should be avoided at all cost. In fact, views are not meant to be stored into named variables like in the above example. Most of the time, one will use them as temporary variables, e.g.:
\begin{cppcode}
vec1f w = {1,2,3,4,5,6};
vec1u id = {1,2,4};
w[id] *= 2; // {1,4,6,4,10,6}
\end{cppcode}
\end{warning}

\section{The vector class \label{SEC:core:vec}}

The full type of the vector class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec<Dimension,ElementType>;
\end{cppcode}

In the rest of this document, \cppinline{Dimension} will usually just be called \cppinline{D} and \cppinline{ElementType} will be shortened to \cppinline{T}.

\subsection{Member variables \label{SEC:core:vec:member_var}}

A vector only contains two member variables:
\begin{itemize}
\item \cppinline{std::vector<T> data} \\ This is the underlying \stdvec containing the elements of the vector. It is exposed to the public interface for simplicity, but on most occasions it should \emph{not} be used directly. In fact, it may become part of the private interface in the future, so you should not rely on its existence.

\begin{advanced}
Concerning \cppinline{bool} vectors. We do not use \cppinline{std::vector<bool>}, since it is a very special case of \stdvec: the C++ standard specifies that the \cppinline{bool} specialization does not store \cppinline{bool} elements, but is actually implemented like a \emph{bit field}. This is essentially to save memory: a \cppinline{bool} in C++ occupies $8$ bits of memory, like a \cppinline{char}, even though it can only carry a single bit of information. This is due to \emph{memory alignment} issues, which are inherent to the CPU architecture (the address of individual values in memory are supposed to be multiples of $8$ bits, or one byte). In a bit field however, $8$ \cppinline{bool}s are stored in a single \cppinline{char}, and bitwise operators are used to read and write individual \cppinline{bool}s. While more memory efficient, it is also slower, and involves a whole machinery to trick the user into thinking that none of this is happening. For this reason, \cppinline{bool} vectors are implemented with \cppinline{std::vector<char>} in \phypp, with one \cppinline{char} containing one \cppinline{bool}. This is completely transparent to the library user though, since \cppinline{char&} is casted into \cppinline{bool&}, and vice versa, at the boundary of the vector interface.
\end{advanced}

\item \cppinline{std::array<std::size_t,D> dims} \\ This variable contains the dimensions of this vector (useful only for multidimensional vectors). On no occasion should you modify this variable yourself: you should only read its content\footnote{This statement is actually a bit bold, but is mostly true. The only reason why this variable is made public is for optimization purposes. On occasions, it can be noticeably faster to manage manually the growth of a vector, and update the dimensions afterwards. This is often done within the core library, but should rarely be done otherwise.}. To change the dimensions of a vector, either use \cppinline{resize(...)} (\ref{SEC:core:vec:member_fun}) or assign it another vector (\ref{SEC:core:vec:constructor}).

\begin{example}
\begin{cppcode}
// Create a 2D image with 256 x 128 pixels
vec2f img(256,128);
img.dims[0]; // 256
img.dims[1]; // 128
for (std::size_t x = 0; x < img.dims[0]; ++x)
for (std::size_t y = 0; y < img.dims[1]; ++y) {
    img(x,y) = 3.1415;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Constructors and assignment \label{SEC:core:vec:constructor}}

There are various ways to construct a new vector, or assign it some value. In the following, we will cover the various \emph{constructors} and the associated \emph{assignments} when applicable.

\begin{itemize}
\item \cppinline|vec::vec(); // The default constructor|

Like \stdvec, the \phypp vector is \emph{default constructible}. By default it is in a valid state where the vector does not contain any element.

\begin{example}
\begin{cppcode}
vec1f w; // default constructor: w is empty
\end{cppcode}
\end{example}

\item \cppinline|explicit vec::vec(...); // The dimension constructor|

The \stdvec has a constructor to create a new vector of a given size. The \phypp vector also offers this feature, however it is rendered a bit more complex by the possibility of having multi-dimensional vectors. In particular, it is possible to specify the size either by giving all the dimensions one by one, or by specifying some (or all) as a \cppinline|std::array|. In all cases, the vector is populated with the number of requested elements, and all these elements are \emph{default initialized} (i.e., integers and floats are initialized to \cppinline{0}, booleans to \cppfalse, and \cppinline|std::string| are empty). This constructor is declared \cppinline{explicit} to prevent interference with the other constructors and assignments.

\begin{example}
\begin{cppcode}
vec1f w(10);     // w contains 10 objects all equal to 0
vec2d z(5,4);    // z contains 5*4=20 objects all equal to 0
vec2s x(z.dims); // x has the same dimensions as z
                 // but contains strings, all empty
vec3b y(z.dims, 8); // y has the same dimensions as z,
                 // plus an extra dimension of length 8
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(nested_initializer_list<D,T>); // The list constructor|

Like \stdvec, the \phypp vector can be initialized from a list of values. This usually requires the usage of \cppinline|std::initializer_list<T>|, however here we also have to support multi-dimensional vectors, hence we need initializer lists of initializer lists of ..., and \cppinline|nested_initializer_list<D,T>| is just that. Note that, since C++ is a row-major language, the most nested lists correspond to the last index in a multi-dimensional vector.

\begin{example}
\begin{cppcode}
vec1f w({1,2,3}); // 1D list constructor: {1,2,3}
vec2f z({{1,2,3},{6,5,4}}); // 2D list constructor: {{1,2,3},{6,5,4}}
z(0,0); // 1
z(0,1); // 2
z(0,2); // 3

// Assignment
w = {4,5,6};
z = {{1,2}, {3,4}, {5,6}}; // dimensions can change through assignment
z(0,0); // 1
z(1,0); // 3
z(2,0); // 5
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec&); // The copy constructor|

Like \stdvec, the \phypp vector is \emph{copiable}, meaning that one can duplicate the content of an existing vector inside another vector by copy. Note that this constructor is only valid for copying vectors of the \emph{same} type. If the type is different, then another constructor is called (conversion constructor, see below).

\begin{example}
\begin{cppcode}
vec1f w = {1,2,3};
vec1f z(w); // copy constructor: {1,2,3}

// Assignment
z = w;
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(vec&&); // The move constructor|

Like \stdvec, the \phypp vector is \emph{movable}, meaning that one can move the content of an existing vector that is going to be destroyed inside another vector. This is an optimized copy for temporary variables (C++11 move semantics). You need not explicitly ask for either the copy of the move constructor, as they will automatically be chosen by the compiler. For you, this is transparent (but the performance boost is large).

\begin{example}
\begin{cppcode}
vec1f z(vec1f{1,2,3}); // move constructor: {1,2,3}
// Here, a temporary vector is created with vec1f{1,2,3}.
// This temporary vector is then *moved* inside z.

// Assignment
z = vec1f{4,5,6};
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec<D,OtherT>&); // The conversion constructor|

C++ supports implicit conversion between all the build in types. In particular, it is possible to write:
\begin{cppcode}
int i = 0;
float f = i; // int to float
bool b1 = i; // int to bool, mostly for interoperability with C
bool b2 = f; // float to bool, not sure if that makes sense...
\end{cppcode}
While this is very convenient in most cases, it can also lead to dangerous silent conversions, such as the \cppinline{float} to \cppinline{bool} conversion. This is, somehow, a legacy of C. In \phypp we decided to also support such implicit conversions. They make the code much easier to read, but the price to pay is that sometimes we do some conversions which are not necessary, and we do not realize it because they are implicit. However, we decided to disable implicit conversion to and from \cppinline{bool} vectors, since it could lead to subtle bugs that are difficult to trace. It is sill possible to do the conversion to \cppinline{bool} using explicit

\begin{example}
\begin{cppcode}
vec1i w = {1,2,0};
vec1f z(w); // int to float {1,2,0}
vec1b y(w); // error: cannot convert int to bool
vec1s x(w); // error: cannot convert int to std::string

vec1b b = {true,true,false};
vec1i s(b); // bool to int {1,1,0}

// Assignment
z = w;
y = w;        // error: cannot convert int to bool
x = w;        // error: cannot convert int to std::string

s = b;        // error: implicit conversion is not allowed for bool
s = vec1i(b); // ok: bool to int {1,1,0}
\end{cppcode}
\end{example}

\item \cppinline|vec::vec(const vec<D,T*>&); // The view constructor|

The last constructor on the list is the view constructor. It allows implicit conversion of a view (\ref{SEC:core:view}) into a new, independent vector.

\begin{example}
\begin{cppcode}
vec1i w = {1,2,3};
vec1u id = {0,1};
vec1i z(w[id]); // {1,2}

// Assignment
z = w[id];
\end{cppcode}
\end{example}

\end{itemize}

\subsection{Member functions \label{SEC:core:vec:member_fun}}

\begin{itemize}
\item \cppinline{bool vec::empty() const}

This function will return \cpptrue if this vector contains at least one element, and \cppfalse otherwise. In particular, \cpptrue will be returned for default constructed vectors, and after a call to \cppinline{vec::clear()}.

\begin{example}
\begin{cppcode}
vec1i v;
v.empty(); // true
vec1i w = {1,2,3};
w.empty(); // false
\end{cppcode}
\end{example}

\item \cppinline{std::size_t vec::size() const}

This function will return the total number of elements in this vector. If the vector is empty, then the function returns \cppinline{0}. If the vector is multidimensional, then the function returns the product of all the dimensions.

\begin{example}
\begin{cppcode}
vec1i v;
v.size(); // 0
vec1i w = {1,2,3};
w.size(); // 3
vec2i z = {{1,2,3}, {4,5,6}};
z.size(); // 6
\end{cppcode}
\end{example}

\item \cppinline{void vec::resize(...)}

This function can be used to explicitly change the size of a vector. The parameters it accepts are the same as the dimension constructor (\ref{SEC:core:vec:constructor}), i.e., either integral values for individual dimensions, or an \cppinline{std::array} containing multiple dimensions, or any combination of these. However, the total number of dimensions of the vector must remain unchanged.

After the vector has been resized, its content will have changed. For a monodimensional vector, if the resize operation \emph{decreased} the total number of elements, then the last elements will be erased, but the other ones will remain untouched. On the other hand, if the resize operation \emph{increased} the total number of elements, all the previous elements are unchanged, and new elements are inserted at the end of the vector, default constructed (i.e., zeroes for integral types, etc.). For a multidimensional vector, its content is left in an \emph{undefined state}, and can be assumed to be destroyed\footnote{This is just out of laziness. In the future, this will probably be specified to behave like the monodimensional vector. The issue is that it involves non-trivial reshuffling of the elements to preserve the original structure after the dimensions have changed. I have not needed this feature so far.}.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.resize(5); // {1,2,3,0,0}
v.resize(2); // {1,2}
v.resize(3); // {1,2,0}

vec2f w = {{1,2},{2,3}};
w.resize(2,3); // w has been resized, but its content is unspecified
w(0,0); // ?
\end{cppcode}
\end{example}

\item \cppinline{void vec::clear()}

This function removes all elements from the vector, and sets all dimensions to zero.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.clear(); // v is now empty
v.empty(); // true
v.size();  // 0
v.dims;    // {0}
\end{cppcode}
\end{example}

\item \cppinline{T& vec::back()}

This function is only available for monodimensional vectors. It returns the last element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.back(); // 3
v.back() == v[v.size()-1]; // always true
\end{cppcode}
\end{example}

\item \cppinline{T& vec::front()}

This function is only available for monodimensional vectors. It returns the first element of the vector. Will crash if called on an empty vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.front(); // 1
v.front() == v[0]; // always true
\end{cppcode}
\end{example}

\item \cppinline{void vec::push_back(...)}

The behavior of this function is different for monodimensional and multidimensional vectors. For monodimensional vectors, this function appends a new element at the end of the vector, and therefore takes for argument a single value of type \cppinline{T} (or convertible to \cppinline{T}). For multidimensional vectors, this function takes for argument another vector of \cppinline{D-1} dimensions, and whose lengths match the \emph{last} \cppinline{D-1} dimensions of the first vector. This new vector is inserted after the existing elements, and the first dimension of the first vector is increased by one.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3};
v.push_back(4); // {1,2,3,4}

vec2i w = {{1,2,3}, {4,5,6}};
w.push_back({7,8,9}); // {{1,2,3}, {4,5,6}, {7,8,9}}
w.push_back({7,8});   // error: dimensions do not match, 2 != 3
\end{cppcode}
\end{example}

\item \cppinline{void vec::reserve(std::size_t)}

This function is used for optimization, and is similar to \cppinline{std::vector::reserve()} (actually, this function is called internally). To understand what this function actually does, one needs to know the internal behavior of \stdvec. By default, the \stdvec only allocates enough memory to hold a few elements. Once the allocated memory is full, \stdvec allocates a larger amount of memory, copies the existing elements inside this new memory, and frees the old memory. This strategy allows virtually unlimited growth of a given vector, and is quite efficiently tuned. However, it is still an expensive operation, and performances can be greatly improved if one knows \emph{in advance} the total number of objects that need to be stored in the vector, so that the right amount of memory is allocated from the beginning, and no copy is required. This function does just that, it tells \stdvec how many elements it \emph{will} (or might) contain at some point, so that the vector can already allocate enough memory. This is also useful if you only have a rough idea of the future number of elements.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,...};

// Let's imagine you have an algorithm that will produce an
// unknown number of values, but you know that on average
// it is close to N*N.
vec1i w;
// Reserve roughly enough memory in advance
w.reserve(v.size()*v.size());

// Now the algorithm will run close to the optimal memory
// efficiency
for (...) {
    w.push_back(...);
}
\end{cppcode}
\end{example}

\item \cppinline{uint_t vec::pitch(uint_t) const}

This is only useful for multidimensional vectors. This function returns the ``pitch'' factor associated to a given dimension. This factor is number of elements in memory that separate two consecutive indices of this dimension. By definition, the pitch factor is \cppinline{1} for the last dimension. For the other dimensions, this is the product of all the other dimensions located between the one considered and the last dimension.

\begin{example}
\begin{cppcode}
vec3f v(5,8,6);
v.pitch(2); // 1
v.pitch(1); // 6 = v.dims[2]
v.pitch(0); // 48 = v.dims[2]*v.dims[1]
\end{cppcode}
\end{example}

\item \cppinline{bool vec::is_same(const vec<D,T>&) const}

This function tests if the provided vector is a view inside this vector.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
vec1f w = {1,2,3};
vec1u id = {1,2};
v.is_same(v[id]); // true
v.is_same(w[id]); // false
\end{cppcode}
\end{example}

\item \cppinline{const vec& vec::concretize() const}

This function just returns a reference to this vector, and is only present to mirror the interface of the view class.

\item \cppinline{iterator vec::begin()} and \cppinline{iterator vec::end()}

These functions allow iteration over the values of this vector. The only reason one may use these functions explicitly is when using algorithms from the standard C++ library, which often work on a pair of iterators as returned by \cppinline{begin()} and \cppinline{end()}.

\begin{example}
\begin{cppcode}
vec1f v = {1,2,3};
// The presence of these functions allow to use vectors
// in range-based loops
for (float& f : v) {
    f += 1;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Indexing \label{SEC:core:vec:indexing}}

There are two ways to index a given vector, for both mono- and multidimensional vectors. The first way is through ``flat'' indices and the bracket indexing \cppinline{v[i]}, i.e., a single index that runs contiguously in memory, and the second way is through multidimensional indices and parenthesis indexing \cppinline{v(i)} (\ref{SEC:core:overview:multidim}). For monodimensional vectors, these two methods are perfectly identical.

Flat indexing does not care about the details of the dimensions of a given vector. The only important thing is the total number of elements in the vector. This is the simplest and fastest\footnote{Actually there is a faster way using the \cppinline{safe} wrapper, which does not do bounds checking. See the ``Advanced'' note at the end of this section.} way to access the data inside a vector.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.size(); ++i) {
    // Here we traverse the vector v regardless of its dimensions
    v[i] = 12.0 + i*i - sqrt(5.0*i) + v[i/4];
}
\end{cppcode}
\end{example}

Multidimensional indexing is more involved computationally, because it implies some index arithmetic to compute the flat index and find the right place to read in memory. However it is much more expressive and easier to read and understand. Furthermore, except for very critical code sections, the performance gap is usually negligible, as long as you iterate over the dimensions properly, i.e., following the example below, that you do the \emph{last} nested loop to iterate on the \emph{last} index. This will guarantee as much memory locality as possible, and will take best advantage of CPU caches.

\begin{example}
\begin{cppcode}
vec3f v(4,5,8); // a complex 3D vector
for (std::size_t i = 0; i < v.dims[0]; ++i)
for (std::size_t j = 0; j < v.dims[1]; ++j)
for (std::size_t k = 0; k < v.dims[2]; ++k) {
    // Here we traverse the vector v keeping its dimensional structure
    v(i,j,k) = 42.0 + i + j + k/(j+1);
}
\end{cppcode}
\end{example}

Indexing a vector can only be done with integers, e.g., \cppinline{int}, \cppinline{unsigned int}, \cppinline{int_t}, \cppinline{uint_t}, \cppinline{std::size_t}, etc. Indexing with \emph{unsigned} integers is faster because it removes the need to check for the positivity of the index, and should therefore be preferred when possible. Negative indices are allowed though, and they are interpreted as \emph{reverse} indices, where \cppinline{-1} refers to the last element of the vector, \cppinline{-2} the one before the last, etc.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v[0];    // 1, int index
v[0u];   // 1, unsigned int index (faster, but more cumbersome)
vec[-1]; // 4, int index
vec[-2]; // 3, int index
vec[-1] == vec[vec.size()-1]; // always true

v[0.1]; // error: can only access using integers
\end{cppcode}
\end{example}

As discussed in the overview (\ref{SEC:core:overview:views}), one can also use a vector to index another one. This is creates a \emph{view} into the vector. Similarly to scalar indexing, creating a view is only allowed by using integer vectors, i.e., \cppinline{vec1u}, \cppinline{vec1i} and their multidimensional counterparts. Again, unsigned integers should be preferred when possible.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,2,3};
v[id]; // 1,3,4
\end{cppcode}
\end{example}

Sometimes, one will want to use views to access all the elements at once, for example to set all the elements of a vector to a specific value. This can be done with a loop, of course, but it can be boring to write. To do so without explicitly writing the loop, one typically has to create first an index vector containing all the indices of the target vector, and then apply the operation:

\begin{cppcode}
vec1i v = {1,2,3,4};
vec1u id = {0,1,2,3}; // all the indices of v
v[id] = 12;

// Note that the following will not work
v = 12; // now v only contains a single element equal to 12
\end{cppcode}

Not only is this not very practical to write, it is error prone and not very clear. If we decide to add an element to \cppinline{v}, we also have to modify \cppinline{id}. Not only this, but it will most likely be slower than writing the loop directly, because the compiler may not realize that you are accessing all the elements contiguously, and will fail to optimize it properly. For this reason, we also introduce the ``placeholder'' symbol, defined as a single underscore \cppinline{_}. When used as an index, it means ``all the indices in the range''. Coming back to our example:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_] = 12; // it cannot get much shorter
\end{cppcode}

This placeholder index can be used in all situations, with both flat and multidimensional indexing. It can be further refined to only encompass a fraction of the whole range, using a peculiar syntax\footnote{Be warned that this feature has been introduced recently and may not survive in the future.}:

\begin{cppcode}
vec1i v = {1,2,3,4};
v[_-2] = 12;   // only access the indices 0 to 2
v[2-_] = 12;   // only access the indices 2 to 3
v[1-_-2] = 12; // only access the indices 1 to 2
\end{cppcode}

Except for the special case of the placeholder index \cppinline{_}, all the indexing methods described above perform \emph{bound checks} before accessing each element. In other words, the vector class makes sure that each index is smaller than either the total size of the vector (for flat indices) or the length of its corresponding dimension (for multidimensional indices). If this condition is not satisfied, an assertion is raised explaining the problem, and the program is stopped immediately to prevent memory corruption.

\begin{advanced}
This bound checking has a small but noticeable impact on performances. In most cases, the added security is definitely worth it. Indeed, accessing a vector with an out of bounds index has very unpredictable impacts on the behavior of the program: sometimes it will crash, but most of the time it will not. Memory will be silently corrupted, the problem will be hard to notice, but the consequences can be terrible... Then, identifying the root of the problem to fix it may prove even more challenging. This is why bound checking is enabled by default.

However, there are cases where bound checking is superfluous, for example if we already know \emph{by construction} that the indices we are dealing with will always be valid. Sometimes the compiler may realize that and optimize the checks away, but one should not rely on it. If these situations are computation-limited, i.e., a lot of time is spent doing some number crushing for each element, then the performance hit of bound checking will be negligible, and one should not worry about it. On the other hand, if very little work is done per element, then most of the time will be spent iterating from one index to the next and loading the value in the CPU cache, and bound checking can take a significant amount of the total time.

For this reason, the \phypp vector also offers an alternative indexing interface, the \emph{safe} interface, that behaves exactly like the standard interface described above, except that it does not perform bound checking. One may access it using \cppinline{v.safe[i]} for flat indexing, or \cppinline{v.safe(x,y)} for multidimensional indexing, and it can also be used to create views. This interface is not meant to be used in daily coding, but rather for computationally intensive functions that you write once but use many times.
\end{advanced}

\subsection{Operators \label{SEC:core:vec:operator}}

The set of available operators depend on the type of the elements contained in the vector.

\begin{itemize}
\item For arithmetic types (\cppinline{int}, \cppinline{unsigned int}, \cppinline{float} and \cppinline{double}): addition (\cppinline{+}), subtraction (\cppinline{-}), multiplication (\cppinline{*}), division (\cppinline{/}) and (integer types only) modulo (\cppinline{%}).

\item For \cppinline{bool}: and (\cppinline{&&}), or (\cppinline{||}) and negation (\cppinline{!}).

\item For \cppinline{std::string}: concatenation (\cppinline{+}).

\item For all types: less than (\cppinline{<}), less than or equal (\cppinline{<=}), greater than (\cppinline{>}), greather than or equal (\cppinline{>=}), equal (\cppinline{==}) and not equal (\cppinline{!=}).
\end{itemize}

In all cases, the operator overloading allows mixing together vectors of different types (as long as they are convertible one to another) and scalar values.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4};
v + 2; // {3,4,5,6}
v + v; // {2,4,6,8}

vec1s fruits = {"apple", "orange"};
"I ate an "+fruits; // {"I ate an apple", "I ate an orange"}
2+fruits;           // error: no operator found for int + std::string
\end{cppcode}
\end{example}

\section{The view class \label{SEC:core:view}}

The full type of the view class is
\begin{cppcode}
template<std::size_t Dimension, typename ElementType>
struct vec<Dimension,ElementType*>;
//            note the asterisk ^
\end{cppcode}

The public interface of the view class is very similar to that of the normal vector, and we will not repeat it here. There are some important differences though, which are inherent to the goal of this class. In particular, there is no available constructor (you do now create a view yourself, you ask for it from an existing vector that will create it for you), and the \cppinline|resize()| function is not available. Lastly, the view implements \cppinline|concretize()|, differently.

Thanks to their strong similarity, we will not distinguish in the other sections between vectors and views, and will consider views as just another kind of vectors. Indeed, the interface of these two classes has been designed for views to be completely interchangeable with vectors, and vice versa, so that the code of any given function is generally written once and is valid for both types.

\subsection{Member functions \label{SEC:core:view:member_fun}}

\begin{itemize}
\item \cppinline|vec<D,T> vec<D,T*>::concretize() const|

This function creates a new vector out of the elements of this view. The returned vector is completely independent from this view, or the original vector this view is currently pointing to. This function is mostly useful when writing generic functions. Indeed, views are implicitly convertible to normal vectors on assignment (\ref{SEC:core:vec:constructor}).
\end{itemize}

\section{Metaprogramming traits and functions (WIP) \label{SEC:core:meta}}

\begin{warning}
This whole section is more advanced than the rest. It is describing the sets of helper types and metaprogramming functions that one can use to write new functions. It is intended to be followed by readers already familiar with the \phypp library, and with good knowledge of C++ metaprogramming.
\end{warning}


% Functions:

% n_elements

% dim

% element
% first
% last

\chapter{Support libraries \label{SEC:support}}

In this chapter we describe the set of helper functions that are part of the \phypp support library. These functions are not essential to the use of the \phypp library, but are mostly modular components that one may choose to use or not. All the support functions are sorted into broad categories to help you discover new functions and algorithm. Alternatively, if you know the name of a function and would like to read its documentation, an index is available at the end of this document.

Note that, in all this section, the signature of the functions is given in pseudo-code, both for conciseness and readability. In particular, the following rules apply.

\begin{itemize}
\item The presence of the \vectorfuncsym symbol in front of the signature of the function means that this function is also available in a \emph{vectorized} form. This only applies to functions whose first argument is a scalar (i.e., not a vector). In this case, the vectorized form shares the same signature as the original form, but the first argument is promoted to a vector. Calling the vectorized version is the same as writing a loop to call the original version on each element of the vector. If the original function had a return value, the vectorized form returns a vector whose elements are the return value of each call, corresponding to each element of the input vector. The vectorized version can be faster than writing the loop manually.

\begin{example}
\begin{cppcode}
// Suppose this function is marked as vectorized
bool is_odd(uint_t)
// It means that there is another function with the
// same name, but that acts on a vector instead
vec<D,bool> is_odd(vec<D,uint_t>)

// It is used like this
vec1u v = {1,2,3,4,5};
vec1b b = is_odd(v);
// ... and is equivalent to
vec1b b(v.dims);
for (uint_t i : range(v)) {
    b[i] = is_odd(v[i]);
}
\end{cppcode}
\end{example}

\item If the function depends on an external library, the name of this library will be written before the signature, for example if LAPACK is needed you will find the symbol \lapacksym.

\item Template parameters are not declared explicitly. They are always written in uppercase, usually with a single character (e.g., \cppinline{T}, \cppinline{D}), or possibly two (e.g., a letter and a number), but never more. Letters \cppinline{T}, \cppinline{U}, \cppinline{V}, etc.~refer to template \emph{types}, while letters \cppinline{D}, \cppinline{N} or \cppinline{I} refer to template \emph{integers}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void foo(T)
// Corresponding C++ code
template<typename T>
void foo(T);

// Pseudo-code used in this section
void foo(vec<D,T> v, U u)
// Corresponding C++ code
template<std::size_t D, typename T, typename U>
void foo(vec<D,T> v, U u);
\end{cppcode}
\end{example}

\item Template parameters are omitted when not relevant to the description of the function. In this case, it is implicitly assumed that the function will work for any type/value of these template parameters.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
void sort(vec&)
// Corresponding C++ code
template<std::size_t D, typename T>
void sort(vec<D,T>&);
\end{cppcode}
\end{example}

\item There are only two kinds of arguments: input arguments, and input/output arguments. Input arguments are always spelled as plain types, e.g. \cppinline{T}, even if the actual signature of the function uses a constant reference, an r-value reference or a universal reference. The reason is that this implementation choice does not matter to the end user. What matters is the interface. The input/output parameters are always C++ references, e.g. \cppinline{T&}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
vec1u dims(vec)
// Corresponding C++ code could be either
template<std::size_t D, typename T>
vec1u dims(vec<D,T>);
// ... or
template<std::size_t D, typename T>
vec1u dims(const vec<D,T>&);
// The only difference is that the first version will
// always make a copy (or move) of its parameter, while
// the second may not. This optimization choice depends
// on the actual code inside the function, and has no
// consequence on how the function is actually used.
\end{cppcode}
\end{example}

\item The ellipsis \cppinline{...} is used to symbolize a list of multiple arguments whose length can vary depending on the context. These arguments are not spelled out explicitly, but the description of the function must make it clear what they are used for. Optionally, a type may be placed before the ellipsis to indicate that all the arguments must be of this same type.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t flat_id(vec, ...)
// Corresponding C++ code
template<std::size_t D, typename T, typename ... Args>
uint_t flat_id(vec<D,T>, Args&& ...);
\end{cppcode}
\end{example}

\item The \cppinline{std} namespace is omitted for common standard types, like \cppinline{std::string} or \cppinline{std::array}.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t length(string)
// Corresponding C++ code
uint_t length(const std::string&);
\end{cppcode}
\end{example}

\item For the particular case of \cppinline{std::array}, the individual elements inside the array can be named by placing the names inside curly braces after the type of the array.

\begin{example}
\begin{cppcode}
// Pseudo-code used in this section
uint_t distance(array {x,y})
// Corresponding C++ code
template<typename T>
uint_t length(const std::array<T,2>& a) {
    // x := a[0]
    // y := a[1]
}
\end{cppcode}
\end{example}

\item If the return type of a function in pseudo-code is \cppinline{auto}, it means that this return value is ``complex'' (usually a structure or a class) and it is not important to know its precise type. The description of the function must therefore make it clear how this return value can be used.

\end{itemize}

With this in mind, it is clear that this chapter focuses on the \emph{interface} that is provided by the library, rather than on the individual function themselves. In fact, a single interface may be composed of many different functions to take care of all the combination of types that the interface supports. If the reader is interested in all these overloads, or is experiencing a particular compiler error that cannot be easily fixed just by looking at the interface, then it is best to look directly into the code of the library. Although less readable than the pseudo-code used in this document, most of the time an effort is made to make the code as clear as possible. However, if a function is too hard to understand, I consider this as a bug that should be reported on the \texttt{github} issue tracker (seriously). Similarly, if you end up doing something wrong with the library, but that the compiler error message is too cryptic or too long, you may also fill in a bug report. Ensuring that clear error messages are sent to the user is a shared responsibility between compiler writers and library authors.

\section{Generic vector functions \label{SEC:support:generic}}

The vector and view classes are useful and complete tools. However, there are a number of tasks that one repeatedly need to do, like generating a sequence of indices, or sorting a vector, and that would be tedious to write each time they are needed. For this reason, the \phypp library comes with a large set of utility functions to sort, rearrange, and select data inside vectors. In this section we list these functions and algorithms.

This support library also introduces a global constant called \cppinline{npos}\itt{npos}. This is an unsigned integer whose value is the largest possible integer that the \cppinline{uint_t} type can hold. It is meant to be used as an error value, or the value to return if no normal value would make sense. It is very similar in concept to the \cppinline{std::string::npos} provided by the C++ standard library. In particular, it is worth noting that converting \cppinline{npos} to a \emph{signed} integer produces the value \cppinline{-1}.

We now describe the functions provided by this library, sorted by categories.

\subsection{Range-based iteration}

\begin{itemize}
\item \cppinline{auto range(vec v)} \itt{range}

\cppinline{auto range(uint_t n)}

\cppinline{auto range(uint_t i0, uint_t n)}

This function returns a C++ \emph{range}, i.e., an object that can be used inside the C++ range-based \cppinline{for} loop. This range will generate integer values starting from \cppinline{0} (first and second version) or \cppinline{i0} (third version) to \cppinline{v.size()} (first version) or \cppinline{n} (second and third versions), that last value being \emph{excluded} from the range. This nice way of writing an integer \cppinline{for} loop actually runs as fast as (if not faster than) the classical way, and is less error prone.

\begin{example}
\begin{cppcode}
vec1i v = {4,5,6,8};

// First version
for (uint_t i : range(v)) {
    // 'i' goes from 0 to 3
    v[i] = ...;
}

// Note that the loop above generates
// *indices* inside the vector, while:
for (int i : v) { /* ... */ }
// ... generates *values* from the vector.

// Second version
for (uint_t i : range(3)) {
    // 'i' goes from 0 to 2
    v[i] = ...;
}

// Third version
for (uint_t i : range(1,3)) {
    // 'i' goes from 1 to 3
    v[i] = ...;
}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Index manipulation}

\begin{itemize}
\item \cppinline{vec1u mult_ids(vec v, uint_t i)} \itt{mult_ids}

\cppinline{vec1u mult_ids(array<uint_t> dims, uint_t i)}

This is only useful for multidimensional vectors. This function converts a ``flat'' index \cppinline{i} (\ref{SEC:core:vec:indexing}) into an array of multidimensional indices, following the dimensions of the provided vector \cppinline{v} (or, in the second version, following the dimensions \cppinline{dims}). The \cppinline{flat_id} function does the inverse job.

\begin{example}
\begin{cppcode}
vec2i v(2,3);
mult_ids(v,0); // {0,0}
mult_ids(v,1); // {0,1}
mult_ids(v,2); // {0,3}
mult_ids(v,3); // {1,0}
v[3] == v(1,0); // true
\end{cppcode}
\end{example}

\item \cppinline{uint_t flat_id(vec v, ...)} \itt{flat_id}

This is only useful for multidimensional vectors. This function converts a group of multidimensional indices into a ``flat'' index (\ref{SEC:core:vec:indexing}), following the dimensions of the provided vector \cppinline{v}. The \cppinline{mult_ids} function does the inverse job.

\begin{example}
\begin{cppcode}
vec2i v(2,3);
flat_id(v,0,0); // 0
flat_id(v,0,1); // 1
flat_id(v,0,2); // 2
flat_id(v,1,0); // 3
v(1,0) == v[3]; // true
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Integer sequences}

\begin{itemize}
\item \cppinline|vec<D,int_t>  indgen(...)| \itt{indgen}

\cppinline|vec<D,uint_t> uindgen(...)| \itt{uindgen}

\cppinline|vec<D,float>  findgen(...)| \itt{findgen}

\cppinline|vec<D,double> dindgen(...)| \itt{dindgen}

These functions will create a new vector, whose dimensions are specified in argument (like in the dimension constructor, \ref{SEC:core:vec:constructor}, or \cppinline{vec::resize()}, \ref{SEC:core:vec:member_fun}). After this vector is created, the function will fill it with values that start at \cppinline{0} and increment by steps of \cppinline{1} until the end of the vector.

\begin{example}
\begin{cppcode}
vec1i v = indgen(5);    // {0,1,2,3,4}
vec2u w = uindgen(3,2); // {{0,1}, {2,3}, {4,5}}
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Rearranging elements}

\begin{itemize}
\item \cppinline|vec1u sort(vec)| \itt{sort}

\cppinline|void inplace_sort(vec&)| \itt{inplace_sort}

These functions will change the order of the elements inside a given vector so that they are sorted from the smallest to the largest. The difference between the two versions is that \cppinline{sort} does not actually modify the provided vector, but rather returns a vector containing indices inside the provided vector, and \cppinline{inplace_sort} directly modifies the provided vector. The later is the fastest of the two, but it is less powerful.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {1,5,6,3,7};
vec1u id = sort(v); // {0,3,1,2,4}
v[id]; // {1,3,5,6,7} is sorted
// now, id can also be used to modify the order of
// another vector of the same dimensions

// Second version
inplace_sort(v);
v; // {1,3,5,6,7} is sorted
\end{cppcode}
\end{example}

\item \cppinline|bool is_sorted(vec)| \itt{is_sorted}

This function just traverses the whole input vector and checks if its elements are sorted by increasing value.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {1,5,6,3,7};
is_sorted(v); // false
inplace_sort(v);
v; // {1,3,5,6,7}
is_sorted(v); // true
\end{cppcode}
\end{example}

\item \cppinline|vec<1,T> reverse(vec<1,T>)| \itt{reverse}

This function will inverse the order of all the elements inside the provided vector.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5,6};
vec1i w = reverse(v); // {6,5,4,3,2,1}
\end{cppcode}
\end{example}

\item \cppinline|vec<1,T> shift(vec<1,T> v, int_t n, T d = 0)| \itt{shift}

This function will shift the position of the elements inside the provided vector \cppinline{v} by a given amount of indices \cppinline{n}. Elements that would go outside of the bounds of the vector are destroyed. New elements are inserted and default constructed, or assigned the default value \cppinline{d} (optional argument).

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5};
vec1i sr = shift(v, 2);
sr; // {0,0,1,2,3}
vec1i sl = shift(v, -2, 99);
sl; // {3,4,5,99,99};
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Finding elements}

\begin{itemize}
\item \cppinline|vec1u where(vec<D,bool>)| \itt{where}

This function will scan the \cppinline{bool} vector provided in argument, will store the flat indices (\ref{SEC:core:vec:indexing}) of each element which is \cpptrue, and will return all these indices in a vector. This is a very useful tool to filter and selectively modify vectors, and probably one of the most used function of the whole library.

\begin{example}
\begin{cppcode}
vec1i v = {4,8,6,7,5,2,3,9,0};
// We want to select all the elements which are greater than 3
// We use where() to get their indices
vec1u id = where(v > 3); // {0,1,2,3,4,7}
// Now we can check
v[id]; // {4,8,6,7,5,9}, good!

// The argument of where() can by as complex as you want
id = where(v < 3 || (v > 3 && v % 6 < 2)); // now guess

// It can also involve multiple vectors, as long as they have
// the same dimensions
vec1i w = {9,8,6,1,-2,0,8,5,1};
id = where(v > w || (v + w) % 5 == 0);
// The returned indices are valid for both v and w
v[id]; // {8,6,7,5,2,9}
w[id]; // {8,6,1,-2,0,5}
\end{cppcode}
\end{example}

\item \cppinline|vec1u complement(vec v, vec1u id)| \itt{complement}

This function works in tandem with \cppinline{where}. Given a vector \cppinline{v} and a set of flat indices \cppinline{id} (\ref{SEC:core:vec:indexing}), it will return the complementary set of indices inside this vector, i.e., all the indices of \cppinline{v} that are \emph{not} present in \cppinline{id}.

\begin{example}
\begin{cppcode}
vec1i v = {1,5,6,3,7};
vec1u id = where(v > 4); // {1,2,4}
vec1u cid = complement(v, id); // {0,3}
\end{cppcode}
\end{example}

\item \cppinline|uint_t lower_bound(T x, vec v)| \itt{lower_bound}

\cppinline|uint_t upper_bound(T x, vec v)| \itt{upper_bound}

\cppinline|array<uint_t,2> bounds(T x, vec v)| \itt{bounds}

\cppinline|array<uint_t,2> bounds(T x1, U x2, vec v)|

These functions use a binary search algorithm to locate the element in the input vector \cppinline{v} that is equal to or closest to the provided value \cppinline{x}. It is important to note that the binary search assumes that the elements in the input vector are \emph{sorted} by increasing value. This algorithm also assumes that the input vector does not contain any NaN value (\ref{SEC:support:math}).

The \cppinline{lower_bound} function locates the last element in \cppinline{v} that is less or equal to \cppinline{x}. If no such element is found, \cppinline{npos} is returned.

The \cppinline{upper_bound} function locates the first element in \cppinline{v} that is greater than \cppinline{x}. If no such element is found, \cppinline{npos} is returned.

The first \cppinline{bounds} function combines what both \cppinline{lower_bound} and \cppinline{upper_bound} do, and returns both indices in an array. The second \cppinline{bounds} function calls \cppinline{lower_bound} to look for \cppinline{x1}, and \cppinline{upper_bound} to look for \cppinline{x2}.

\begin{example}
\begin{cppcode}
vec1i v = {2,5,9,12,50};
bounds(0, v);   // {npos,0}
bounds(9, v);   // {2,3}
bounds(100, v); // {4,npos}
\end{cppcode}
\end{example}

\item \cppinline|vec1u equal_range(T x, vec v)| \itt{equal_range}

Similarly to \cppinline{lower_bound}, \cppinline{upper_bound} and \cppinline{bounds}, this function uses a binary search algorithm to locate all the values in the input vector \cppinline{v} that are equal to \cppinline{x}. It then returns the flat indices of all these values in a vector. It is important to note that the binary search assumes that the elements in the input vector are \emph{sorted} by increasing value. This algorithm also assumes that the input vector does not contain any NaN value (\ref{SEC:support:math}).

If no such value is found, an empty vector is returned.

\begin{example}
\begin{cppcode}
vec1i v = {2,2,5,9,9,9,12,50};
equal_range(9, v); // {3,4,5}

// It's a faster version of
where(v == 9);
\end{cppcode}
\end{example}

\item \cppinline|vec1u uniq(vec v)| \itt{uniq}

\cppinline|vec1u uniq(vec v, vec1u sid)|

This function will traverse the provided vector \cppinline{v} and find all the unique values. It will store the indices of these values (if a value is present more than once inside \cppinline{v}, the index of the first one will be used) and return them inside an index vector. The first version assumes that the values in \cppinline{v} are \emph{sorted} from the smallest to the largest. In the second version, \cppinline{v} may not be sorted, but the second argument \cppinline{id} contains indices that will sort \cppinline{v} (e.g., \cppinline{id} can be the return value of \cppinline{sort(v)}).

\begin{example}
\begin{cppcode}
// For a sorted vector
vec1i v = {1,1,2,5,5,6,9,9,10};
vec1u u = uniq(v); // {0,2,3,5,6,8}
v[u]; // {1,2,5,6,9,10} only unique values

// For an non-sorted vector
vec1i w = {5,6,7,8,6,5,4,1,2,5};
vec1u u = uniq(w, sort(w));
w[u]; // {1,2,4,5,6,7,8}
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|bool is_any_of(T1 v1, vec<D2,T2> v2)| \itt{is_any_of}

This function looks if there is any value inside \cppinline{v2} that is equal to \cppinline{v1}. If so, it returns \cpptrue, else it returns \cppfalse.

\begin{example}
\begin{cppcode}
vec1i v = {7,4,2,1,6};
vec1i d = {5,6,7};
vec1b b = is_any_of(v, d); // {true, false, false, false, true}
\end{cppcode}
\end{example}

\item \cppinline|void match(vec v1, v2, vec1u& id1, id2)| \itt{match}

This function traverses \cppinline{v1} and, for each value in \cppinline{v1}, looks for elements in \cppinline{v2} that have the same value. If one is found, the flat index of the element of \cppinline{v1} is added to \cppinline{id1}, and the flat index of the element of \cppinline{v2} is added to \cppinline{id2}. Then the function goes on to the next value in \cppinline{v1}. Note that, contrary to \cppinline{match_dictionary}, each value in \cppinline{v1} is matched to \emph{at most} one value in \cppinline{v2}, and vice versa. In other words, if \cppinline{v1} or \cppinline{v2} contain duplicates, only the first value will be matched and the others will be ignored. This function is symmetric: the result will be the same if you swap the two input vectors (of course, the output vectors have to be swapped also).

\begin{example}
\begin{cppcode}
vec1i v = {7,4,2,1,6};
vec1i w = {2,6,5,3};
vec1u id1, id2;
match(v, w, id1, id2);
id1; // {2,4}
id2; // {0,1}
v[id1] == w[id2]; // always true
\end{cppcode}
\end{example}

\item \cppinline|void match_dictionary(vec v1, v2, vec1u& id1, id2)| \itt{match_dictionary}

This function traverses \cppinline{v1} and, for each value in \cppinline{v1}, looks for an element in \cppinline{v2} that has the same value. If one is found, the flat index of the element of \cppinline{v1} is added to \cppinline{id1}, and the flat index of the element of \cppinline{v2} is added to \cppinline{id2}. Then the function goes on to the next value in \cppinline{v1}. Contrary to \cppinline{match}, each value in \cppinline{v2} can be matched to multiple values in \cppinline{v1}. Therefore this function is not symmetric: the second vector should be considered as a ``dictionary'', hence the name of this function. It is assumed that \cppinline{v2} does not contain any duplicates.

\begin{example}
\begin{cppcode}
vec1i v = {7,6,2,1,6};
vec1i w = {2,6,5,3};
vec1u id1, id2;
match_dictionary(v, w, id1, id2);
id1; // {1,2,4}
id2; // {1,0,1}
v[id1] == w[id2]; // always true
\end{cppcode}
\end{example}

\item \cppinline|bool astar_find(vec2b m, uint_t& x, y)| \itt{astar_find}

This function uses the $A^\star$ (``A star'') algorithm to look inside a 2D boolean map \cppinline{m} and, starting from the position \cppinline{x} and \cppinline{y} (i.e. \cppinline{m(x,y)}), find the closest point that has a value of \cpptrue. Once this position is found, its indices are stored inside \cppinline{x} and \cppinline{y}, and the function returns \cpptrue. If no element inside \cppinline{m} is \cpptrue, then the function returns \cppfalse.

\begin{example}
\begin{cppcode}
// Using '@' for true and '.' for false,
// assume we have the following boolean map,
// and that we start at the position indicated
// by 'S', the closest point whose coordinates
// will be returned by astar_find is indicated
// by an 'X'
vec2b m;
// .................
// .................
// .................
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@@.........
// ...@@@@X.........
// .............S...
// .................
// .................

uint_t x = 13, y = 2;
astar_find(m, x, y);
x; // 7
y; // 3
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Modifying dimensions}

\begin{itemize}
\item \cppinline|vec<1,T> flatten(vec<D,T>)| \itt{flatten}

This function transforms a multidimensional vector into a monodimensional vector. The content in memory is exactly the same, so the operation is fast. In particular, if the argument of this function is a temporary, this function is extremely cheap as it produces no copy. The \cppinline{reform} function does the inverse job, and more.

\begin{example}
\begin{cppcode}
vec2i v = {{1,2,3}, {4,5,6}};
vec1i w = flatten(v); // {1,2,3,4,5,6}
\end{cppcode}
\end{example}

\item \cppinline|vec<D1,T> reform(vec<D2,T>, ...)| \itt{reform}

This function transforms a vector into another vector just by changing its dimensions. The content in memory is exactly the same, so the operation is fast. In particular, if the argument of this function is a temporary, this function is extremely cheap as it produces no copy. However, the new dimensions have to generate the same number of elements as the provided vector contains. The \cppinline{flatten} function is a special case of \cppinline{reform}.

\begin{example}
\begin{cppcode}
vec1i v = {1,2,3,4,5,6};
vec2i w = reform(v, 2, 3); // {{1,2,3}, {4,5,6}}
\end{cppcode}
\end{example}

\item \cppinline|vec<N,T>   replicate(T, ...)| \itt{replicate}

      \cppinline|vec<D+N,T> replicate(vec<D,T>, ...)|

This function will take the provided scalar (first version) or vector (second version), and replicate it multiple times according to the provided additional parameters, to generate additional dimensions.

\begin{example}
\begin{cppcode}
// First version
vec1i v = replicate(2, 5);
v; // {2,2,2,2,2} 5 times 2
vec2i w = replicate(2, 3, 2);
w; // {{2,2},{2,2},{2,2}} 3 x 2 times 2

// Second version
vec2i z = replicate(vec1i{1,2}, 3);
z; // {{1,2},{1,2},{1,2}} 3 times {1,2}
// Note that it is not possible to just use a plain initializer list
vec2i z = replicate({1,2}, 3); // error, unfortunately
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Adding/removing elements}

\begin{itemize}
\item \cppinline|vec<1,T> remove(vec<1,T> v, vec1u id)| \itt{remove}

\cppinline|void inplace_remove(vec<1,T>& v, vec1u id)| \itt{inplace_remove}

These functions will remove the elements in \cppinline{v} that have their indices in \cppinline{id}. The only difference between the first and the second version is that the former will first make a copy of the provided vector, remove elements inside this copy, and return it. The second version modifies directly the provided vector, and is therefore faster.

\begin{example}
\begin{cppcode}
// First version
vec1i v = {4,5,2,8,1};
vec1i w = remove(v, {1,3}); // {4,2,1}

// Second version
inplace_remove(v, {1,3});
v; // {4,2,1}
\end{cppcode}
\end{example}

\item \cppinline|void append<N>(vec<D,T1>& t1, vec<D,T2> t2)| \itt{append}

\cppinline|void append(vec<1,T1>& t1, vec<1,T2> t2)|

\cppinline|void prepend<N>(vec<D,T1>& t1, vec<D,T2> t2)| \itt{prepend}

\cppinline|void prepend(vec<1,T1>& t1, vec<1,T2> t2)|

These functions behave similarly to \cppinline{vec::push_back}, in that they will add new elements at the end (\cppinline{append}), but also at the beginning (\cppinline{prepend}) of the provided vector. However, when \cppinline{vec::push_back} can only add new elements from a vector that is one dimension less than the original vector (or a scalar, for monodimensional vectors), these functions will add new elements from a vector of the \emph{same} dimension. These functions are also more powerful than \cppinline{vec::push_back}, because they allow you to choose along which dimension the new elements will be added, through the template parameter \cppinline{N} (note that this parameter is useless and therefore does not exist for monodimensional vectors). The other dimensions must be identical. They are clearly dedicated to a more advanced usage.

\begin{example}
\begin{cppcode}
// For monodimensional vectors
vec1i v = {1,2,3};
vec1i w = {4,5,6};
append(v, w);
v; // {1,2,3,4,5,6}
prepend(v, w);
v; // {4,5,6,1,2,3,4,5,6}

// For multidimensional vectors
vec2i x = {{1,2}, {3,4}};         // x is (2x2)
vec2i y = {{0}, {0}};             // y is (1x2)
vec2i z = {{5,6,7}};              // z is (3x1)
append<1>(x, y);
x; // {{1,2,0}, {3,4,0}}          // x is (2x3)
prepend<0>(x, z);
x; // {{5,6,7}, {1,2,0}, {3,4,0}} // x is (3x3)
\end{cppcode}
\end{example}
\end{itemize}

\subsection{Error checking}

\begin{itemize}
\item \cppinline|void phypp_check(bool b, ...)| \itt{phypp_check}

This function makes error checking easier. When called, it checks the value of \cppinline{b}. If \cppinline{b} is \cpptrue, then nothing happens. However if \cppinline{b} is \cppfalse, then the current file and line are printed to the standard output, followed by the other arguments of this function (they are supposed to be an error message explaining what went wrong), and an assertion is raised, immediately stopping the program. This function is used everywhere in the \phypp library to make sure that certain conditions are properly satisfied before doing a calculation, and it is essential to make the program crash in case something is unexpected (rather than letting it run hoping for the best, and often getting the worst).

Since this function is actually implemented by a preprocessor macro, you should not worry about its performance impact. It will only affect the performances when something goes wrong and the program is about to crash. However the calculation of \cppinline{b} can itself be costly (for example, you may want to check that a vector is sorted), and there is no way around this.

\begin{example}
\begin{cppcode}
vec1i v;
// Suppose v is read from the command line arguments.
v = read_from_somewhere();

// The following code needs at least 3 elements in the
// vector v, so we need to check that first.
phypp_check(v.size() >= 3, "this algorithm needs at least "
    "3 values in the input vector, but only ", v.size(),
    " were found");

// If we get past this point, then v has the right number
// of elements, and we can proceed
do_stuff(v);
\end{cppcode}
\end{example}
\end{itemize}

\section{Parsing command line arguments \label{SEC:support:cmd}}
% argv.hpp

\begin{itemize}
\item \cppinline|void read_args(int argc, char* argv[], ...)| \itt{read_args}
\end{itemize}

The biggest problem of C++ programs is that, while they are usually fast to execute, they can take a long time to \emph{compile}. For this reason, C++ is generally not a productive language in situations where the code has to be written by \emph{trial and error}, a process that involves frequently changing the behavior or starting point of a program. This situation could change the day we have a complete, robust and efficient C++ interpreter (keep an eye out for \texttt{cling}\footnote{\url{http://root.cern.ch/drupal/content/cling}}).

Fortunately, in the mean time there are ways around this issue. One in particular is called \emph{data driven} programming: the behavior of a program depends on the data that are fed to it. The simplest way to use this paradigm is to control the program through \emph{command line arguments}. The C++ language provides the basic bricks to use command line arguments, but the interface is inherited from C and lacks severely in usability. For this reason we introduce in \phypp a single function \cppinline{read_args()} that uses these bricks to provide a simple and concise interface to implement command line arguments in a program. The details of the implementation are complex, since this function makes use of preprocessor macros, so instead of describing it all, we will focus on a simple example.

Let us assume that we want to build a simple program that will print (\ref{SEC:support:print}) to the terminal the first \cppinline{n} powers of two.

\begin{example}
\begin{cppcode}
// This is the standard entry point of every C++ program.
// The signature of the main function is imposed by the C++ standard
int main(int argc, char* argv[]) {
    // Declare the main parameters of the program

    // The number of powers of two to display
    uint_t n = 1;

    // Then read command line arguments...
    read_args(argc, argv, arg_list(n));

    // - The first two arguments must be the arguments of the main
    //   function, in the exact same order.
    // - The following argument must be arg_list(...).

    // Within the arg_list(), one can put as many C++ variables as
    // needed. The function will recognize their name, and will try
    // to find a command line argument that matches.
    // If it finds one, it tries to convert its value into the type
    // of the variable, and if successful, store this new value
    // inside the variable. In all other cases, the variable is not
    // modified.
    // It is therefore important to give a meaningful default value
    // to each variable!

    // Now we can go on with the program
    print(pow(2.0, findgen(n)+1));

    // And quit gracefully
    return 0;
}
\end{cppcode}
\end{example}

By just adding this line
\begin{cppcode}
    read_args(argc, argv, arg_list(n));
\end{cppcode}
we exposed the variable \cppinline{n} to the public: everyone that runs this program can modify the value of \cppinline{n} to suit their need. Assuming the name of the compiled program is \cppinline{show_pow2}, then the program is ran the following way:

\begin{bashcode}
# First try with no parameter.
# 'n' is not modified, and keeps its default value of 1.
./show_pow2
# output:
# 2

# Then we change 'n' to 5.
./show_pow2 n=5
# output:
# 2 4 8 16 32
\end{bashcode}

You immediately see the interest of this approach. Instead of recompiling the whole program just to change \cppinline{n}, we expose it in the program arguments. We can then compile the program once, and change its behavior without recompiling. This saves a lot of time when trying to figure out what is the best value of a parameter in a given problem, or if we have created an algorithm that depends on some parameters, and we want to see how the results change when we change the values of these parameters. And of course, this is most useful when writing \emph{tools} (see, e.g., the tools presented in Chapter \ref{SEC:tool}).

In the previous example, we chose to expose a simple integer. But in fact, the interface also allows virtually any type, provided that there is a way to convert a string into a value of this type. In particular, this is the case for vectors. There is a little subtlety though: the values of the vector must be separated by commas, \emph{without any space} (unless you put the whole argument inside quotes), and surrounded by brackets \cppinline{[...]}. Again, let us illustrate this with an example. We will modify the previous program to allow it to show not only powers of $2$, but the powers of multiple, arbitrary numbers. Note: in the following, we will not repeat the whole \cppinline{main()} function, just the important bits.

\begin{example}
\begin{cppcode}
    // The number of powers of two to display
    uint_t n = 1;
    // The powers to display
    vec1f p = {2};

    // Read command line arguments
    read_args(argc, argv, arg_list(n, p));

    // Go on with the program
    for (float v : p) {
        print(pow(v, findgen(n)+1));
    }
\end{cppcode}
\end{example}

The program can now change the powers it displays, for example
\begin{bashcode}
# We keep 'n' equal to 5, and we show the powers of 2, 3 and 5.
./show_pow2 n=5 p=[2,3,5]
# output:
# 2 4 8 16 32
# 3 9 27 81 243
# 5 25 125 625 3125
\end{bashcode}

Finally, you may think that \cppinline{p} is not a very explicit name for this last parameter. It would be clearer if we could call it \cppinline{pow}. Unfortunately, \cppinline{pow} is already the name of a function in C++, so we cannot give this name to the variable. However, the \cppinline{read_args()} interface allows you to manually give a name to any parameter using the \cppinline{name()} function. Let us do that and modify the previous example.

\begin{example}
\begin{cppcode}
    // The number of powers of two to display
    uint_t n = 1;
    // The powers to display, we still call it 'p' in the program
    vec1f p = {2};

    // Read command line arguments
    read_args(argc, argv, arg_list(n, name(p, "pow"));

    // Go on with the program
    for (float v : p) {
        print(pow(v, findgen(n)+1));
    }
\end{cppcode}
\end{example}

Now we will call instead
\begin{bashcode}
./show_pow2 n=5 pow=[2,3,5]
# output:
# 2 4 8 16 32
# 3 9 27 81 243
# 5 25 125 625 3125
\end{bashcode}

\section{File input/output \label{SEC:support:file}}
% file.hpp

\subsection{File system \label{SEC:support:file:system}}

This section describes the function provided by the \phypp library that are related to file system management, i.e., getting informations, creating or copying files and directories. All paths can be either absolute, or relative to the working directory.

\begin{itemize}
\item \vectorfunc \cppinline|bool file::exists(string)| \itt{file::exists}

This function returns \cpptrue if the path given in argument corresponds to a file or directory that actually exists on the disk, and \cppfalse otherwise.

\begin{example}
\begin{cppcode}
bool b = file::exists("~/.phypprc");
b; // hopefully true

b = file::exists("/i/do/not/exist");
b; // probably false
\end{cppcode}
\end{example}

\item \cppinline|bool file::is_older(string f1, string f2)| \itt{file::is_older}

This function returns \cpptrue if the file or directory \cppinline{f1} is \emph{older} than the file or directory \cppinline{f2}. The age of a file corresponds to the time spent since the files were last modified. If one of the two files does not exists, the function returns \cppfalse.

\begin{example}
\begin{cppcode}
bool b = file::is_older("~/.phypprc", "/usr/bin/cp");
b; // probably false
\end{cppcode}
\end{example}

\item \cppinline|vec1s file::list_directories(string)| \itt{file::list_directories}

This function scans the directory given in argument and returns the list of all directories it contains. An empty list is returned if no directory is found, or if the directory in argument does not exists. The function does not look inside sub-directories. The output list is ordered alphabetically. Lastly, the path given in argument can contain wildcard characters \cppinline{*}, like in \texttt{bash}, to filter out the output list.

\begin{example}
\begin{cppcode}
vec1s d = file::list_directories("/path/to/phypp/");
d; // {"bin", "cmake", "doc", "include", "test", "tools"}

d = file::list_directories("/path/to/phypp/t*");
d; // {"test", "tools"}
\end{cppcode}
\end{example}

\item \cppinline|vec1s file::list_files(string)| \itt{file::list_files}

This function scans the directory given in argument and returns the list of all files it contains (excluding directories). An empty list is returned if no file is found, or if the directory in argument does not exists. The function does not look inside sub-directories. The output list is ordered alphabetically. Lastly, the path given in argument can contain wildcard characters \cppinline{*}, like in \texttt{bash}, to filter out the output list.

\begin{example}
\begin{cppcode}
vec1s d = file::list_files("/path/to/phypp/doc");
d; // {"compile.sh", "phypp.pdf", "phypp.tex"}

d = file::list_files("/path/to/phypp/doc/*.tex");
d; // {"phypp.tex"}
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|string file::directorize(string)| \itt{file::directorize}

This function modifies the path given in argument to make sure that it can be used as a directory, i.e.~in UNIX systems it makes sure that it ends with a forward slash \cppinline{/}. The goal is to produce a directory path that can be appended the base name of a file to form a valid file path.

\begin{example}
\begin{cppcode}
std::string p = file::directorize("/some/path");
p; // "/some/path/"

p = file::directorize("/another/path/");
p; // "/another/path/"
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|string file::get_basename(string)| \itt{file::get_basename}

This function extracts the name of a file from its full path given in argument. If this path is that of a directory, the function returns the name of this directory. This behavior is similar to the \texttt{bash} function \texttt{basename}.

\begin{example}
\begin{cppcode}
std::string n = file::get_basename("/some/path");
n; // "path"

n = file::get_basename("/another/path/to/a/file.txt");
n; // "file.txt"
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|string file::get_directory(string)| \itt{file::get_directory}

This function extracts the path of the directory that contains the file given in argument. If the path in argument is that of a directory, the function returns the path of its parent directory. This behavior is similar to the \texttt{bash} function \texttt{dirname}, except that the returned path ends with a forward slash \cppinline{/}.

\begin{example}
\begin{cppcode}
std::string n = file::get_directory("/some/path");
n; // "/some/"

n = file::get_directory("/another/path/to/a/file.txt");
n; // "/another/path/to/a/"
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|bool file::mkdir(string)| \itt{file::mkdir}

This function creates a new directory whose path is given in argument and returns \cpptrue. If the directory could not be created (e.g., because of permission issues), the function returns \cppfalse. If the directory already exists, the function does nothing and returns \cpptrue.

\begin{example}
\begin{cppcode}
bool b = file::mkdir("/path/to/phypp/a/new/directory");
// Will most likely create the directories:
//  - /path/to/phypp/a
//  - /path/to/phypp/a/new
//  - /path/to/phypp/a/new/directory
b; // maybe true or false, depending on your permissions
\end{cppcode}
\end{example}

\end{itemize}

\subsection{ASCII table input/output \label{SEC:support:file:ascii}}

\begin{itemize}
\item \cppinline|void file::read_table(string f, uint_t s, ...)| \itt{file::read_table}

This function reads the content of the ASCII table \cppinline{f} and stores the data inside vectors. The second argument \cppinline{s} gives the number of lines to skip before starting reading data: this is useful to ignore the lines that correspond to the header of the table. Note that, due to the lack of standard formatting for the header, there is no automatic way to ignore these lines.

The vectors in which the data should be stored are given in argument, one after the other. Each column of the file will be stored in a different vector, in the order in which they are provided to the function. If there is more columns than vectors, the extra columns are ignored. If there is more vectors than columns, the program will stop and report an error.

Columns in the file can be separated by any number of spaces and tabulations. While this is better for human readability, columns need not be aligned to be read by this function. However, ``holes'' in the table are not supported, i.e., rows that only have data for some columns but not all. If such a situation is encountered, the ``hole'' is considered as white spaces and ignored, and the data from this column is actually read from the next one. This will make the function report and error only if all columns of the file are read. For this reason, it is advised to always read all the columns of a given file, even those that are not used (see below for an efficient way to do that). The table may contain empty lines however, they will simply be ignored.

Regarding the type of the data. ASCII tables are not strongly typed: as long as the data in the table can be converted to a value of its corresponding vector, this function will be able to read it. There are particular rules though:
\begin{itemize}
\item Strings may not contain spaces (since they will be understood as column separators). Adding quotes \cppinline{"..."} will \emph{not} change that.
\item Floating point columns can contain special values such as NaN or the infinity. These can be spelled \cppinline{nan}, \cppinline{+nan}, \cppinline{-nan}, \cppinline{+inf}, \cppinline{-inf}, \cppinline{inf}, \cppinline{inf+} or \cppinline{inf-} (case does not matter). The special value \cppinline{null} is also accepted and means zero. Both fixed point and scientific notation is allowed.
\item In general for arithmetic data, if the value to be read is too large to fit in the corresponding C++ variable, the program will stop report the error. This will happen for example is trying to read a number like \cppinline{1e128} inside a \cppinline{float} vector. Use a larger data type to fix this (e.g.~\cppinline{double} in this particular case).
\end{itemize}

In the following examples, we will parse a table which contains the following columns:
\begin{bashcode}
#  - source ID              (integer)
#  - right ascension        (double)
#  - declination            (double)
#  - badpixel flag          (integer)
#  - contamination flag     (integer)
#  - cov   24               (float)
#  - cov   160              (float)
#  - flux  24               (float)
#  - error 24               (float)
#  - flux  160              (float)
#  - error 160              (float)
\end{bashcode}
This is the header of the table, and it contains \cppinline{11} lines that should be ignored.

Here is how to read the first three columns:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec // read three columns
);
\end{cppcode}

The placeholder character \cppinline{_} can be used in the argument list to skip a given column. Let's say we want to read the \cppinline{contamination} flag, but we don't care about the \cppinline{badpixel} flag. We can write:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;
vec1u contam;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec, // read three columns
    _, contam    // ignore one column, and read one column
);
\end{cppcode}

Lastly, the \cppinline{file::columns(n, ...)} function can be used to group several columns and repeat \cppinline{n} times the same extraction pattern. This can be used to read multiple columns inside a single two-dimensional vector. Let's say we want now to read the data from \texttt{cov24} and \texttt{cov160} in a single vector:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;
vec1u contam;
vec2f cov;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec, // read three columns
    _, contam,   // ignore one column, and read one column
    file::columns(2, cov) // read two columns in one vector
);
cov(_,0); // contains data from "cov 24"
cov(_,1); // contains data from "cov 160"
\end{cppcode}

The \cppinline{file::columns(n, ...)} function can also be used to ignore multiple columns at a time. Let's say we don't want to read the \cppinline{contamination} flag anymore, so we need to skip two consecutive columns. We could write ``\cppinline{_, _}'', but this becomes tedious and error prone when many columns are to be ignored. Instead, we can write:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;
vec2f cov;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec,          // read three columns
    file::columns(2, _),  // ignore two columns
    file::columns(2, cov) // read two columns in one vector
);
\end{cppcode}

The \cppinline{file::columns(n, ...)} function can also be used to read consecutive groups of columns with a given pattern. Let's say we now want to read the \cppinline{flux} and \cppinline{error} inside their respective two-dimensional vectors. The pattern here is ``\cppinline{flux}, \cppinline{error}, \cppinline{flux}, \cppinline{error}, ...''. We can parse this using:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;
vec2f cov, flux, err;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec,           // read three columns
    file::columns(2, _),   // ignore two columns
    file::columns(2, cov), // read two columns in one vector
    file::columns(2, flux, err) // read (flux,err,flux,err)
);
\end{cppcode}

Finally, note that it is possible to mix together vectors and \cppinline{_} in this pattern. Imagine we just want to read the \cppinline{flux} columns and ignore the \cppinline{errors}. We can write:
\begin{cppcode}
// First declare the vectors and their types
vec1u id;
vec1d ra, dec;
vec2f cov, flux;

// Then read the data
file::read_table("some/ascii_table.dat", 11,
    id, ra, dec,           // read three columns
    file::columns(2, _),   // ignore two columns
    file::columns(2, cov), // read two columns in one vector
    file::columns(2, flux, _) // read (flux,_,flux,_)
);
\end{cppcode}

\item \cppinline|void file::write_table(string f, uint_t w, ...)| \itt{file::write_table}

\cppinline|void file::write_table_csv(string f, uint_t w, ...)| \itt{file::write_table_csv}

\cppinline|void file::write_table_hdr(string f, uint_t w, ...)| \itt{file::write_table_hdr}

This collection of functions will write the data contained inside one of multiple vectors into a file \cppinline{f}, in human-readable ``ASCII'' format\footnote{This is simple and convenient for small files, but if the volume of data is huge, consider instead using binary FITS files (\ref{SEC:support:fits:table}). This will be both faster to read and write, and will also occupy less space on your disk.}. The data is written in separate columns, with a fixed width of \cppinline{w} characters. Spaces are used to fill the empty space between columns.

The first two functions in the list will just write all the data, and nothing else. The difference between the two is that the second version uses the ``CSV'' format (comma-separated values), i.e., appends a comma after each value. Apart from this, the functions behave the same: after the column width \cppinline{w}, the following arguments can be any number of 1D vectors. They must contain the same number of elements. 2D vectors are also allowed, in which case, by convention, the first dimension is considered as the ``row'' dimension, and the second is the ``column'' dimension.

Note that this function will only create the \emph{file}. If the path \cppinline{f} given in argument contains directories that do not exist, the function will fail. You have to create them yourself beforehand.

For example, imagine we want to save the following data into a file:
\begin{cppcode}
// Some arbitrary data
vec1u id = {1,2,3,4,5};
vec1i x = {125,568,9852,12,-51};
vec1i y = {-56,157,2,99,1024};
vec2f flux(5,2);
flux(_,0) = {0.0, 1.2, 5.6, 9.5, 1.5};
flux(_,1) = {9.6, 0.0, 4.5, 0.0, 0.0};
\end{cppcode}

We can use this function to create an ASCII table with columns that are \cppinline{8} characters wide:
\begin{cppcode}
// Write these in a file
file::write_table("some/path/to/a_table.dat", 8,
    id, x, y, flux
);
\end{cppcode}

The content of the file will be:
\begin{bashcode}
       1     125     -56       0     9.6
       2     568     157     1.2       0
       3    9852       2     5.6     4.5
       4      12      99     9.5       0
       5     -51    1024     1.5       0
\end{bashcode}

Sometimes it is desirable to also add some information in the file about what kind of data is stored in each column. This is usually done with a \emph{header}, i.e., a couple of lines at the beginning of the file containing information about what the file contains, among other things. This can be done easily using the third function in the list above, \cppinline{file::write_table_hdr()}. Usage is fairly simple:
\begin{cppcode}
// Write these in a file
file::write_table_hdr("some/path/to/a_table.dat", 8,
    {"id", "x", "y", "flux_1", "flux_2"},
    id, x, y, flux
);
\end{cppcode}

The resulting file is:
\begin{bashcode}
#     id       x       y  flux_1  flux_2
#
       1     125     -56       0     9.6
       2     568     157     1.2       0
       3    9852       2     5.6     4.5
       4      12      99     9.5       0
       5     -51    1024     1.5       0
\end{bashcode}

However it can be tedious to write the name of the columns manually, especially when they match closely the names of the vectors in the C++ code. For this reason, another way to write the above file is to use an alternative version of this function and the \cppinline{ftable()} macro:
\begin{cppcode}
// Write these in a file
file::write_table_hdr("some/path/to/a_table.dat", 8,
    ftable(id, x, y, flux)
);
\end{cppcode}

This will take the C++ name of the variables and will use them directly as column names. For 2D vectors, ``\cppinline{_i}'' is appended to the name of the vector for each column \cppinline{i}. If you need better looking headers, you will have to write them manually using the previous signature.

Finally, if you want to fine tune the way a particular column is written in the file, for example if you want to use scientific notation, you can perform the conversion to string yourself (\ref{SEC:support:string:convert}), and feed string vectors to this function.

\end{itemize}

\section{String manipulation \label{SEC:support:string}}
% string.hpp

\subsection{String conversions \label{SEC:support:string:convert}}

\begin{itemize}
\item \cppinline|string strn(T v)| \itt{strn}

\cppinline|string strn_sci(T v)| \itt{strn_sci}

These functions will convert the value \cppinline{v} into a string. This value can be of any type, as long as it is convertible to string. In particular, \cppinline{v} can be a vector, in which case the output string will contain all the values of the vector, separated by commas, and enclosed inside curly braces \cppinline{"{...}"}.

\begin{example}
\begin{cppcode}
strn(2);            // "2"
strn(true);         // "1"
strn("foo");        // "foo"
strn(vec1i{2,5,9}); // "{2, 5, 9}"
\end{cppcode}
\end{example}

The second version is dedicated to floating point numbers, and will output them in scientific format.

\begin{example}
\begin{cppcode}
strn_sci(2.0);    // "2.000000e+00"
strn_sci(2e10);   // "2.000000e+10"
strn_sci(-5e-2);  // "-5.000000e-02"

// Integer numbers are not affected
strn_sci(1000);   // "1000"
strn_sci(1000.0); // "1.000000e+03"
\end{cppcode}
\end{example}

\item \cppinline|vec_<D,string> strna(vec<D,T>)| \itt{strna}

\cppinline|vec_<D,string> strna_sci(vec<D,T> v)| \itt{strna_sci}

These functions are the vectorized version of \cppinline{strn} (see above). The reason why the name of the function is different is because it is already possible to call \cppinline{strn} with vector arguments: the whole vector will be converted into a \emph{single} string. These versions however convert each element separately to form a vector of strings.

\begin{example}
\begin{cppcode}
strna(vec1i{1,5,6,9}); // {"1", "5", "6", "9"}
strn(vec1i{1,5,6,9});  // "{1, 5, 6, 9}"
\end{cppcode}
\end{example}

\item \vectorfunc \cppinline|bool from_string(string s, T& v)| \itt{from_string}

This function tries to convert the string \cppinline{s} into a C++ value \cppinline{v} and returns \cpptrue in case of success. If the string cannot be converted into this value, for example if the string contains letters and the value has an arithmetic type, or if the number inside the string is too big to fit inside the C++ value, the function will return \cppfalse. In this case, the value of \cppinline{v} is not modified.

The vectorized version of this function will try to convert every value inside the string vector \cppinline{s}, and will store the converted values inside the vector \cppinline{v} (it will take care or properly resizing the vector, so you can pass an empty vector if you want). The return value will then be an array of boolean values, corresponding to the success or failure of each individual value inside \cppinline{s}. If an element of \cppinline{s} fails to convert, the corresponding value in \cppinline{v} will be default-initialized (e.g., zero for numbers).

\begin{example}
\begin{cppcode}
float f;
bool b = from_string("3.1415", f);
b; // true
f; // 3.1415

b = from_string("abcdef", f);
b; // false;
f; // 3.1415, 'f' has not been modified

vec1f fs;
vec1b bs = from_string({"1", "15", "abc", "1e128", "2.5"}, fs);
bs; // {true, true, false, false, true}
fs; // {1,    15,   0,     0,     2.5}
\end{cppcode}
\end{example}

\end{itemize}

\subsection{String operations \label{SEC:support:string:modify}}

\begin{itemize}
\item \vectorfunc \cppinline|bool empty(string s)| \itt{empty}
\item \vectorfunc \cppinline|uint_t length(string s)| \itt{length}

\item \vectorfunc \cppinline|string trim(string s, c)| \itt{trim}

\item \vectorfunc \cppinline|string toupper(string s)| \itt{toupper}

\item \vectorfunc \cppinline|string tolower(string s)| \itt{tolower}

\item \vectorfunc \cppinline|string replace(string s, p, r)| \itt{replace}

\item \cppinline|vec1s split(string s, p)| \itt{split}

\item \cppinline|vec1s cut(string s, uint_t n)| \itt{cut}

\item \cppinline|vec1s wrap(string s, uint_t w, string i = "", bool e = false)| \itt{wrap}

\item \cppinline|string collapse(vec<D,string>)| \itt{collapse}

\cppinline|string collapse(vec<D,string> v, string s)|

\item \vectorfunc \cppinline|uint_t find(string s, p)| \itt{find}

\item \vectorfunc \cppinline|bool match(string s, r)| \itt{match}

\vectorfunc \cppinline|bool match_any_of(string s, vec1s r)| \itt{match_any_of}

\item \vectorfunc \cppinline|bool start_with(string s, string p)| \itt{start_with}

\vectorfunc \cppinline|bool end_with(string s, string p)| \itt{end_with}

\item \vectorfunc \cppinline|string erase_begin(string s, string p)| \itt{erase_begin}

\vectorfunc \cppinline|string erase_begin(string s, uint_t n)|

\vectorfunc \cppinline|string erase_end(string s, string p)| \itt{erase_end}

\vectorfunc \cppinline|string erase_end(string s, uint_t n)|

\item \vectorfunc \cppinline|string keep_start(string s, uint_t n = 1)| \itt{keep_start}

\vectorfunc \cppinline|string keep_end(string s, uint_t n = 1)| \itt{keep_end}

\item\vectorfunc  \cppinline|string remove_extension(string)| \itt{remove_extension}

\item \vectorfunc \cppinline|string align_left(string s, uint_t w, char f = ' ')| \itt{align_left}

\vectorfunc \cppinline|string align_center(string s, uint_t w, char f = ' ')| \itt{align_center}

\vectorfunc \cppinline|string align_right(string s, uint_t w, char f = ' ')| \itt{align_right}

\item \vectorfunc \cppinline|uint_t distance(string s1, s2)| \itt{distance}
\end{itemize}

\section{OS interaction \label{SEC:support:os}}

\begin{itemize}

\item \cppinline|string system_var(string v, string d = "")| \itt{system_var}

\end{itemize}

\section{Printing to the terminal \label{SEC:support:print}}
% print.hpp

\begin{itemize}

\item \cppinline|void print(...)| \itt{print}

\cppinline|void error(...)| \itt{error}

\cppinline|void warning(...)| \itt{warning}

\cppinline|void note(...)| \itt{note}

\item \cppinline|bool prompt(string msg, T& v, string err = "")

\end{itemize}

\section{Measuring time \label{SEC:support:time}}
% time.hpp

\begin{itemize}

\item \cppinline|double now()| \itt{now}

\item \cppinline|string today()| \itt{today}

\item \cppinline|string time_str(double)| \itt{time_str}

\item \cppinline|string seconds_str(double)| \itt{seconds_str}

\item \cppinline|auto progress_start(uint_t)| \itt{progress_start}

\cppinline|void progress(auto p, uint_t m)| \itt{progress}

\cppinline|void print_progress(auto p, T i, uint_t m)| \itt{print_progress}

\end{itemize}

\section{Mathematics \label{SEC:support:math}}
% math.hpp
% mpfit.hpp

The mathematics support library is among the largest inside \phypp. It contains many functions, as well as a handful of useful constants. Some functionalities of this library are only available if you have installed the \texttt{fftw} and \texttt{gsl} libraries. If not, the specific functions that depend on these libraries will not be available, or will be slow, but the rest of the library will function properly.

This library provides the following global constants:
\begin{itemize}
\item \cppinline{fnan}\itt{fnan} and \cppinline{dnan}\itt{dnan}. These are the \cppinline{float} and \cppinline{double} representation of the ``not-a-number'' (NaN) special value. This value is returned by some operations that are mathematically undefined in the real domain. For example, dividing zero by zero, or taking the square root of a negative number. NaN has some very peculiar properties that can surprise the newcomer. In particular, it propagates extremely fast, since any operation involving at least a NaN value will always return NaN, e.g., \cppinline{2.0 + fnan == fnan}). More troubling, any comparison operation involving a NaN will return \cppfalse, e.g., \cppinline{(10.0 < fnan) == false} and \cppinline{(10.0 >= fnan) == false} too. The only notable exception to this rule is that \cppinline{(fnan != fnan) == true}. Knowing this, NaN is a very useful return value to indicate that giving an actual value would not make sense. For example, in a galaxy catalog, some galaxies may have been observed at a certain wavelength, but not all of them. For those that are not observed, we do not know their flux. In this case, astronomers typically assign them a special, weird value, such as \cppinline{-99}. Using NaN in this case is clearer.

\item \cppinline{fpi}\itt{fpi} and \cppinline{dpi}\itt{dpi}. This is the \cppinline{float} and \cppinline{double} closest representation of the number $\pi = 3.14519...$.

\item \cppinline{finf}\itt{finf} and \cppinline{dinf}\itt{dinf}. This is the \cppinline{float} and \cppinline{double} representation of the positive infinity. The positive infinity is larger than any other finite value.
\end{itemize}

We now present the functions provided by this support library. One of the responsibilities of this library is to bring vectorized versions of standard mathematical functions that only work for scalar values. Since these functions are fairly common and well known, we will not describe their signature and behavior, and instead just list them here:

\begin{itemize}
\item exponentiation: \cppinline{sqrt}\itt{sqrt}, \cppinline{pow}\itt{pow},
\item trigonometry: \cppinline{cos}\itt{cos}, \cppinline{sin}\itt{sin}, \cppinline{tan}\itt{tan}, \cppinline{acos}\itt{acos}, \cppinline{asin}\itt{asin}, \cppinline{atan}\itt{atan}, \cppinline{cosh}\itt{cosh}, \cppinline{sinh}\itt{sinh}, \cppinline{tanh}\itt{tanh}, \cppinline{acosh}\itt{acosh}, \cppinline{asinh}\itt{asinh}, \cppinline{atanh}\itt{atanh},
\item exponentials and logarithms: \cppinline{exp}\itt{exp}, \cppinline{log}\itt{log}, \cppinline{log2}\itt{log2}, \cppinline{log10}\itt{log10},
\item special functions: \cppinline{erf}\itt{erf}, \cppinline{erfc}\itt{erfc}, \cppinline{tgamma}\itt{tgamma},
\item rounding: \cppinline{ceil}\itt{ceil}, \cppinline{floor}\itt{floor}, \cppinline{round}\itt{round},
\item absolute value: \cppinline{fabs}\itt{fabs}.
\end{itemize}

We also introduce the functions \cppinline{bessel_j0}\itt{bessel_j0}, \cppinline{bessel_j1}\itt{bessel_j1}, \cppinline{bessel_y0}\itt{bessel_y0}, \cppinline{bessel_y1}\itt{bessel_y1}, \cppinline{bessel_i0}\itt{bessel_i0}, \cppinline{bessel_i1}\itt{bessel_i1}, \cppinline{bessel_k0}\itt{bessel_k0}, \cppinline{bessel_k1}\itt{bessel_k1}. The scalar version of the first four are provided by the C++ standard, while the last four are provided by the \texttt{gsl}.

We now list the other, less common functions provided in this library. These are grouped by sections.

\subsection{Low level mathematics}

\begin{itemize}
\item \vectorfunc \cppinline|double e10(double)| \itt{e10}

\item \vectorfunc \cppinline|T sqr(T)| \itt{sqr}

\item \vectorfunc \cppinline|T invsqr(T)| \itt{invsqr}

\item \vectorfunc \cppinline|T clamp(T t, mi, ma)| \itt{clamp}

\item \vectorfunc \cppinline|bool finite(T)| \itt{finite}

\item \vectorfunc \cppinline|bool nan(T)| \itt{nan}

\item \vectorfunc \cppinline|int_t sign(T)| \itt{sign}
\end{itemize}

\subsection{Sequences and bins}

\begin{itemize}
\item \cppinline|vec1u rgen(T)| \itt{rgen}

\cppinline|vec<1,T> rgen(T i, j)|

\cppinline|vec1d rgen(T i, j, n)|

\cppinline|vec1d rgen_log(T i, j, n)| \itt{rgen_log}

\item \cppinline|vec<2,T> make_bins(T mi, ma)| \itt{make_bins}

\cppinline|vec<2,T> make_bins(T mi, ma, uint_t n)|

\cppinline|vec<2,T> make_bins(vec<1,T>)|

\item \vectorfunc \cppinline|bool in_bin(T v, vec<1,U> b)| \itt{in_bin}

\vectorfunc \cppinline|bool in_bin(T v, vec<2,U> b, uint_t ib)|

\vectorfunc \cppinline|bool in_bin_open(T v, vec<2,U> b, uint_t ib)| \itt{in_bin_open}

\item \cppinline|vec<1,T> bin_center(vec<2,T>)| \itt{bin_center}
\cppinline|T bin_center(vec<1,T>)|

\item \cppinline|vec<1,T> bin_width(vec<2,T>)| \itt{bin_width}
\cppinline|T bin_width(vec<1,T>)|
\end{itemize}

\subsection{Randomization}

\begin{itemize}
\item \cppinline|auto make_seed(T)| \itt{make_seed}

\item \cppinline|double randomn(auto seed)| \itt{randomn}

\cppinline|vec<N,double> randomn(auto seed, ...)|

\item \cppinline|double randomu(auto seed)| \itt{randomn}

\cppinline|vec<N,double> randomu(auto seed, ...)|

\item \cppinline|T randomi(auto seed, T mi, T ma)| \itt{randomi}

\cppinline|vec<N,T> randomi(auto seed, T mi, T ma, ...)|

\item \cppinline|T random_pdf(auto seed, vec<1,T> x, vec<1,U> y, ...)| \itt{random_pdf}

\item \cppinline|bool random_coin(auto seed, double p)| \itt{random_coin}

\cppinline|vec<N,bool> random_coin(auto seed, double p, ...)|

\item \cppinline|vec shuffle(vec, auto seed)| \itt{shuffle}

\cppinline|void inplace_shuffle(vec&, auto seed)| \itt{inplace_shuffle}
\end{itemize}

\subsection{Reduction}

\begin{itemize}
\item \cppinline|void run_dim_idx(uint_t d, F f, ...)| \itt{run_dim_idx}

\item \cppinline|vec<D-1,T> run_dim(vec<D,T> v, uint_t d, F f)| \itt{run_dim}

\item \cppinline|T total(vec<D,T> v)| \itt{total}

\cppinline|vec<D-1,T> partial_total(uint_t d, vec<D,T> v)| \itt{partial_total}

\item \cppinline|uint_t count(vec<D,bool> v)| \itt{count}

\cppinline|vec<D-1,uint_t> partial_count(uint_t d, vec<D,bool> v)| \itt{partial_count}

\item \cppinline|uint_t fraction_of(vec<D,bool> v)| \itt{fraction_of}

\cppinline|vec<D-1,uint_t> partial_fraction_of(uint_t d, vec<D,bool> v)| \itt{partial_fraction_of}

\item \cppinline|double mean(vec v)| \itt{mean}

\cppinline|vec<D-1,double> partial_mean(uint_t d, vec<D,T> v)| \itt{partial_mean}

\item \cppinline|T median(vec<D,T> v)| \itt{median}

\cppinline|T inplace_median(vec<D,T>& v)| \itt{inplace_median}

\cppinline|vec<D-1,T> partial_median(uint_t d, vec<D,T> v)| \itt{partial_median}

\item \cppinline|T percentile(vec<D,T> v, double p)| \itt{percentile}

\cppinline|vec<D-1,T> partial_percentile(uint_t d, vec<D,T> v, double p)| \itt{partial_percentile}

\cppinline|vec<1,T> percentiles(vec<D,T> v, double ...)| \itt{percentiles}

\item \cppinline|T min(vec<D,T> v)| \itt{min}

\cppinline|T min(vec<D,T> v, uint_t& i)|

\cppinline|vec<D-1,T> partial_min(uint_t d, vec<D,T> v)| \itt{partial_min}

\cppinline|T max(vec<D,T> v)| \itt{max}

\cppinline|T max(vec<D,T> v, uint_t& i)|

\cppinline|vec<D-1,T> partial_max(uint_t d, vec<D,T> v)| \itt{partial_max}

\item \cppinline|uint_t min_id(vec v)| \itt{min_id}

\cppinline|uint_t max_id(vec v)| \itt{max_id}

\item \cppinline|vec1u histogram(vec v, vec<2,V> b)| \itt{histogram}

\cppinline|vec<1,W> histogram(vec<D,T> v, vec<D,W> w, vec<2,U> b)|

\item \cppinline|vec2u histogram2d(vec x, y, vec<2,U> bx, by)| \itt{histogram2d}

\item \cppinline|vec<D,bool> sigma_clip(vec<D,T> v, double pl, double pu)| \itt{sigma_clip}

\item \cppinline|vec<D,bool> mad_clip(vec<D,T> v, double s)| \itt{mad_clip}

\end{itemize}

\subsection{Interpolation}

\begin{itemize}
\item \cppinline|double interpolate(double y1, y2, x1, x2, x)| \itt{interpolate}

\cppinline|T interpolate(vec<D,T> y, vec<D,U> x, V nx)|

\cppinline|vec<D2,T> interpolate(vec<D1,T> y, vec<D1,U> x, vec<D2,V> nx)|

\item \cppinline|T bilinear(vec<2,T> m, double x, y)| \itt{bilinear}

\item \cppinline|vec<2,T> rebin(vec<2,T> m, vec1d mx, my, nx, ny)| \itt{rebin}
\end{itemize}

\subsection{Calculus}

\begin{itemize}
\item \cppinline|double derivate1(F f, double x, e)| \itt{derivate1}

\cppinline|double derivate1(F f, vec1d x, double e, uint_t i)| \itt{derivate1}

\item \cppinline|double derivate2(F f, double x, e)| \itt{derivate2}

\cppinline|double derivate2(F f, vec1d x, double e, uint_t i)| \itt{derivate2}

\item \cppinline|double integrate_trap(F f, double x, uint_t n)| \itt{integrate_trap}

\cppinline|double integrate(F f, double x, e = default)| \itt{integrate}

\item \cppinline|double integrate(vec<1,T> x, y)| \itt{integrate}

\cppinline|double integrate(vec<1,T> x, y, double x0, x1)|

\cppinline|double integrate(vec<2,T> x, y)|

\cppinline|double integrate(vec<2,T> x, y, double x0, x1)|

\end{itemize}

\subsection{Algebra}

\begin{itemize}
\item \cppinline|vec<2,T> mmul(vec<2,T> a, b)| \itt{mmul}

\cppinline|vec<1,V> mmul(vec<2,T> a, vec<1,U> b)|

\cppinline|vec<1,V> mmul(vec<1,T> b, vec<2,U> a)|

\item \cppinline|vec<2,T> transpose(vec<2,T>)| \itt{transpose}

\item \cppinline|vec<1,T*> diagonal(vec<2,T>)| \itt{diagonal}

\item \cppinline|vec2d identity_matrix(uint_t)| \itt{identity_matrix}

\item \cppinline|vec2d scale_matrix(double sx, sy)| \itt{scale_matrix}

\cppinline|vec2d scale_matrix(double s)|

\item \cppinline|vec2d translation_matrix(double dx, dy)| \itt{translation_matrix}

\item \cppinline|vec2d rotation_matrix(double a)| \itt{rotation_matrix}

\item \cppinline|vec1d point2d(double x, y)| \itt{point2d}

\item \lapack \cppinline|bool invert(vec2d a, vec2d& i)| \itt{invert}

\lapack \cppinline|bool inplace_invert(vec2d&)| \itt{inplace_invert}

\item \lapack \cppinline|bool invert_symmetric(vec2d a, vec2d& i)| \itt{invert_symmetric}

\lapack \cppinline|bool inplace_invert_symmetric(vec2d&)| \itt{inplace_invert_symmetric}

\item \lapack \cppinline|bool solve_symmetric(vec2d a, vec1d b, vec1d& r)| \itt{solve_symmetric}

\lapack \cppinline|bool inplace_solve_symmetric(vec2d& a, vec1d& b)| \itt{inplace_solve_symmetric}

\item \lapack \cppinline|bool eigen_symmetric(vec2d a, vec1d& va, vec1d& ve)| \itt{eigen_symmetric}

\lapack \cppinline|bool inplace_eigen_symmetric(vec2d& a, vec1d& va)| \itt{inplace_eigen_symmetric}

\item \fftw \cppinline|vec2cd fft(vec2d)| \itt{fft}

\fftw \cppinline|vec2d ifft(vec2cd)| \itt{ifft}

\item \cppinline|vec<1,W> convolve(vec<1,T> x, vec<1,U> y, vec<1,V> k)| \itt{convolve}

\end{itemize}

\subsection{Fitting}

\begin{itemize}
\item \cppinline|auto linfit(vec y, e, ...)| \itt{linfit}

\cppinline|auto linfit_pack(vec y, e, x)| \itt{linfit_pack}

\item \cppinline|auto affinefit(vec y, e, x)| \itt{affinefit}

\item \cppinline|auto mpfit(F d, vec1d p, auto opt = default)| \itt{mpfit}

\item \cppinline|auto mpfitfun(vec y, e, x, F f, vec1d p, auto opt = default)| \itt{mpfitfun}

\end{itemize}

\subsection{Geometry}

\begin{itemize}
\item \cppinline|vec1u convex_hull(vec x, y)| \itt{convex_hull}

\item \cppinline|bool is_hull_closed(vec1u h, vec hx, hy)| \itt{is_hull_closed}

\item \vectorfunc \cppinline|bool in_convex_hull(T x, y, vec1u h, vec hx, hy)| \itt{in_convex_hull}

\item \vectorfunc \cppinline|double convex_hull_distance(T x, y, vec1u h, vec hx, hy)| \itt{convex_hull_distance}

\item \vectorfunc \cppinline|double angdistr(double ra1, dec1, ra2, dec2)| \itt{angdistr}

\vectorfunc \cppinline|double angdist(double ra1, dec1, ra2, dec2)| \itt{angdist}

\item \cppinline|vec<D,bool> angdist_less(vec<D,double> ra1, dec1, double ra2, dec2)| \itt{angdist_less}

\item \cppinline|void move_ra_dec(double& ra, dec, double dra, ddec)| \itt{move_ra_dec}

\cppinline|void move_ra_dec(vec<D,double>& ra, dec, double dra, ddec)|

\end{itemize}

\subsection{Debug functions}

\begin{itemize}
\item \cppinline|void data_info(vec)| \itt{data_info}
\item \cppinline|void mprint(vec<2,T>)| \itt{mprint}
\end{itemize}

\section{Parallel execution \label{SEC:support:thread}}
% thread.hpp

\begin{itemize}
\item \cppinline|void fork(string)| \itt{fork}

\cppinline|void spawn(string)| \itt{spawn}

\item \cppinline|auto thread::pool(uint_t)| \itt{thread::pool}

\item \cppinline|void thread::sleep_for(double)| \itt{thread::sleep_for}
\end{itemize}

\section{FITS input/output \label{SEC:support:fits}}
% fits.hpp

The FITS (Flexible Image Transport System) format is a general purpose file format developed for astrophysics data. In particular, FITS files can store images with floating point pixel values, image cubes, but also binary data tables with an arbitrary number of columns and rows. Using a meta-data system (FITS keywords), FITS files usually carry a number of important additional informations about their content. E.g., for images files, the mapping between image pixels and sky coordinates (WCS coordinates), or the physical unit of the pixel values.

Storying data tables in binary inside FITS files is a space-efficient and fast way to store and read non-image data. FITS tables come in two fashions: row-oriented and column-oriented tables. In row-oriented tables, all the data about one row (e.g., about one galaxy in the table) is stored contiguously on disk. This means that it is very fast to retrieve all the information about a given object. In column-oriented tables however, a whole column is stored contiguously in memory. This means that it is very fast to read a given column for all the objects in the table. Due to the way the \phypp library is designed, it is more efficient to use the latter format, since a given column of the file will be represented by a single \phypp vector. It also brings the nice advantage of allowing to store columns of different lengths, e.g.~to combine two tables in the same file, or to carry meta-data that would be hard to store in the standard FITS keywords. The column-oriented format is not well known, but most softwares and libraries do support it\footnote{Topcat does. In IDL, column-oriented FITS files are supported by the \cppinline{mrdfits} and \cppinline{mwrfits} procedures.}.

Finally, note that this support library introduces a new type: \cppinline{fits::header} (that we will shorten to \cppinline{header} in the following). This type is used to store the header of any FITS file. For now, it is actually just a raw \cppinline{std::string}, but that might change in the future.

We now describe the various functions offered by this library, split into categories.

\subsection{Generic header functions \label{SEC:support:fits:header}}

\begin{itemize}
\item \cppinline|header fits::read_header(string f)| \itt{fits::read_header}

\cppinline|header fits::read_header_hdu(string f, uint_t hdu)|

\cppinline|header fits::read_header_sectfits(string f, uint_t s)|

\item \cppinline|bool fits::getkey(header hdr, string k, T& v)| \itt{fits::getkey}

\item \cppinline|bool fits::setkey(header hdr, string k, T& v, string c = "")| \itt{fits::setkey}


\end{itemize}

\subsection{FITS images input/output \label{SEC:support:fits:image}}

\begin{itemize}
\item \cppinline|uint_t fits::file_axes(string)| \itt{fits::file_axes}

\item \cppinline|vec1u fits::file_dimensions(string)| \itt{fits::file_dimensions}

\item \cppinline|bool fits::is_cube(string)| \itt{fits::is_cube}

\item \cppinline|bool fits::is_image(string)| \itt{fits::is_image}

\item \cppinline|void fits::read(string f, vec& v)| \itt{fits::read}

\cppinline|void fits::read(string f, vec& v, header& hdr)|

\cppinline|void fits::read_hdu(string f, vec& v, uint_t hdu)| \itt{fits::read_hdu}

\cppinline|void fits::read_hdu(string f, vec& v, uint_t hdu, header& hdr)|

\item \cppinline|vec1s fits::read_sectfits(string f)| \itt{fits::read_sectfits}

\item \cppinline|void fits::write(string f, vec v)| \itt{fits::write}

\cppinline|void fits::write(string f, vec v, header hdr)|

\item \cppinline|void fits::display(string f)| \itt{fits::display}

\cppinline|void fits::display(string r, string g)|

\cppinline|void fits::display(string r, string g, string b)|

\end{itemize}

\subsection{WCS coordinates \label{SEC:support:fits:wcs}}

\begin{itemize}
\item \cppinline|bool fits::make_wcs_header(auto p, header& hdr)| \itt{fits::make_wcs_header}

\cppinline|bool fits::make_wcs_header(vec1s p, header& hdr)|

\item \cppinline|header fits::filter_wcs(header)| \itt{fits::filter_wcs}

\item \cppinline|auto fits::extast(header)| \itt{fits::extast}

\item \cppinline|void fits::ad2xy(auto wcs, vec ra, dec, vec& x, y)| \itt{fits::ad2xy}

\cppinline|void fits::xy2ad(auto wcs, vec ra, dec, vec& x, y)| \itt{fits::xy2ad}

\item \cppinline|bool fits::get_pixel_size(string file, double& a)| \itt{fits::get_pixel_size}

\end{itemize}

\subsection{FITS tables input/output \label{SEC:support:fits:table}}

\begin{itemize}
\item \cppinline|vec<1,auto> fits::read_table_columns(string)| \itt{fits::read_table_columns}

\item \cppinline|void fits::read_table(string f, ...)| \itt{fits::read_table}

\cppinline|void fits::read_table_loose(string f, ...)| \itt{fits::read_table_loose}

\item \cppinline|void fits::write_table(string f, ...)| \itt{fits::write_table}

\cppinline|void fits::update_table(string f, ...)| \itt{fits::update_table}

\end{itemize}


\section{Image processing \label{SEC:support:image}}
% image.hpp

\begin{itemize}
\item \cppinline|vec<2,T> enlarge(vec<2,T> v, array {l1, l2, u1, u2}, T d = 0)| \itt{enlarge}

\cppinline|vec<2,T> enlarge(vec<2,T> v, uint_t u, T d = 0)|

\item \cppinline|vec<2,T> shrink(vec<2,T> v, array {l1, l2, u1, u2})| \itt{shrink}

\cppinline|vec<2,T> shrink(vec<2,T> v, uint_t u)|

\item \cppinline|void subregion(vec<2,T> v, vec1i r, vec1u& rr, rs)| \itt{subregion}

\cppinline|void subregion(vec<2,T> v, vec1i r, T d = 0)|

\item \cppinline|vec<2,T> translate(vec<2,T> v, double x, y, T d = 0)| \itt{translate}

\item \cppinline|vec2d circular_mask(vec1u d, vec1d c, double r)| \itt{circular_mask}

\item \cppinline|vec<1,T> radial_profile(vec<2,T> m, uint_t n)| \itt{radial_profile}

\item \cppinline|vec<2,T> generate_img(array {w,h}, F f)| \itt{generate_img}

\item \cppinline|vec2d gaussian_profile(array {w,h}, double sigma)| \itt{gaussian_profile}

\item \cppinline|vec<2,T> convolve2d(vec<2,T> m, vec<2,U> k)| \itt{convolve2d}

\item \cppinline|vec<2,T> boxcar(vec<2,T> m, uint_t n, F f)| \itt{boxcar}
\end{itemize}

\section{Astrophysics \label{SEC:support:astro}}
% astro.hpp

\subsection{PSF fitting}

\begin{itemize}
\item \itt{make_psf}\begin{cppcode}
bool make_psf(array<uint_t> {w, h}, double x0, y0,
              string model, vec2d& psf)
\end{cppcode}

\item \cppinline|auto psffit(vec<2,T> m, e, psf, vec1i pos)| \itt{psffit}

\cppinline|auto psffit(vec<2,T> m, e, psf)|
\end{itemize}

\subsection{Cosmology}

\begin{itemize}
\item \cppinline|auto get_cosmo()| \itt{get_cosmo}

\cppinline|vec1s cosmo_list()| \itt{cosmo_list}

\cppinline|auto cosmo_wmap()| \itt{cosmo_wmap}

\cppinline|auto cosmo_plank()| \itt{cosmo_plank}

\cppinline|auto cosmo_std()| \itt{cosmo_std}

\item \vectorfunc \cppinline|T lumdist(T z, auto cosmo)| \itt{lumdist}

\item \vectorfunc \cppinline|T lookback_time(T z, auto cosmo)| \itt{lookback_time}

\item \vectorfunc \cppinline|T vuniverse(T z, auto cosmo)| \itt{vuniverse}
\end{itemize}

\subsection{Fluxes, magnitudes and luminosities}

\begin{itemize}
\item \cppinline|T lsun2uJy(T z, d, lam, lum)| \itt{lsun2uJy}

\cppinline|T uJy2lsun(T z, d, lam, lum)| \itt{uJy2lsun}

\item \cppinline|T lsun2mag(T lam, lum, double zp = 23.9)| \itt{lsun2mag}

\cppinline|T mag2lsun(T lam, lum, double zp = 23.9)| \itt{mag2lsun}

\item \cppinline|T uJy2mag(T flx, double zp = 23.9)| \itt{uJy2mag}

\cppinline|T mag2uJy(T mag, double zp = 23.9)| \itt{mag2uJy}

\item \cppinline|auto read_filter_db(string)| \itt{read_filter_db}

\item \cppinline|auto get_filter(auto db, string name)| \itt{get_filter}

\cppinline|auto get_filters(auto db, vec1s names)| \itt{get_filters}

\item \cppinline|double sed2flux(auto fil, vec<1,T> lam, sed)| \itt{sed2flux}

\cppinline|vec1d sed2flux(auto fil, vec<2,T> lam, sed)|

\item \cppinline|double sed_convert(auto from, to, double z, d, vec<1,T> lam, sed)| \itt{sed_convert}

\item \cppinline|double lir_8_1000(vec<1,T> lam, sed)| \itt{lir_8_1000}
\end{itemize}

\subsection{Sky coordinates}

\begin{itemize}
\item \cppinline|double field_area_hull(vec1u hull, vec ra, dec)| \itt{field_area_hull}

\cppinline|double field_area_hull(vec ra, dec)|

\item \cppinline|double field_area_h2d(vec ra, dec)| \itt{field_area_h2d}

\item \cppinline|double field_area(vec ra, dec)| \itt{field_area}

\item \cppinline|vec1d angcorrel(vec<D1,T> ra, dec, vec<D2,U> rra, rdec, vec<2,V> b)| \itt{angcorrel}

\item \itt{randpos_uniform} \begin{cppcode}
auto randpos_uniform(auto seed, vec1d rra, rdec, F in,
                     vec& ra, dec, auto options = default)
\end{cppcode}

\item \itt{randpos_power_circle} \begin{cppcode}
auto randpos_power_circle(auto seed, double ra0, dec0, r0,
                          vec& ra, dec, auto options = default)
\end{cppcode}

\item \itt{randpos_power} \begin{cppcode}
auto randpos_power(auto seed, vec1u h, vec<D1,double> hra, hdec,
                   vec& ra, dec, auto options = default)
\end{cppcode}

\item \vectorfunc \cppinline|bool sex2deg(string sra, sdec, T& ra, dec)| \itt{sex2deg}

\vectorfunc \cppinline|void deg2sex(T ra, dec, string& sra, sdec)| \itt{deg2sex}

\item \itt{qxmatch} \begin{cppcode}
auto qxmatch(vec<1,T> ra1, dec1, ra2, dec2,
             auto options = default)
\end{cppcode}

\item \cppinline|vec2d qdist(vec<1,T> ra, dec, auto options = default)| \itt{qdist}
\end{itemize}

\subsection{Catalog management}
% astro/catalog_merge.hpp

\begin{itemize}
\item \cppinline|bool get_band(auto cat, string band, uint_t& b)| \itt{get_band}

\cppinline|bool get_band(auto cat, string band, note, uint_t& b)| \itt{get_band}
\end{itemize}

\subsection{Image stacking}
% astro/qstack.hpp

\begin{itemize}
\item \itt{pick_sources} \begin{cppcode}
bool pick_sources(vec<2,T> m, vec1d x, y, uint_t hs,
                  vec<3,T>& c, vec1u& ids)
\end{cppcode}

\item \itt{qstack} \begin{cppcode}
auto qstack(vec<1,T> ra, dec, string ff, uint_t hs, vec<3,T>& fc,
            vec1u& i, auto options = default)
\end{cppcode}

\begin{cppcode}
auto qstack(vec<1,T> ra, dec, string ff, fw, uint_t hs,
            vec<3,T>& fc, wc, vec1u& i, auto options = default)
\end{cppcode}

\item \cppinline|auto qstack_mean(vec<3,T> fc)| \itt{qstack_mean}

\cppinline|auto qstack_mean(vec<3,T> fc, wc)|

\item \cppinline|auto qstack_median(vec<3,T> fc)| \itt{qstack_median}

\item \cppinline|void qstack_bootstrap(vec<3,T> fc, uint_t nb, ns, auto seed, F f)| \itt{qstack_bootstrap}

\cppinline|void qstack_bootstrap(vec<3,T> fc, wc, uint_t nb, ns, auto seed, F f)|

\cppinline|void qstack_bootstrap(uint_t nb, ns, auto seed, F f, ...)|

\item \cppinline|vec<3,T> qstack_mean_bootstrap(vec<3,T> fc, uint_t nb, ns, auto seed)| \itt{qstack_mean_bootstrap}

\cppinline|vec<3,T> qstack_mean_bootstrap(vec<3,T> fc, wc, uint_t nb, ns, auto seed)|

\item \cppinline|vec<3,T> qstack_median_bootstrap(vec<3,T> fc, uint_t nb, ns, auto seed)| \itt{qstack_median_bootstrap}
\end{itemize}

\subsection{Template fitting}
% astro/qstack.hpp

\begin{itemize}
\item \cppinline|vec2d template_observed(auto lib, double z, d, auto filters)| \itt{template_observed}

\cppinline|vec2d template_observed(auto lib, vec1d z, d, auto filters)|

\item \vectorfunc \cppinline|double limweight(double)| \itt{limweight}

\item \itt{template_fit} \begin{cppcode}
auto template_fit(auto lib, auto seed, T z, d, vec1d flux, err,
                  auto filters, auto options = default)
\end{cppcode}
\end{itemize}

\chapter{Tools \label{SEC:tool}}

\section{Astrophysics \label{SEC:tool:astro}}
\subsection{\texttt{angcorrel}} \itt{angcorrel}
\subsection{\texttt{catinfo}} \itt{catinfo}
\subsection{\texttt{deg2sex} and \texttt{sex2deg}} \itt{deg2sex} \itt{sex2deg}
\subsection{\texttt{findsrc}} \itt{findsrc}
\subsection{\texttt{fluxcube}} \itt{fluxcube}
\subsection{\texttt{getgal}} \itt{getgal}
\subsection{\texttt{photinfo}} \itt{photinfo}
\subsection{\texttt{psffit}} \itt{psffit}
\subsection{\texttt{qstack2}} \itt{qstack2}
\subsection{\texttt{qxmatch2}} \itt{qxmatch2}
\subsection{\texttt{randsrc}} \itt{randsrc}
\subsection{\texttt{subsrc}} \itt{subsrc}

\section{FITS and ASCII \label{SEC:tool:fits}}
\subsection{\texttt{fits2ascii}} \itt{fits2ascii}
\subsection{\texttt{fitstool}} \itt{fitstool}
\subsection{\texttt{imgtool}} \itt{imgtool}
\subsection{\texttt{qconvol}} \itt{qconvol}
\subsection{\texttt{remcol}} \itt{remcol}


\printindex

\end{document}
